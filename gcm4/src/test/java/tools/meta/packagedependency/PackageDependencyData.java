package tools.meta.packagedependency;

import java.nio.file.Path;
import java.util.LinkedHashSet;
import java.util.Set;

import tools.meta.packagedependency.reports.PackageDependencyReport;
import util.graph.Graph;
import util.graph.MutableGraph;

/**
 * An immutable container for holding the primary level of package dependency
 * analysis data. It is generated by the
 * {@linkplain PackageDependencyDataGenerator} and is used by the
 * {@linkplain PackageDependencyReport}
 * 
 */
public final class PackageDependencyData {

	public final static class PackageRef {
		private String name;

		public PackageRef(String name) {
			this.name = name;
		}

		public String getName() {
			return name;
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + ((name == null) ? 0 : name.hashCode());
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj) {
				return true;
			}
			if (!(obj instanceof PackageRef)) {
				return false;
			}
			PackageRef other = (PackageRef) obj;
			if (name == null) {
				if (other.name != null) {
					return false;
				}
			} else if (!name.equals(other.name)) {
				return false;
			}
			return true;
		}

		@Override
		public String toString() {
			StringBuilder builder = new StringBuilder();
			builder.append("PackageRef [name=");
			builder.append(name);
			builder.append("]");
			return builder.toString();
		}

	}

	public final static class PackageDependencyDetails {
		private final Set<Class<?>> classes;

		public PackageDependencyDetails(Set<Class<?>> classes) {
			this.classes = new LinkedHashSet<>(classes);
		}

		public Set<Class<?>> getClasses() {
			return new LinkedHashSet<>(classes);
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + ((classes == null) ? 0 : classes.hashCode());
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj) {
				return true;
			}
			if (!(obj instanceof PackageDependencyDetails)) {
				return false;
			}
			PackageDependencyDetails other = (PackageDependencyDetails) obj;
			if (classes == null) {
				if (other.classes != null) {
					return false;
				}
			} else if (!classes.equals(other.classes)) {
				return false;
			}
			return true;
		}

		@Override
		public String toString() {
			StringBuilder builder = new StringBuilder();
			builder.append("PackageDependencyDetails [classes=");
			builder.append(classes);
			builder.append("]");
			return builder.toString();
		}

	}

	private static class Data {
		private Graph<PackageRef, PackageDependencyDetails> graph = new MutableGraph<PackageRef, PackageDependencyDetails>().toGraph();
		private Set<Class<?>> wildCardClasses = new LinkedHashSet<>();
		private Set<Class<?>> packagelessClasses = new LinkedHashSet<>();
		private Set<Class<?>> uncoveredClasses = new LinkedHashSet<>();
		private Set<Path> directories = new LinkedHashSet<>();
		private Set<String> packageNames = new LinkedHashSet<>();
	}

	public final static Builder builder() {
		return new Builder();
	}

	public final static class Builder {
		private Builder() {

		}

		private Data data = new Data();

		public PackageDependencyData build() {
			try {
				return new PackageDependencyData(data);
			} finally {
				data = new Data();
			}
		}

		/**
		 * Adds a constructor warning
		 * 
		 * @throws NullPointerException
		 *             <li>if the graph is null</li>
		 */
		public Builder setGraph(Graph<PackageRef, PackageDependencyDetails> graph) {
			if (graph == null) {
				throw new NullPointerException("graph is null");
			}
			data.graph = graph;
			return this;
		}

		/**
		 * Adds a wildcard class reference. A wildcard class is one containing a
		 * wildcard character in its import statements
		 * 
		 * 
		 * @throws NullPointerException
		 *             <li>if the wildcard class is null</li>
		 */
		public Builder addWildCardClass(Class<?> wildcardClass) {
			if (wildcardClass == null) {
				throw new NullPointerException("wildcard class is null");
			}
			data.wildCardClasses.add(wildcardClass);
			return this;
		}

		/**
		 * Adds a packageless class reference. A packageless class is one having
		 * not package statement
		 * 
		 * 
		 * @throws NullPointerException
		 *             <li>if the wildcard class is null</li>
		 */
		public Builder addPackagelessClass(Class<?> packagelessClass) {
			if (packagelessClass == null) {
				throw new NullPointerException("packageless class is null");
			}
			data.packagelessClasses.add(packagelessClass);
			return this;

		}

		/**
		 * Adds an uncovered class reference. An uncovered class is a java class
		 * found in the scanned directories that does not match any of the
		 * contributed package names.
		 * 
		 * 
		 * @throws NullPointerException
		 *             <li>if the wildcard class is null</li>
		 */
		public Builder addUncoveredClass(Class<?> uncoveredClass) {
			if (uncoveredClass == null) {
				throw new NullPointerException("uncovered class is null");
			}
			data.uncoveredClasses.add(uncoveredClass);
			return this;
		}

		/**
		 * Adds a covered directory.
		 * 
		 * 
		 * @throws NullPointerException
		 *             <li>if the directory is null</li>
		 */
		public Builder addCoveredDirectory(Path directory) {
			if (directory == null) {
				throw new NullPointerException("directory is null");
			}
			data.directories.add(directory);
			return this;
		}

		/**
		 * Adds a covered directory.
		 * 
		 * 
		 * @throws NullPointerException
		 *             <li>if the package name is null</li>
		 */
		public Builder addCoveredPackageName(String packageName) {
			if (packageName == null) {
				throw new NullPointerException("package name is null");
			}
			data.packageNames.add(packageName);
			return this;
		}

	}

	private final Data data;

	private PackageDependencyData(Data data) {
		this.data = data;
	}

	public Graph<PackageRef, PackageDependencyDetails> getPackageDependencyGraph() {
		return data.graph;
	}

	public Set<Class<?>> getWildcardClasses() {
		return new LinkedHashSet<>(data.wildCardClasses);
	}

	public Set<Class<?>> getPackagelessClasses() {
		return new LinkedHashSet<>(data.packagelessClasses);
	}

	public Set<Class<?>> getUncoveredClasses() {
		return new LinkedHashSet<>(data.uncoveredClasses);
	}

	public Set<Path> getCoveredDirectories() {
		return new LinkedHashSet<>(data.directories);
	}

	public Set<String> getCoveredPackageNames() {
		return new LinkedHashSet<>(data.packageNames);
	}

}
