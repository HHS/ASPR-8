package nucleus;

import java.util.function.Consumer;

import util.ContractException;

/**
 * A report context provides access to the nucleus engine and published data
 * views to reports. It is supplied by the engine each time it interacts with a
 * report. Reports are defined by this context. If this context is passed to a
 * method invocation, then that method is a report method. Reports cannot submit
 * events for resolution and thus cannot change the state of any data view. They
 * are passive observers of the simulation and serve to release output to the
 * output consumer registered with nucleus.
 * 
 * @author Shawn Hatch
 *
 */
public interface ReportContext extends Context {

	/**
	 * Schedules a plan that will be executed at the given time. If the plan
	 * time is less than the current time the plan is scheduled for immediate
	 * execution.
	 * 
	 * @throws ContractException
	 *             <li>{@link NucleusError#NULL_PLAN} if the plan is null
	 *             <li>{@link NucleusError#PAST_PLANNING_TIME} if the plan is
	 *             scheduled for a time in the past
	 * 
	 * 
	 */
	public void addPlan(Consumer<ReportContext> plan, double planTime);

	/**
	 * Returns the ReportId of the current report
	 */
	public ReportId getCurrentReportId();

	/**
	 * Subscribes the current report to the given event label. Events of the
	 * type T that are generated by event resolution (not events generated by
	 * agents) are matched to the event label. If a match is found, then the
	 * event will be consumed by the supplied ReportEventConsumer.
	 * 
	 * 
	 * @throws ContractException
	 *             <li>{@link NucleusError#NULL_EVENT_CLASS} if the event class
	 *             is null
	 *             <li>{@link NucleusError#NULL_EVENT_CONSUMER} if the
	 *             ReportEventConsumer is null
	 * 
	 */

	public <T extends Event> void subscribe(Class<T> eventClass, ReportEventConsumer<T> reportConsumer);


	/**
	 * Subscribes the current report to the given event label. Events of the
	 * type T that are generated by event resolution (not events generated by
	 * agents) are matched to the event label. If a match is found, then the
	 * event will be consumed by the supplied ReportEventConsumer.
	 * 
	 * 
	 * @throws ContractException
	 *             <li>{@link NucleusError#NULL_EVENT_LABEL} if the EventLabel
	 *             is null
	 *             <li>{@link NucleusError#NULL_EVENT_CONSUMER} if the
	 *             ReportEventConsumer is null
	 *             <li>{@link NucleusError#NULL_EVENT_CLASS_IN_EVENT_LABEL} if
	 *             the event class in the event label is null
	 *             <li>{@link NucleusError#NULL_LABELER_ID_IN_EVENT_LABEL} if
	 *             the event labeler id in the event label is null
	 *             <li>{@link NucleusError#UNKNOWN_EVENT_LABELER} if the event
	 *             labeler id in the event label cannot be resolved to a
	 *             registered event labeler *
	 *             <li>{@link NucleusError#NULL_PRIMARY_KEY_VALUE} if the event
	 *             label has a null primary key
	 * 
	 */
	public <T extends Event> void subscribe(EventLabel<T> eventLabel, ReportEventConsumer<T> reportEventConsumer);

	/**
	 * Subscribes the current report to have the given ReportContext consumer
	 * invoked at the end of the simulation.
	 */
	public void subscribeToSimulationClose(Consumer<ReportContext> closeHandler);
	
	/**
	 * Adds an event labeler to nucleus.
	 * 
	 * @throws ContractException
	 *             <li>{@link NucleusError#NULL_EVENT_LABELER} if the event
	 *             labeler is null
	 *             <li>{@link NucleusError#NULL_EVENT_CLASS_IN_EVENT_LABELER} if
	 *             the event class is null
	 *             <li>{@link NucleusError#NULL_LABELER_ID_IN_EVENT_LABELER} if
	 *             the event labeler contains a null labeler id
	 *             <li>{@link NucleusError#DUPLICATE_LABELER_ID_IN_EVENT_LABELER}
	 *             if the event labeler contains a labeler id that is the id of
	 *             a previously added event labeler
	 */
	public <T extends Event> void addEventLabeler(EventLabeler<T> eventLabeler);

}
