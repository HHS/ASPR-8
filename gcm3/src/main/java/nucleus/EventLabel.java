package nucleus;

import java.util.ArrayList;
import java.util.List;

import net.jcip.annotations.NotThreadSafe;
import nucleus.util.ContractException;
import util.wrappers.MultiKey;

/**
 * 
 * A generics-based class that is used to filter event observations.
 * 
 * When an actor subscribes to observe a particular type of event, it may need
 * to filter such events.
 * 
 * For example, suppose a fox(actor) has subscribed to actor movement events.
 * The fox is only interested in rabbits that are close by and is unconcerned
 * with distant rabbits or other animals. When the fox subscribes to movement
 * event observation, it uses an event label to describe this filtering. When
 * any animal moves, a movement observation event is generated by some plugin.
 * Nucleus will then generate an event label from the event using a registered
 * event-labeler. If this generated event label matches, via equality, the event
 * label used by the fox, then the fox will receive the movement observation
 * event.
 * 
 * Event labels are paired with event labelers. A data manager registers an
 * event labeler in anticipation of actors needing to use the corresponding
 * event labels. Event labels remain active until the actor unsubscribes them.
 * 
 * 
 * @author Shawn Hatch
 *
 * @param <T>
 */
@NotThreadSafe
public final class EventLabel<T extends Event> {

	private static class Data<N> {

		private Class<N> eventClass;

		private EventLabelerId labelerId;

		private final List<Object> keys = new ArrayList<>();
	}

	private final MultiKey multiKey;

	private final Class<T> eventClass;

	private final EventLabelerId labelerId;

	private final Object primaryKeyValue;

	/**
	 * Returns a new instance of the Builder class
	 * 
	 * @throws ContractException
	 * 
	 *             <li>{@linkplain NucleusError#NULL_EVENT_CLASS } if the class
	 *             reference is null</li>
	 */
	public static <N extends Event> Builder<N> builder(Class<N> classReference) {
		if (classReference == null) {
			throw new ContractException(NucleusError.NULL_EVENT_CLASS);
		}
		return new Builder<N>(classReference);
	}

	public static class Builder<N extends Event> {

		private Data<N> data = new Data<>();

		private final Class<N> eventClass;

		private Builder(Class<N> classReference) {
			this.eventClass = classReference;
		}

		private void validate() {
			if (data.keys.isEmpty()) {
				throw new ContractException(NucleusError.NULL_PRIMARY_KEY_VALUE);
			}

			if (data.labelerId == null) {
				throw new ContractException(NucleusError.NULL_LABELER_ID_IN_EVENT_LABEL);
			}
		}

		/**
		 * Constructs a new EventLabel.
		 * 
		 * @throws ContractException
		 *             <li>{@linkplain NucleusError#NULL_PRIMARY_KEY_VALUE} if
		 *             no keys were added</li>
		 *             <li>{@linkplain NucleusError#NULL_LABELER_ID_IN_EVENT_LABEL} if no
		 *             event labeler was set</li>
		 */
		public EventLabel<N> build() {
			try {
				validate();
				data.eventClass = this.eventClass;
				return new EventLabel<>(data);
			} finally {
				data = new Data<>();
			}
		}

		/**
		 * Adds a key to the event label
		 * 
		 * @throws ContractException
		 *             <li>{@linkplain NucleusError#NULL_EVENT_LABEL_KEY} if the
		 *             key is null</li>
		 */
		public Builder<N> addKey(Object key) {
			if (key == null) {
				throw new ContractException(NucleusError.NULL_EVENT_LABEL_KEY);
			}
			data.keys.add(key);
			return this;
		}

		/**
		 * Sets the event labeler for the event label
		 * 
		 * @throws ContractException
		 *             <li>{@linkplain NucleusError#NULL_EVENT_LABELER_ID} if
		 *             the labeler is null</li>
		 */
		public Builder<N> setEventLabelerId(EventLabelerId eventLabelerId) {
			if (eventLabelerId == null) {
				throw new ContractException(NucleusError.NULL_EVENT_LABELER_ID);
			}
			data.labelerId = eventLabelerId;
			return this;
		}

	}

	private EventLabel(Data<T> data) {
		this.primaryKeyValue = data.keys.get(0);
		this.eventClass = data.eventClass;
		this.labelerId = data.labelerId;
		MultiKey.Builder builder = MultiKey.builder();
		for (Object key : data.keys) {
			builder.addKey(key);
		}
		multiKey = builder.build();
	}

	/**
	 * WARNING, NON-STANDARD EQUALS CONTRACT: Nucleus only checks for equality
	 * between event labels when those labels have the same primary keys, event
	 * class types and labeler ids. Thus, within the confines of nucleus, the
	 * equality contract can ignore these values to gain efficiency.
	 */
	@Override
	public int hashCode() {
		/*
		 * Justify the use of a non-standard approach to equals: this was done
		 * to gain efficiency, but should we use a correct implementation or
		 * force this to be the only implementation class of the event label?
		 */
		return multiKey.hashCode();
	}

	/**
	 * NOTE: Nucleus only checks for equality between event labels when those
	 * labels have the same primary keys, event class types and labeler ids.
	 */

	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (!(obj instanceof EventLabel)) {
			return false;
		}
		@SuppressWarnings("rawtypes")
		EventLabel other = (EventLabel) obj;
		return multiKey.equals(other.multiKey);
	}

	/**
	 * Returns the event subclass that this label applies to.
	 */
	public Class<T> getEventClass() {
		return eventClass;
	}

	/**
	 * Returns the labeler id associated with this label. Labels can only be
	 * compared to other labels that share the same labeler id.
	 */
	public EventLabelerId getLabelerId() {
		return labelerId;
	}

	/**
	 * Returns the primary key value of any event that this label matches. This
	 * provides efficiency to the publication/subscription process and does not
	 * replace the equality comparison between labels. This label will only be
	 * matched to events that have the same primary key.
	 */
	public Object getPrimaryKeyValue() {
		return primaryKeyValue;
	}

}
