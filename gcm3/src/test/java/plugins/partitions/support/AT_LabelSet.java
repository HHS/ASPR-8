package plugins.partitions.support;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.LinkedHashSet;
import java.util.Optional;
import java.util.Set;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import plugins.compartments.support.CompartmentId;
import plugins.groups.support.GroupTypeId;
import plugins.personproperties.testsupport.TestPersonPropertyId;
import plugins.regions.support.RegionId;
import plugins.support.XTestResourceId;
import util.SeedProvider;
import util.annotations.UnitTest;
import util.annotations.UnitTestMethod;

/**
 * Test class for {@link LabelSetInfo}
 * 
 * @author Shawn Hatch
 *
 */
@UnitTest(target = LabelSet.class)

public class AT_LabelSet {
	@SuppressWarnings("unused")
	private static SeedProvider SEED_PROVIDER;

	@BeforeAll
	public static void beforeClass() {
		SEED_PROVIDER = new SeedProvider(346345534578886785L);
	}

	/**
	 * Internal test(not part of public tests) to show that there are no large
	 * gaps in the seed cases generated by the SeedProvider.
	 */
	@AfterAll
	public static void afterClass() {
		// System.out.println(AT_LabelSet.class.getSimpleName() + " " +
		// SEED_PROVIDER.generateUnusedSeedReport());
	}

	/**
	 * Tests {@linkplain LabelSet#builder()
	 */
	@Test
	@UnitTestMethod(name = "builder", args = {})
	public void testBuilder() {
		assertNotNull(LabelSet.builder());
	}

	/**
	 * Tests {@linkplain LabelSet#isEmpty()
	 */
	@Test
	@UnitTestMethod(name = "isEmpty", args = {})
	public void testIsEmpty() {

		LabelSet labelSet = LabelSet.builder().build();
		assertTrue(labelSet.isEmpty());

		labelSet = LabelSet.builder().setLabel(CompartmentId.class, "compartment label").build();
		assertFalse(labelSet.isEmpty());

		labelSet = LabelSet.builder().setLabel(GroupTypeId.class, "group label").build();
		assertFalse(labelSet.isEmpty());

		labelSet = LabelSet.builder().setLabel(RegionId.class, "region label").build();
		assertFalse(labelSet.isEmpty());

		labelSet = LabelSet.builder().setLabel(XTestResourceId.RESOURCE1, "resource label").build();
		assertFalse(labelSet.isEmpty());

		labelSet = LabelSet.builder().setLabel(TestPersonPropertyId.PERSON_PROPERTY_1_BOOLEAN_MUTABLE_NO_TRACK, "property label").build();
		assertFalse(labelSet.isEmpty());

	}

	/**
	 * Tests {@linkplain LabelSet#getLabel(Object)
	 */
	@Test
	@UnitTestMethod(name = "getLabel", args = {})
	public void testGetCompartmentLabel() {
		Object expectedCompartmentLabel = "Compartment Label";
		LabelSet labelSet = LabelSet.builder().setLabel(CompartmentId.class, expectedCompartmentLabel).build();
		Optional<Object> optionalLabel = labelSet.getLabel(CompartmentId.class);
		assertTrue(optionalLabel.isPresent());
		Object actualCompartmentLabel = optionalLabel.get();
		assertEquals(expectedCompartmentLabel, actualCompartmentLabel);

	}

	/**
	 * Tests {@linkplain LabelSet#getDimensions()
	 */
	@Test
	@UnitTestMethod(name = "getDimensions", args = {})
	public void testGetPersonPropertyLabel() {
		// getDimensions()
		LabelSet.Builder builder = LabelSet.builder();
		Set<Object> expectedDimensions = new LinkedHashSet<>();
		for (int i = 0; i < 10; i++) {
			expectedDimensions.add(i);
			builder.setLabel(i, Integer.toString(i));
		}
		LabelSet labelSet = builder.build();
		Set<Object> actualDimensions = labelSet.getDimensions();
		assertEquals(expectedDimensions, actualDimensions);
	}

	/**
	 * Tests {@linkplain LabelSet#equals(Object)
	 */
	@Test
	@UnitTestMethod(name = "equals", args = { Object.class })
	public void testEquals() {
		LabelSet labelSet1 = LabelSet.builder().setLabel(CompartmentId.class, "compartment label").build();
		LabelSet labelSet2 = LabelSet.builder().setLabel(CompartmentId.class, "compartment label").build();
		LabelSet labelSet3 = LabelSet.builder().setLabel(CompartmentId.class, "compartment label2").build();

		assertFalse(labelSet1 == labelSet2);
		assertTrue(labelSet1.equals(labelSet1));
		assertTrue(labelSet1.equals(labelSet2));
		assertTrue(labelSet2.equals(labelSet1));
		assertFalse(labelSet1.equals(labelSet3));

	}

	/**
	 * Tests {@linkplain LabelSet#hashCode()
	 */
	@Test
	@UnitTestMethod(name = "hashCode", args = {})
	public void testHashCode() {

		LabelSet labelSet1 = LabelSet.builder().setLabel(CompartmentId.class, "compartment label").build();
		LabelSet labelSet2 = LabelSet.builder().setLabel(CompartmentId.class, "compartment label").build();

		assertFalse(labelSet1 == labelSet2);
		assertEquals(labelSet1, labelSet2);
		assertEquals(labelSet1.hashCode(), labelSet2.hashCode());
	}

}
