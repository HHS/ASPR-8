[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GCM-Docs",
    "section": "",
    "text": "The General Computation Model (GCM)\nThe General Computation Model (GCM) is a Java based simulation framework for building disease progression models. Users of GCM should have a general familiarity with Java and object oriented programming and would benefit from some exposure to event based modeling.\nChanges to the documentation will be maintained in the table below:\n\nChange History\n\n\n\n\n\n\n\n\nID\nDate\nDescription\n\n\n\n\n1\n2023-09-08\nInitial GCM Documentation made available in Quarto"
  },
  {
    "objectID": "ch01-Introduction.html#who-is-this-for",
    "href": "ch01-Introduction.html#who-is-this-for",
    "title": "1  Introduction",
    "section": "1.1 Who is this for?",
    "text": "1.1 Who is this for?\nThe General Computation Model (GCM) is a Java based simulation framework for building disease progression models. Users of GCM should have a general familiarity with Java and object oriented programming and would benefit from some exposure to event based modeling."
  },
  {
    "objectID": "ch01-Introduction.html#high-level-overview",
    "href": "ch01-Introduction.html#high-level-overview",
    "title": "1  Introduction",
    "section": "1.2 High level overview",
    "text": "1.2 High level overview\n\n1.2.1 Simulation\nGCM is an event based simulation composed of data managers, actors, reports and an event engine. The data managers contain the state of the simulation and generate events when that state changes. The actors contain the business logic of your model and act on the data managers. The engine transports events generated by the data managers to any data managers and actors that subscribe to those events and manages the flow of time.\n\n\n1.2.2 Plugins\nData managers, actors and reports are organized into plugins. A GCM model is thus composed of the core simulation and a suite of plugins. The plugin architecture provides for the scalable reuse of concepts and capabilities between models. GCM contains a set of existing plugins that define many concepts useful to a broad range of models such as the management of people, their properties, social group structures and the like. The modeler is free to compose a model from their choice of plugins.\n\n\n1.2.3 Experiment\nGCM also provides a multi-threaded experiment management system. Each plugin contains zero to many data objects that define the initial state of its actors and data managers. Each such data object may be altered freely. The complete set of all combinations (scenarios) of the variant plugin data objects form an experiment and a separate simulation instance is executed for each combination."
  },
  {
    "objectID": "ch02-GettingStarted.html#hello-world-lesson-lesson-1",
    "href": "ch02-GettingStarted.html#hello-world-lesson-lesson-1",
    "title": "2  Getting Started",
    "section": "2.1 Hello World Lesson (Lesson 1)",
    "text": "2.1 Hello World Lesson (Lesson 1)\nOur first lesson is a very reduced “Hello World” example where we will execute the simulation with one line of code.\n\n\nCode Block 2.1: Building and executing an empty simulation.\npackage gov.hhs.aspr.ms.gcm.lessons;\n\nimport gov.hhs.aspr.ms.gcm.nucleus.Simulation;\n\npublic final class Example_1 {\n\n    public static void main(String[] args) {\n        Simulation.builder().build().execute();\n    }\n\n\nWith this one line we have created and executed a simulation.  Since the simulation had no actors or data managers there was nothing to do and so it terminated immediately. Let’s analyze the line in a more drawn out form:\n\n\nCode Block 2.2: Building and executing an empty simulation broken out into discrete commands.\nSimulation.Builder builder = Simulation.builder();\nSimulation simulation = builder.build();\nsimulation.execute();\n\n\nThe simulation does not have a constructor.  Instead it uses a static builder class that creates the simulation from various arguments.  The builder is immediately capable of building a simulation instance so we will skip giving it any more information.  The simulation is only capable of executing, so we execute it."
  },
  {
    "objectID": "ch02-GettingStarted.html#plugins-lesson-lesson-2",
    "href": "ch02-GettingStarted.html#plugins-lesson-lesson-2",
    "title": "2  Getting Started",
    "section": "2.2 Plugins Lesson (Lesson 2)",
    "text": "2.2 Plugins Lesson (Lesson 2)\nModels are made of plugins. In this lesson(Example2) we will add a single plugin to the simulation and execute it.\n\n\nCode Block 2.3: A simple plugin added to the simulation. Plugins act as modules for all components contributed to the simulation.\npublic final class Example_2 {\n\n    private Example_2() {\n    }\n\n    public static void main(String[] args) {\n\n        PluginId pluginId = new SimplePluginId(\"example plugin\");\n\n        Plugin plugin = Plugin.builder()//\n                .setPluginId(pluginId)//\n                .build();\n\n        Simulation.builder()//\n                .addPlugin(plugin)//\n                .build()//\n                .execute();\n    }\n\n}\n\n\nThe first thing we will need to do to build a plugin is to identify it. The PluginId is a marker interface – it has no methods and serves to help differentiate between plugin id values and other identifiers. The SimplePluginId is a convenience implementor of PluginId and will wrap any object as an identifier. In this case we use the string “example plugin”, but you are free to implement them however best fits your needs.\nNext we build the plugin. The Plugin class implements all plugins and you can provide several arguments to its builder to specify the contents and behavior of your plugin. A plugin is composed of four items:\n\nAn id\nDependencies on other plugins\nData objects used to initialize data managers, actors and reports\nAn initializer to load the data into the simulation\n\nFor now, we will only need to add the plugin id and build the plugin.\nFinally, we build the simulation by adding the plugin and then executing as usual. The result is the same as the previous lesson: nothing happens. However, internally, the simulation did add the plugin and found it had no information other than its id."
  },
  {
    "objectID": "ch02-GettingStarted.html#actors-lesson-lesson-3",
    "href": "ch02-GettingStarted.html#actors-lesson-lesson-3",
    "title": "2  Getting Started",
    "section": "2.3 Actors Lesson (Lesson 3)",
    "text": "2.3 Actors Lesson (Lesson 3)\n\nContexts\nIn all that follows(Example3), we will encounter various context objects. Contexts are interfaces into the simulation that are tailored to the thing using the context. For example, an ActorContext provides everything that an actor will need to interact with the simulation. Similarly, a DataManager context provides the capabilities needed by data managers.\nThe first context we encounter is the PluginContext. It provides the plugin with the following abilities:\n\nAdd an actor to the simulation\nAdd a data manager to the simulation\nAdd a report to the simulation\nGet plugin data\n\nThe PluginContext is passed to the plugin’s initializer and is used to add all data managers, all initial data and any actors or reports that need to exist at the beginning of the simulation run.\nThe next context will be the ActorContext. It provides actors with a wide array of capabilities that we demonstrate later. For now, the important takeaway is that being granted a context implicitly identifies the recipient as having a particular role in the simulation.\n\n\nCode Block 2.4: An initializer uses a plugin context to execute the initialization logic at the beginning of each simulation.\nPluginId pluginId = new SimplePluginId(\"example plugin\");\n\nPlugin plugin = Plugin.builder()//\n        .setPluginId(pluginId)//\n        .setInitializer(Example_3::pluginInit)//\n        .build();\n\nSimulation.builder()//\n        .addPlugin(plugin)//\n        .build()//\n        .execute();\n\n\nWe are setting the plugin’s initializer. The initializer is a method that consumes a PluginContext and returns void. For this example, we use a static local method for our initializer:\n\n\nCode Block 2.5: A single actor is being added to the simulation at initialization.\npublic static void pluginInit(PluginContext pluginContext) {\n    System.out.println(\"plugin being initialized -- we will add one actor\");\n    pluginContext.addActor(Example_3::actorInit);\n}\n\n\nWhen the simulation starts up its execution, one of the first things it will do is to execute each plugin’s initializer to give the plugin an opportunity to add actors, reports and data managers to the simulation before time and events begin to flow. Adding an actor is done with another consumer, but this time it is a consumer of ActorContext.\n\n\nCode Block 2.6: The actor prints out some identifying information when it initializes.\npublic static void actorInit(ActorContext actorContext) {\n    System.out.println(\"actor being initialized\");\n    System.out.println(\"my id = \" + actorContext.getActorId());\n    System.out.println(\"time = \" + actorContext.getTime());\n}\n\n\nAfter the plugins are initialized, the actors and data managers are next. For this example, the actor is initialized and it prints a few statements and ceases activity. Here is the resulting console output:\n\n\n\nFigure 2.1: Output from the single actor as it initializes.\n\n\n\n\n\nplugin being initialized – we will add one actor actor being initialized my id = ActorId [id=0] time = 0.0\n\n\n\n\n\n\n\n\nWe can replace the local method references above with lamdas to be more succinct.\n\n\nCode Block 2.7: A single actor writes output to the console during its initialization.\nPluginId pluginId = new SimplePluginId(\"example plugin\");\n\nPlugin plugin = Plugin.builder()//\n        .setPluginId(pluginId)//\n        .setInitializer(pluginContext -> {\n            System.out.println(\"plugin being initialized -- we will add one actor\");\n            pluginContext.addActor(actorContext -> {\n                System.out.println(\"actor being initialized\");\n                System.out.println(\"my id = \" + actorContext.getActorId());\n                System.out.println(\"time = \" + actorContext.getTime());\n            });\n        })//\n        .build();\n\nSimulation.builder()//\n        .addPlugin(plugin)//\n        .build()//\n        .execute();"
  },
  {
    "objectID": "ch02-GettingStarted.html#data-managers-lesson-lesson-4",
    "href": "ch02-GettingStarted.html#data-managers-lesson-lesson-4",
    "title": "2  Getting Started",
    "section": "2.4 Data Managers Lesson (Lesson 4)",
    "text": "2.4 Data Managers Lesson (Lesson 4)\nWe extend the previous lesson by slightly altering the actor and adding a data manager. But first let’s list some of the attributes of data managers, actors and reports to better understand the roles they play in the simulation. Reports are presented in detail in a later chapter.\n\nData Managers\n\nExist for the full duration of the simulation\nContain and maintain the entire state of the world.\nAre highly stateful\nProduce events in reaction to state changes\nInteract with other data managers via events\nDo not have a set of objectives. They are not trying to achieve some particular state of the world\nAre narrowly focused on some particular aspect of the world, but are concerned with all instances of that aspect\nAre added as instances and are limited to a single instance per class type\n\nActors\n\nMay be added and removed over time\nAre not considered to be part of the world\nAre generally stateless\nReact to but do not produce events\nMay access any data manager\nHave objectives. They contain the business logic of the model and are trying to achieve some particular state of the world\nAre concerned with many aspects of the world, but often focused on a particular subset of world\nAre added as consumers of ActorContext and may be composed of any such consumers\n\n\n\n\nReports\n\nExist for the full duration of the simulation\nAre not considered to be part of the world\nReact to but do not produce events\nMay access any data manager\nDo not have a set of objectives\nCannot mutate data and have no effect on the outcome of the simulation\n\n\n\n\nCode Block 2.8: A data manager is added to the simulation.\npublic static void main(String[] args) {\n\n    PluginId pluginId = new SimplePluginId(\"example plugin\");\n\n    Plugin plugin = Plugin.builder()//\n            .setPluginId(pluginId)//\n            .setInitializer(pluginContext -> {\n                pluginContext.addActor(new ExampleActor()::init);\n                pluginContext.addDataManager(new ExampleDataManager());\n            })//\n            .build();\n\n    Simulation.builder()//\n            .addPlugin(plugin)//\n            .build()//\n            .execute();\n}\n\n\nWe add an instance of ExampleDataManager to the simulation. Unlike the actor, where we pass a consumer of context, we need to provide an actual instance of a data manager. Note that the ExampleDataManager extends the base class DataManager. The base class provides only the init() method to override and you must include the super.init(dataManagerContext) call as its first line. This is done to ensure that each data manager is initialized exactly once by the simulation.\nThe ExampleDataManager has two (completely arbitrary) data fields alpha and beta and provides both getters and setters for each.\n\n\nCode Block 2.9: The example data manager manages the state of two properties and prints to the console when changes are made.\npublic final class ExampleDataManager extends DataManager {\n\n    private int alpha = 7;\n\n    private double beta = 1.2345;\n\n    private DataManagerContext dataManagerContext;\n\n    @Override\n    public void init(DataManagerContext dataManagerContext) {\n        super.init(dataManagerContext);\n        this.dataManagerContext = dataManagerContext;\n        System.out.println(\"ExampleDataManager is initialized\");\n    }\n\n    public int getAlpha() {\n        return alpha;\n    }\n\n    public void setAlpha(int alpha) {\n        this.alpha = alpha;\n        System.out.println(\"ExampleDataManager sets alpha = \" + alpha + \" at time = \" + dataManagerContext.getTime());\n    }\n\n    public double getBeta() {\n        return beta;\n    }\n\n    public void setBeta(double beta) {\n        this.beta = beta;\n        System.out.println(\"ExampleDataManager sets beta = \" + beta + \" at time = \" + dataManagerContext.getTime());\n    }\n\n}\n\n\nThe actor is now specified via the ExampleActor class, Code Block 2.10. Most actors contain enough code that we usually put that code into a separate class rather than a lambda statement as we did in the previous lesson. Note that the init() method has the correct method signature of being a consumer of ActorContext.\n\nPlans\nIn GCM, an actor can do three things:\n\nObserve: Observation can be done directly by gaining access to a data manager and then getting a value from that data manager. Observation can be done indirectly by subscribing to events. We will cover that option later.\nAct: A mutation to some data manager’s managed data.\nPlan: At some time in the future, the actor will take some particular action\n\nActions in GCM are always executed in the current moment in the simulation. Unlike many future event simulations where events are queued for future execution, GCM allows an actor to plan for an action or observation in the future. The plan is a consumer of ActorContext and can be a static method, member method or a lambda. The plan is registered with the simulation and is executed only when time has moved forward to the plan’s scheduled time. There is no requirement that the plan do anything at all. This allows the flexibility to re-evaluate the circumstances of the planned action and choose to take appropriate action at that time. Plans are queued in GCM by their associated planning times and it is this queue that dictates the flow of time. For example, suppose the simulation finds the first plan is scheduled for time= 2.4 days. The current time = 0 days and the simulation progresses time to 2.4 days and then invokes the plan. Plans are always privately managed by the actor that owns the plan and no other actor or data manager has any insight into those plans.\nIn this example, the actor is initialized at time= 0 and generates 10 plans to increment the value of the alpha in the ExampleManager. Each time the ExampleManager changes the value of alpha, it outputs to the console a description of the change.\n\n\nCode Block 2.10: The example actor initializes by making plans to update the alpha property on a daily basis.\npublic final class ExampleActor {\n\n    public void init(ActorContext actorContext) {\n        System.out.println(\"Example Actor is initialized and will plan to set Alpha\");\n\n        ExampleDataManager exampleDataManager = actorContext.getDataManager(ExampleDataManager.class);\n\n        for (double planTime = 0; planTime < 10; planTime++) {\n            actorContext.addPlan((context) -> {\n                int alpha = exampleDataManager.getAlpha();\n                alpha++;\n                exampleDataManager.setAlpha(alpha);\n            }, planTime);\n        }\n    }\n}\n\n\nThe output from the simulation is:\n\n\n\nFigure 2.2: Output from the example actor and example data manager showing the alpha property initialization and subsequent evolution.\n\n\n\n\n\nExampleDataManager is initialized Example Actor is initialized and will plan to set Alpha ExampleDataManager sets alpha = 8 at time = 0.0 ExampleDataManager sets alpha = 9 at time = 1.0 ExampleDataManager sets alpha = 10 at time = 2.0 ExampleDataManager sets alpha = 11 at time = 3.0 ExampleDataManager sets alpha = 12 at time = 4.0 ExampleDataManager sets alpha = 13 at time = 5.0 ExampleDataManager sets alpha = 14 at time = 6.0 ExampleDataManager sets alpha = 15 at time = 7.0 ExampleDataManager sets alpha = 16 at time = 8.0 ExampleDataManager sets alpha = 17 at time = 9.0"
  },
  {
    "objectID": "ch02-GettingStarted.html#events-lesson-lesson-5",
    "href": "ch02-GettingStarted.html#events-lesson-lesson-5",
    "title": "2  Getting Started",
    "section": "2.5 Events Lesson (Lesson 5)",
    "text": "2.5 Events Lesson (Lesson 5)\nAn event in GCM is a notification of a data change to the state of a data manager. In this example we will introduce two events corresponding to the two changes to the ExampleDataManager. Both events document the previous value and current value (at the time when the event was generated) and are immutable data classes.\n\n\nCode Block 2.11: An event to notify that the alpha property has been updated.\npublic final class AlphaChangeEvent implements Event {\n\n    private final int previousAlpha;\n\n    private final int currentAlpha;\n\n    public AlphaChangeEvent(int previousAlpha, int currentAlpha) {\n        super();\n        this.previousAlpha = previousAlpha;\n        this.currentAlpha = currentAlpha;\n    }\n\n    public int getPreviousAlpha() {\n        return previousAlpha;\n    }\n\n    public int getCurrentAlpha() {\n        return currentAlpha;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"AlphaChangeEvent [previousAlpha=\");\n        builder.append(previousAlpha);\n        builder.append(\", currentAlpha=\");\n        builder.append(currentAlpha);\n        builder.append(\"]\");\n        return builder.toString();\n    }\n\n}\n\n\n\n\nCode Block 2.12: An event to notify that the beta property has been updated.\npublic final class BetaChangeEvent implements Event {\n\n    private final double previousBeta;\n\n    private final double currentBeta;\n\n    public BetaChangeEvent(double previousBeta, double currentBeta) {\n        super();\n        this.previousBeta = previousBeta;\n        this.currentBeta = currentBeta;\n    }\n\n    public double getPreviousBeta() {\n        return previousBeta;\n    }\n\n    public double getCurrentBeta() {\n        return currentBeta;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"BetaChangeEvent [previousBeta=\");\n        builder.append(previousBeta);\n        builder.append(\", currentBeta=\");\n        builder.append(currentBeta);\n        builder.append(\"]\");\n        return builder.toString();\n    }\n\n}\n\n\nEach is generated by the ExampleDataManager, Code Block 2.13, when the alpha or beta values are mutated by releasing the events through the DataManagerContext to the simulation:\n\n\nCode Block 2.13: The alpha and beta updates are managed via private mutation events.\nprivate static record AlphaChangeMutationEvent(int alpha) implements Event {\n}\n\npublic void setAlpha(int alpha) {\n    dataManagerContext.releaseMutationEvent(new AlphaChangeMutationEvent(alpha));\n}\n\nprivate void handleAlphaChangeMutationEvent(DataManagerContext dataManagerContext,\n        AlphaChangeMutationEvent alphaChangeMutationEvent) {\n    int alpha = alphaChangeMutationEvent.alpha();\n    int previousValue = this.alpha;\n    this.alpha = alpha;\n    dataManagerContext.releaseObservationEvent(new AlphaChangeEvent(previousValue, this.alpha));\n}\n\nprivate static record BetaChangeMutationEvent(double beta) implements Event {\n}\n\npublic void setBeta(double beta) {\n    dataManagerContext.releaseMutationEvent(new BetaChangeMutationEvent(beta));\n}\n\nprivate void handleBetaChangeMutationEvent(DataManagerContext dataManagerContext,\n        BetaChangeMutationEvent betaChangeMutationEvent) {\n    double beta = betaChangeMutationEvent.beta();\n    double previousValue = this.beta;\n    this.beta = beta;\n    dataManagerContext.releaseObservationEvent(new BetaChangeEvent(previousValue, this.beta));\n}\n\n\nThere are three actors in this example:\n\nActor1 makes changes to both the alpha and beta values at 1 and 3.5 day intervals respectively.\nActor2 subscribes to AlphaChangeEvent events and reports to console what it receives.\nActor3 does the same for BetaChangeEvent events\n\n\n\nCode Block 2.14: Actor 1 schedules updates to both the alpha and beta properties.\npublic final class Actor1 {\n\n    public void init(ActorContext actorContext) {\n        ExampleDataManager exampleDataManager = actorContext.getDataManager(ExampleDataManager.class);\n\n        for (double planTime = 1; planTime <= 10; planTime++) {\n            actorContext.addPlan((context) -> {\n                int alpha = exampleDataManager.getAlpha();\n                alpha++;\n                exampleDataManager.setAlpha(alpha);\n            }, planTime);\n        }\n\n        for (int i = 1; i <= 5; i++) {\n            double planTime = i * 3.5;\n            actorContext.addPlan((context) -> {\n                double beta = exampleDataManager.getBeta();\n                beta *= 2;\n                exampleDataManager.setBeta(beta);\n            }, planTime);\n        }\n\n    }\n}\n\n\n\n\nCode Block 2.15: Actor 2 reacts to changes in the alpha property.\npublic final class Actor2 {\n    public void init(ActorContext actorContext) {\n\n        EventFilter<AlphaChangeEvent> eventFilter = EventFilter.builder(AlphaChangeEvent.class).build();\n\n        actorContext.subscribe(eventFilter, (context, event) -> {\n            System.out.println(\"Actor2 observes event \" + event + \" at time = \" + context.getTime());\n        });\n    }\n}\n\n\n\n\nCode Block 2.16: Actor 3 reacts to changes in the beta property.\npublic final class Actor3 {\n    public void init(ActorContext actorContext) {\n        EventFilter<BetaChangeEvent> eventFilter = EventFilter.builder(BetaChangeEvent.class).build();\n        actorContext.subscribe(eventFilter, (context, event) -> {\n            System.out.println(\"Actor3 observes event \" + event + \" at time = \" + context.getTime());\n        });\n    }\n}\n\n\nThe resulting console output shows Actor2 and Actor3 observing the expected events at the expected times:\n\n\n\nFigure 2.3: Output from Actors 2 and 3 as they observe changes to the alpha and beta properties.\n\n\n\n\n\nActor2 observes event AlphaChangeEvent [previousAlpha=7, currentAlpha=8] at time = 1.0 Actor2 observes event AlphaChangeEvent [previousAlpha=8, currentAlpha=9] at time = 2.0 Actor2 observes event AlphaChangeEvent [previousAlpha=9, currentAlpha=10] at time = 3.0 Actor3 observes event BetaChangeEvent [previousBeta=1.2345, currentBeta=2.469] at time = 3.5 Actor2 observes event AlphaChangeEvent [previousAlpha=10, currentAlpha=11] at time = 4.0 Actor2 observes event AlphaChangeEvent [previousAlpha=11, currentAlpha=12] at time = 5.0 Actor2 observes event AlphaChangeEvent [previousAlpha=12, currentAlpha=13] at time = 6.0 Actor2 observes event AlphaChangeEvent [previousAlpha=13, currentAlpha=14] at time = 7.0 Actor3 observes event BetaChangeEvent [previousBeta=2.469, currentBeta=4.938] at time = 7.0 Actor2 observes event AlphaChangeEvent [previousAlpha=14, currentAlpha=15] at time = 8.0 Actor2 observes event AlphaChangeEvent [previousAlpha=15, currentAlpha=16] at time = 9.0 Actor2 observes event AlphaChangeEvent [previousAlpha=16, currentAlpha=17] at time = 10.0 Actor3 observes event BetaChangeEvent [previousBeta=4.938, currentBeta=9.876] at time = 10.5 Actor3 observes event BetaChangeEvent [previousBeta=9.876, currentBeta=19.752] at time = 14.0 Actor3 observes event BetaChangeEvent [previousBeta=19.752, currentBeta=39.504] at time = 17.5\n\n\n\n\n\n\n\n\n\nEvent Filters\nSubscription to events for data managers and actors differ a bit. Data managers subscribe directly to the event type since they are generally interested in all events of some given type. Actors are often more selective and would like a predicate (in Java, the predicate is a function that returns a Boolean) to return true before they handle an event. For example, an actor wants to subscribe for person property change events, but is only interested in those events indicate a change to a particular person property. Since there will likely be dozens of person properties, the actor would get stimulated many times over, only to ignore the event most of the time. Unfortunately, a simple predicate added during the subscription process will not suffice since that predicate would have to be executed for each event and we will have gained little efficiency. Instead, GCM uses the EventFilter class that is essentially a predicate grouping mechanism that allows the subscription engine to group subscribers into a tree structure so that a single predicate execution might suffice to allow an event to be passed to multiple subscribers.\nThe event filter is logically composed of functions and target values as pairs. Each function takes in an event and releases a value. If that value is equal to the target value, then the event passes that function. An event passes the event filter if it passes all the functions that compose the filter. The construction of the builder for event filters requires the event class reference. The addition of function-value pairs requires that the functions take in only events of the given class reference, but may return any non-null object value. The simple examples given so far have only specified the event class and thus every event of that type will pass the event filter.\nThe functions that compose the event filter are often non-meaningfully comparable. For example, two functions that return the same values for every event may be separate instances of lambda code that are logically equal, but are not equal from the point of view of Java. To get around this, each function is associated with an id value and the id and function pair are called an IdentifiableFunction. Two such functions will be equal if and only if their ids are equal without regard to what their functions actually do. Thus is it very important that the mapping of id to actual logical function be stable and the usual best practice is to manage that mapping in a curated manner via the data manager that is associated with the plugin that defines the event. As we examine plugins that define events, we will encounter event filters that are managed by data managers and we will generally not generate event filters directly in the actor code."
  },
  {
    "objectID": "ch02-GettingStarted.html#plugin-dependencies-lesson-lesson-6",
    "href": "ch02-GettingStarted.html#plugin-dependencies-lesson-lesson-6",
    "title": "2  Getting Started",
    "section": "2.6 Plugin Dependencies Lesson (Lesson 6)",
    "text": "2.6 Plugin Dependencies Lesson (Lesson 6)\nSo far we have covered what actors and data managers do and that they are introduced into the simulation via plugins. Over the next lessons we take a closer look at the plugins. This lesson starts with creating a more realistic set of plugins arranged into separate java packages.\n\nPeople plugin\n\nDefines a person id\nAdds the PersonDataManager for tracking people\nAdds events for the the addition and removal of people\n\nFamily Plugin\n\nDefines a family id\nAdds the FamilyDataManager for grouping people into families\n\nVaccine Plugin\n\nAdds the VaccineDataManager for tracking which people have been vaccinated\n\nModel Plugin\n\nContains the ModelActor class to add people organized into family structures and vaccinate some of those people\n\n\nHere are the classes that implement this example:\n\nPeople Plugin:\nThe people plugin defines a PersonId as a simple, immutable wrapper to an int value. The PersonDataManager tracks people via PersonId values and allows for the addition and removal of people. PersonId values are generated in order and never reused. Events are generated when people are added or removed.\n\n\nCode Block 2.17: The PersonId class defines people and wraps an int value.\npublic final class PersonId implements Comparable<PersonId> {\n\n    private final int id;\n\n    public PersonId(int id) {\n        this.id = id;\n    }\n\n    public int getValue() {\n        return id;\n    }\n\n    @Override\n    public int compareTo(PersonId personId) {\n        return Integer.compare(id, personId.id);\n    }\n\n    @Override\n    public int hashCode() {\n        return id;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof PersonId)) {\n            return false;\n        }\n        PersonId other = (PersonId) obj;\n        if (id != other.id) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return Integer.toString(id);\n    }\n}\n\n\n\n\nCode Block 2.18: The PersonDataManager manages people by adding people, removing people and releasing person removal events.\npublic final class PersonDataManager extends DataManager {\n\n    private int masterPersonId;\n\n    private Set<PersonId> people = new LinkedHashSet<>();\n\n    private DataManagerContext dataManagerContext;\n\n    @Override\n    public void init(DataManagerContext dataManagerContext) {\n        super.init(dataManagerContext);\n        this.dataManagerContext = dataManagerContext;\n        dataManagerContext.subscribe(PersonRemovalMutationEvent.class, this::handlePersonRemovalMutationEvent);\n    }\n\n    public PersonId addPerson() {\n        PersonId personId = new PersonId(masterPersonId++);\n        people.add(personId);\n        return personId;\n    }\n\n    public boolean personExists(PersonId personId) {\n        return people.contains(personId);\n    }\n\n    public Set<PersonId> getPeople() {\n        return new LinkedHashSet<>(people);\n    }\n\n    private static record PersonRemovalMutationEvent(PersonId personId) implements Event {\n    }\n\n    public void removePerson(PersonId personId) {\n        dataManagerContext.releaseMutationEvent(new PersonRemovalMutationEvent(personId));\n    }\n\n    private void handlePersonRemovalMutationEvent(DataManagerContext dataManagerContext,\n            PersonRemovalMutationEvent personRemovalMutationEvent) {\n        PersonId personId = personRemovalMutationEvent.personId();\n        if (!personExists(personId)) {\n            throw new RuntimeException(\"person \" + personId + \" does not exist\");\n        }\n        people.remove(personId);\n        dataManagerContext.releaseObservationEvent(new PersonRemovalEvent(personId));\n    }\n}\n\n\n\n\nCode Block 2.19: An event signifying that a person has been removed from the simulation.\npublic final class PersonRemovalEvent implements Event {\n\n    private final PersonId personId;\n\n    public PersonRemovalEvent(PersonId personId) {\n        this.personId = personId;\n    }\n\n    public PersonId getPersonId() {\n        return personId;\n    }\n\n}\n\n\n\n\nFamily Plugin\nThe family plugin defines a FamilyId as a simple, immutable wrapper to an int value. The FamilyDataManager tracks family membership via two-way mappings of PersonId to FamilyId. In this example, families can only be added and people can only be added to families. However, people can be removed via the PeoplePlugin so the FamilyDataManager subscribes to PersonRemovalEvent(s) and thus removes the people from families.\n\n\nCode Block 2.20: The family id, like the person id, simply wraps an int.\npublic final class FamilyId implements Comparable<FamilyId> {\n\n    private final int id;\n\n    public FamilyId(int id) {\n        this.id = id;\n    }\n\n    public int getValue() {\n        return id;\n    }\n\n    @Override\n    public int compareTo(FamilyId familyId) {\n        return Integer.compare(id, familyId.id);\n    }\n\n    @Override\n    public int hashCode() {\n        return id;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof FamilyId)) {\n            return false;\n        }\n        FamilyId other = (FamilyId) obj;\n        if (id != other.id) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return Integer.toString(id);\n    }\n}\n\n\n\n\nCode Block 2.21: The family data manager manages families, their person members and various information methods.\npublic final class FamilyDataManager extends DataManager {\n\n    private int masterFamilyId;\n    private Map<FamilyId, Set<PersonId>> familyMap = new LinkedHashMap<>();\n    private Map<PersonId, FamilyId> personMap = new LinkedHashMap<>();\n    private PersonDataManager personDataManager;\n\n    @Override\n    public void init(DataManagerContext dataManagerContext) {\n        super.init(dataManagerContext);\n        personDataManager = dataManagerContext.getDataManager(PersonDataManager.class);\n        dataManagerContext.subscribe(PersonRemovalEvent.class, this::handlePersonRemovalEvent);\n    }\n\n    private void handlePersonRemovalEvent(DataManagerContext dataManagerContext,\n            PersonRemovalEvent personRemovalEvent) {\n        PersonId personId = personRemovalEvent.getPersonId();\n        FamilyId familyId = personMap.remove(personId);\n        if (familyId != null) {\n            familyMap.get(familyId).remove(personId);\n        }\n        System.out.println(\n                \"Family Data Manager is removing person \" + personId + \" at time = \" + dataManagerContext.getTime());\n    }\n\n    public FamilyId addFamily() {\n        FamilyId familyId = new FamilyId(masterFamilyId++);\n        familyMap.put(familyId, new LinkedHashSet<>());\n        return familyId;\n    }\n\n    public boolean familyExists(FamilyId familyId) {\n        return familyMap.keySet().contains(familyId);\n    }\n\n    public List<PersonId> getFamilyMembers(FamilyId familyId) {\n        if (!familyExists(familyId)) {\n            throw new RuntimeException(\"unknown family \" + familyId);\n        }\n        return new ArrayList<>(familyMap.get(familyId));\n    }\n\n    public Optional<FamilyId> getFamilyId(PersonId personId) {\n        if (!personDataManager.personExists(personId)) {\n            throw new RuntimeException(\"unknown person \" + personId);\n        }\n        FamilyId familyId = personMap.get(personId);\n        return Optional.ofNullable(familyId);\n    }\n\n    public void addFamilyMember(PersonId personId, FamilyId familyId) {\n        if (!personDataManager.personExists(personId)) {\n            throw new RuntimeException(\"unknown person \" + personId);\n        }\n        if (!familyExists(familyId)) {\n            throw new RuntimeException(\"unknown family \" + familyId);\n        }\n        FamilyId currentFamilyId = personMap.get(personId);\n        if (currentFamilyId != null) {\n            throw new RuntimeException(\"person \" + personId + \" is already assigned to family \" + currentFamilyId);\n        }\n        familyMap.get(familyId).add(personId);\n        personMap.put(personId, familyId);\n    }\n\n}\n\n\n\n\nVaccine Plugin\nThe vaccine plugin contains only the VaccineDataManager which tracks by PersonId which people have been vaccinated. Like the FamilyDataManager, it too subscribes to PersonRemovalEvent(s) and adjusts its data accordingly.\n\n\nCode Block 2.22: The vaccination manager tracks the vaccination status of each person, reacting to the person removal as needed.\npublic final class VaccinationDataManager extends DataManager {\n\n    private Set<PersonId> vaccinatedPeople = new LinkedHashSet<>();\n\n    private PersonDataManager personDataManager;\n\n    @Override\n    public void init(DataManagerContext dataManagerContext) {\n        super.init(dataManagerContext);\n        dataManagerContext.subscribe(PersonRemovalEvent.class, this::handlePersonRemovalEvent);\n        personDataManager = dataManagerContext.getDataManager(PersonDataManager.class);\n    }\n\n    private void handlePersonRemovalEvent(DataManagerContext dataManagerContext,\n            PersonRemovalEvent personRemovalEvent) {\n        PersonId personId = personRemovalEvent.getPersonId();\n        vaccinatedPeople.remove(personId);\n        System.out.println(\"Vaccination Data Manager is removing person \" + personId + \" at time = \"\n                + dataManagerContext.getTime());\n    }\n\n    public Set<PersonId> getVaccinatedPeople() {\n        return new LinkedHashSet<>(vaccinatedPeople);\n    }\n\n    public Set<PersonId> getUnvaccinatedPeople() {\n        Set<PersonId> people = personDataManager.getPeople();\n        people.removeAll(vaccinatedPeople);\n        return people;\n    }\n\n    public boolean isPersonVaccinated(PersonId personId) {\n        if (!personDataManager.personExists(personId)) {\n            throw new RuntimeException(\"unknown person \" + personId);\n        }\n        return vaccinatedPeople.contains(personId);\n    }\n\n    public void vaccinatePerson(PersonId personId) {\n        if (!personDataManager.personExists(personId)) {\n            throw new RuntimeException(\"unknown person \" + personId);\n        }\n        vaccinatedPeople.add(personId);\n    }\n\n}\n\n\n\n\nModel Plugin\nThe model plugin contains a single actor, the ModelActor, that serves to:\n\nAdd people to the simulation\nGroup them into families\nVaccinate some people\nDemonstrate that events cascade\n\n\n\nConnecting the Plugins\nBoth the family and vaccine plugins depend on the concept of a person as implemented by the PersonId class. They also need to respond when a person is removed from the simulation and do so by handling the corresponding PersonRemovalEvent generated by the person plugin. We build these dependencies via the Plugin.Builder class in the example code below.\n\n\nCode Block 2.23: The people, vaccine, family and model plugins are contributed to the simulation. On execution, the model plugin’s single actor schedules the vaccination of each person as well as a few random removals of people from the simulation.\npublic static void main(String[] args) {\n\n    PluginId peoplePluginId = new SimplePluginId(\"people plugin\");\n    Plugin peoplePlugin = Plugin.builder()//\n            .setPluginId(peoplePluginId)//\n            .setInitializer(pluginContext -> {\n                pluginContext.addDataManager(new PersonDataManager());\n            })//\n            .build();\n\n    PluginId vaccinePluginId = new SimplePluginId(\"vaccine plugin\");\n    Plugin vaccinePlugin = Plugin.builder()//\n            .setPluginId(vaccinePluginId)//\n            .addPluginDependency(peoplePluginId)//\n            .setInitializer(pluginContext -> {\n                pluginContext.addDataManager(new VaccinationDataManager());\n            })//\n            .build();\n\n    PluginId familyPluginId = new SimplePluginId(\"family plugin\");\n    Plugin familyPlugin = Plugin.builder()//\n            .setPluginId(familyPluginId)//\n            .addPluginDependency(peoplePluginId)//\n            .setInitializer(pluginContext -> {\n                pluginContext.addDataManager(new FamilyDataManager());\n            })//\n            .build();\n\n    PluginId modelPluginId = new SimplePluginId(\"model plugin\");\n    Plugin modelPlugin = Plugin.builder()//\n            .setPluginId(modelPluginId)//\n            .setInitializer(pluginContext -> {\n                pluginContext.addActor(new ModelActor()::init);\n\n            })//\n            .build();\n\n    Simulation.builder()//\n            .addPlugin(vaccinePlugin)//\n            .addPlugin(familyPlugin)//\n            .addPlugin(peoplePlugin)//\n            .addPlugin(modelPlugin)//\n            .build()//\n            .execute();\n}\n\n\nNote the addition of the dependency on the people plugin via its id when adding both the vaccine and family plugins. The order of addition of the plugins to the simulation is relatively unimportant as is ordering in general in any of the builder patterns used in GCM.\nThe resulting output:\n\n\n\nFigure 2.4: The output shows the combined reporting from actors and data managers as they report vaccination progress.\n\n\n\n\n\nPerson 7 was vaccinated at time = 1.0 Person 2 was vaccinated at time = 2.0 Person 5 was vaccinated at time = 3.0 Vaccination Data Manager is removing person 2 at time = 3.0 Family Data Manager is removing person 2 at time = 3.0 Person 6 was vaccinated at time = 4.0 Vaccination Data Manager is removing person 1 at time = 4.0 Family Data Manager is removing person 1 at time = 4.0 Person 3 was vaccinated at time = 5.0 Vaccination Data Manager is removing person 8 at time = 5.0 Family Data Manager is removing person 8 at time = 5.0 Failed to vaccinate Person 1 at time = 6.0 Vaccination Data Manager is removing person 6 at time = 6.0 Family Data Manager is removing person 6 at time = 6.0 Person 0 was vaccinated at time = 7.0 Vaccination Data Manager is removing person 7 at time = 7.0 Family Data Manager is removing person 7 at time = 7.0 Person 9 was vaccinated at time = 8.0 Vaccination Data Manager is removing person 5 at time = 8.0 Family Data Manager is removing person 5 at time = 8.0 Failed to vaccinate Person 8 at time = 9.0 Vaccination Data Manager is removing person 3 at time = 9.0 Family Data Manager is removing person 3 at time = 9.0 Person 4 was vaccinated at time = 10.0 Vaccination Data Manager is removing person 4 at time = 10.0 Family Data Manager is removing person 4 at time = 10.0 Vaccination Data Manager is removing person 0 at time = 11.0 Family Data Manager is removing person 0 at time = 11.0 Vaccination Data Manager is removing person 9 at time = 12.0 Family Data Manager is removing person 9 at time = 12.0"
  },
  {
    "objectID": "ch02-GettingStarted.html#plugin-dependency-graph-lesson-lesson-7",
    "href": "ch02-GettingStarted.html#plugin-dependency-graph-lesson-lesson-7",
    "title": "2  Getting Started",
    "section": "2.7 Plugin Dependency Graph Lesson (Lesson 7)",
    "text": "2.7 Plugin Dependency Graph Lesson (Lesson 7)\nWe extend the previous lesson by adding an additional dependency of the vaccine plugin on the family plugin. This will allow the VaccineDataManager to answer queries about which members of a family have yet to be vaccinated.\nFrom the VaccineDataManager:\n\n\nCode Block 2.24: By adding a plugin dependencies on the people and family plugins, the vaccine data manager can now answer questions about the vaccine status of family members\npublic List<PersonId> getUnvaccinatedFamilyMembers(PersonId personId) {\n    if (!personDataManager.personExists(personId)) {\n        throw new RuntimeException(\"unknown person \" + personId);\n    }\n    List<PersonId> result = new ArrayList<>();\n    Optional<FamilyId> optional = familyDataManager.getFamilyId(personId);\n    if (optional.isPresent()) {\n        FamilyId familyId = optional.get();\n        List<PersonId> familyMembers = familyDataManager.getFamilyMembers(familyId);\n        for (PersonId familyMemeberId : familyMembers) {\n            if (!isPersonVaccinated(familyMemeberId)) {\n                result.add(personId);\n            }\n        }\n    }\n    return result;\n}\n\n\nThe plugins in this example form a dependency pattern:\n\n\n\n\nFigure 2.5: The three plugins form a simple, directed acyclic graph (DAG). GCM uses this DAG to ensure that all information provided by any data manager is fully updated whenever an event is being processed by a dependent of the data manager.\n\n\n\n\n\nAll plugin dependencies in GCM form similar directed, acyclic graphs (DAGs). There can be no loops in the dependency graph, but the graph does not have to be fully connected. The dependencies reflect the requirements of the data managers within a plugin to access data managers in other plugins. This pattern drives the order in which events are presented to data managers. This way, a data manager is guaranteed that any event that it is processing has already been fully processed by all the data managers it depends on.\nIn this lesson, the VaccineDataManager and the FamilyDataManager have both subscribed to the PersonRemovalEvent generated by the PersonDataManager. Since the VaccineDataManager also has a dependency on the FamilyDataManager, the VaccineDataManager should receive the event after the FamilyDataManager. Events cascade through the subscribed data managers in an order that is consistent with the plugin dependency DAG."
  },
  {
    "objectID": "ch02-GettingStarted.html#plugin-data-lesson-lesson-8",
    "href": "ch02-GettingStarted.html#plugin-data-lesson-lesson-8",
    "title": "2  Getting Started",
    "section": "2.8 Plugin Data Lesson (Lesson 8)",
    "text": "2.8 Plugin Data Lesson (Lesson 8)\nThe Example code in the last lesson was a bit verbose and can be improved. Identifying and generating the plugins can be included in the plugin packages by introducing classes for each id and classes for each plugin’s contents. In the disease package we add a unique plugin identifier with a final static id field:\n\n\nCode Block 2.25: The plugin id for the disease plugin is implemented as a static constant.\npublic final class DiseasePluginId implements PluginId {\n    private DiseasePluginId() {\n    }\n\n    public final static PluginId PLUGIN_ID = new SimplePluginId(\"disease plugin id\");\n}\n\n\nWe also add a static class (DiseasePlugin) that implements the construction of the plugin from the required plugin data.\n\n\nCode Block 2.26: The DiseasePlugin class is a static class for creating the disease plugin.\npublic final class DiseasePlugin {\n\n    private DiseasePlugin() {\n\n    }\n\n    public static Plugin getDiseasePlugin(DiseasePluginData diseasePluginData) {\n\n        return Plugin.builder()//\n                .addPluginData(diseasePluginData)//\n                .setPluginId(DiseasePluginId.PLUGIN_ID)//\n                .setInitializer((pluginContext) -> {\n                    DiseasePluginData pluginData = pluginContext.getPluginData(DiseasePluginData.class).get();\n                    pluginContext.addDataManager(new DiseaseDataManager(pluginData));\n                })//\n                .build();\n    }\n\n}\n\n\nThe plugin is initialized with a DiseasePluginData object that contains the initial values for r0, asymptomatic days and symptomatic days. Most plugins will have a single plugin data object, but some may not need any and some may be designed with multiple such classes. All such classes must implement the PluginData interface:\n\n\nCode Block 2.27: The PluginData interface indicates that its implementors are immutable. Plugin data objects are shared between all simulation instances and thus must be thread safe. It introduces a single method used to copy plugin datas during the experiment process.\n@ThreadSafe\npublic interface PluginData {\n    /**\n     * Returns a PluginDataBuilder that can build the plugin data. The returned\n     * builder should be initialized with this plugin data object's internal state\n     * such that invocation of pluginData.getCloneBuilder().build() will generate a\n     * copy of the current plugin.\n     */\n    public PluginDataBuilder getCloneBuilder();\n\n    @Override\n    public int hashCode();\n\n    /**\n     * Plugin datas are equal if they are implicitly equal. They contain the same\n     * implicit information without regard to order.\n     */\n    @Override\n    public boolean equals(Object obj);\n\n    /**\n     * A string representation of the plugin data implicit data and reflects the\n     * order of addition of the data. Equal plugin datas have equal strings in terms\n     * of content, but not necessarily order.\n     */\n    @Override\n    public String toString();\n}\n\n\nPlugin data classes must be threadsafe since they will be shared between multiple simulations running on separate threads. This stands in contrast to the actors and data managers which are created and managed in the thread of a single simulation. The best practice is to make plugin data classes immutable since immutable classes in Java are guaranteed to be threadsafe. For a class to be immutable in Java it must meet three conditions:\n\nIt cannot be mutated, i.e. it has no setters and no public fields.\nAll its fields are marked final.\nIts constructor(s) do not pass reference to self. No reference to the newly created object leaks out before construction is complete.\n\nBesides carrying whatever data is needed by the plugin, the PluginData implementor must provide a PluginDataBuilder:\n\n\nCode Block 2.28: Every plugin data class has a corresponding builder class to aid in the experiment’s generation of alternate scenarios.\npublic interface PluginDataBuilder {\n    /**\n     * Returns a plugin data\n     */\n    public PluginData build();\n}\n\n\nThe role of the plugin data builder will be explored in the next lesson where it will be used to make alterable copies of plugin data to drive the experiment. For now, let’s examine the DiseasePluginData class. It is composed several sections:\n\nA data class\nA static builder class\nA single data field and private constructor\nGetter methods for the data\nA clone builder method\n\n\n\nCode Block 2.29: The disease plugin data collects the various general disease properties used to initialize the disease data manager.\nprivate static class Data {\n\n    private double r0;\n\n    private double asymptomaticDays;\n\n    private double symptomaticDays;\n\n    private Data() {\n    }\n\n    private Data(final Data data) {\n        r0 = data.r0;\n        asymptomaticDays = data.asymptomaticDays;\n        symptomaticDays = data.symptomaticDays;\n    }\n\n\nThe Data class is private and just contains the fields needed by the plugin. Note that it is a mutable class and that its fields are not final. It will be used by the builder class later to store values. Its constructors are private and allow one Data object to be copied from another.\n\n\nCode Block 2.30: The builder class for the immutable disease plugin data class.\npublic static class Builder implements PluginDataBuilder {\n    private Data data;\n\n    private Builder(final Data data) {\n        this.data = data;\n    }\n\n    @Override\n    public DiseasePluginData build() {\n\n        return new DiseasePluginData(new Data(data));\n\n    }\n\n    public Builder setAsymptomaticDays(final double asymptomaticDays) {\n        data.asymptomaticDays = asymptomaticDays;\n        return this;\n    }\n\n    public Builder setR0(final double r0) {\n        data.r0 = r0;\n        return this;\n    }\n\n    public Builder setSymptomaticDays(final double symptomaticDays) {\n        data.symptomaticDays = symptomaticDays;\n        return this;\n    }\n}\n\npublic static Builder builder() {\n    return new Builder(new Data());\n}\n\n\nThe static builder class is used instead of a constructor. The use of builder classes for plugin data objects is key to the creation of experiments covered in the next lesson. For now, let’s concentrate on what the builder does. First, it has setter methods for each of the data fields and each such method returns the builder instance to support method chaining. Next, the build() method returns the DiseasePluginData. Finally, the builder’s own constructor is private and is accessed via a static method. This is done to grant a syntax that is more compatible with the method chaining.\n\n\nCode Block 2.31: The disease plugin data is constructed from the collected data in a private constructor.\nprivate final Data data;\n\nprivate DiseasePluginData(final Data data) {\n    this.data = data;\n}\n\n\nAfter the builder collects the data, it passes that data to the instance of the DiseasePluginData which is stored as a final field. Recall that the field must be final in an immutable class.\n\n\nCode Block 2.32: The disease plugin data grants access to its immutable field values.\npublic double getAsymptomaticDays() {\n    return data.asymptomaticDays;\n}\n\npublic double getR0() {\n    return data.r0;\n}\n\npublic double getSymptomaticDays() {\n    return data.symptomaticDays;\n}\n\n\nThe getter methods for each field value in the data are added. There are no corresponding setter methods.\n\n\nCode Block 2.33: The disease plugin data creates a copy of its data and places it in the returned plugin data builder.\n@Override\npublic PluginDataBuilder getCloneBuilder() {\n    return new Builder(new Data(data));\n}\n\n\nWe end the class with the getCloneBuilder method.\n\n\n\n\n\n\nTerminology Note\n\n\n\nOur use of the term clone is intuitive but may cause some confusion. What we are doing is copying the data in the DiseasePluginData and placing into a builder so that it can be further mutated later in the experiment. Java formally defines the term clone as a part of the Object class definition and implements it with a protected method clone(). Use of the Object.clone() method has generally fallen out of favor in Java but still has some proponents/use cases.\n\n\nThe method returns a new Builder that has reference to the current data object. The resulting example class is easier to read and more succinct:\n\n\nCode Block 2.34: Example 8 executes more succinctly by use of static plugin classes.\npublic final class Example_8 {\n\n    private Example_8() {\n    }\n\n    private static DiseasePluginData getDiseasePluginData() {\n        return DiseasePluginData.builder()//\n                .setR0(1.5)//\n                .setAsymptomaticDays(4.0)//\n                .setSymptomaticDays(12.0)//\n                .build();\n    }\n\n    private static PolicyPluginData getPolicyPluginData() {\n        return PolicyPluginData.builder()//\n                .setDistributeVaccineLocally(true)//\n                .setSchoolClosingInfectionRate(0.05)//\n                .build();\n    }\n\n    public static void main(String[] args) {\n\n        DiseasePluginData diseasePluginData = getDiseasePluginData();\n        Plugin diseasePlugin = DiseasePlugin.getDiseasePlugin(diseasePluginData);\n\n        PolicyPluginData policyPluginData = getPolicyPluginData();\n        Plugin policyPlugin = PolicyPlugin.getPolicyPlugin(policyPluginData);\n\n        Plugin modelPlugin = ModelPlugin.getModelPlugin();\n\n        Simulation.builder()//\n                .addPlugin(diseasePlugin)//\n                .addPlugin(modelPlugin)//\n                .addPlugin(policyPlugin)//\n                .build()//\n                .execute();\n    }\n}"
  },
  {
    "objectID": "ch02-GettingStarted.html#experiments-lesson-lesson-9",
    "href": "ch02-GettingStarted.html#experiments-lesson-lesson-9",
    "title": "2  Getting Started",
    "section": "2.9 Experiments Lesson (Lesson 9)",
    "text": "2.9 Experiments Lesson (Lesson 9)\nSo far we have mentioned that the plugin data classes play a role in executing an experiment via the getCloneBuilder method. Let’s start with the simple experiment. We will update the last example class by replacing the Simulation execution with an Experiment execution:\n\n\nCode Block 2.35: Example 9 replaces Example 8’s use of the simulation with an experiment.\npublic final class Example_9_A {\n\n    private Example_9_A() {\n    }\n\n    private static DiseasePluginData getDiseasePluginData() {\n        return DiseasePluginData.builder()//\n                .setR0(1.5)//\n                .setAsymptomaticDays(4.0)//\n                .setSymptomaticDays(12.0)//\n                .build();\n    }\n\n    private static PolicyPluginData getPolicyPluginData() {\n        return PolicyPluginData.builder()//\n                .setDistributeVaccineLocally(true)//\n                .setSchoolClosingInfectionRate(0.05)//\n                .build();\n    }\n\n    public static void main(String[] args) {\n\n        DiseasePluginData diseasePluginData = getDiseasePluginData();\n        Plugin diseasePlugin = DiseasePlugin.getDiseasePlugin(diseasePluginData);\n\n        PolicyPluginData policyPluginData = getPolicyPluginData();\n        Plugin policyPlugin = PolicyPlugin.getPolicyPlugin(policyPluginData);\n\n        Plugin modelPlugin = ModelPlugin.getModelPlugin();\n\n        Experiment.builder()//\n                .addPlugin(diseasePlugin)//\n                .addPlugin(modelPlugin)//\n                .addPlugin(policyPlugin)//\n                .addExperimentContextConsumer(ExperimentStatusConsole.builder().build())//\n                .build()//              \n                .execute();\n    }\n}\n\n\nThe experiment class has a very similar builder to the Simulation class so we only have to swap out the Simulation reference for an Experiment reference. The resulting execution created an experiment containing exactly one simulation that runs in the main thread. However, the output contains information about the status of the experiment.\n\n\n\nFigure 2.6: The output of the experiment version is the same as the simulation since the experiment contains exactly one scenario.\n\n\n\n\n\nModel Actor initializing  r0 = 1.5  asymptomatic days = 4.0  symptomatic days = 12.0  school closing infection rate = 0.05  distribute vaccine locally = true  1 of 1 scenario, 100% complete. Expected experiment completion in 0:00:00 Experiment completion of 1 scenario in 0:00:00:  SUCCEDED : 1 end of experiment status console\n\n\n\n\n\n\n\n\nWhat happens when the experiment executes?\nYou have contributed several plugins to the experiment and on execution the experiment generates multiple simulation runs on multiple threads. Let’s examine how this is accomplished as a way to motivate this lesson’s code examples.\nThe experiment is composed of several plugins, each with zero to many plugin data objects. For purposes of the diagrams we will assume that each plugin has a single plugin data object.\n\n\n\n\nFigure 2.7: Each plugin contains zero to many plugin data objects. For simplicity, we show one plugin data object per plugin.\n\n\n\n\n\nThe experiment gathers the plugin data objects and gets the plugin data builder for each. These plugin data builders will come pre-filled with the data from the original data objects.\n\n\n\n\nFigure 2.8: Using the clone builder mechanism, each plugin data generates a new plugin data builder that is prefilled with the plugin data’s information.\n\n\n\n\n\nBy altering the data in these builders, we generate new scenarios for the simulations to execute. GCM manages the instructions to alter the plugin data via Dimensions. Each dimension contains one to many levels.\n\n\n\n\nFigure 2.9: Dimensions are contributed to the experiment. Each dimension has a fixed number of levels and each such level alters the plugin data builders in a consistent way.\n\n\n\n\n\nFor example, we may have a dimension that alters the value of alpha from plugin data A and the value of beta from plugin data B. Each level in the dimension will set specific values for alpha and beta via the builders.\n::: {#fig-experiments_diagram_dimension_levels_example2 .figure fig-cap=“Example levels in a dimension”}\n\n\n\nlevel\nalpha\nbeta\n\n\n\n\n0\n2.3\nFALSE\n\n\n1\n3.6\nTRUE\n\n\n2\n4.8\nFALSE\n\n\n\nEach level in a dimension is actually a function that takes in the builders and manipulates the content of each plugin as needed.\n\n\n\n\nFigure 2.10: Dimension levels act as a function to change plugin data builders.\n\n\n\n\n\nConsider an experiment with two dimensions having 3 and 5 levels respectively. The number of level permutations is 3x5 = 15. Each such permutation is referred to as a scenario and the scenarios are numbered from 0 to 14. As the experiment executes, it works with each scenario id and determines for that id which levels are active for each dimension.\n\n\n\n\nFigure 2.11: The scenario id is a numberical composite of the level ids in each of the dimensions.\n\n\n\n\n\nEach level (via its function) alters the contents of the builders in turn, resulting in a unique set of content for that scenario.\n\n\n\n\nFigure 2.12: Once all of the dimensions have added content to the plugin data builders, the experiment builds the resulting plugin datas to be used in the next scenario.\n\n\n\n\n\nThe builders are then instructed by the experiment to build the plugin data objects. The resulting data objects are inserted into copies of the original plugins to produce a unique set of altered plugins that are specific to the scenario id and executed via a single simulation instance.\n\n\n\n\nFigure 2.13: For each original, experiment level plugin, a copy of the plugin is made with the various plugin datas replaced with those specific to the scenario. These altered plugins will be contributed to the simulation instance for the scenario.\n\n\n\n\n\nYou may have noticed that the initializer code above acquires the DiseasePluginData via the context rather than the instance passed to the getDiseasePlugin() method. This is a necessity due to experiment design and will be covered in the lessons that follow. In general, the initializer code should always retrieve plugin data from the plugin context.\nWe expand the example by adding a single dimension that sets r0 to two values, generating two simulations.\n\n\nCode Block 2.36: Example 9 B introduces a single dimension that sets the R0 value of the disease plugin data to two values.\npublic static void main(String[] args) {\n\n    DiseasePluginData diseasePluginData = getDiseasePluginData();\n    Plugin diseasePlugin = DiseasePlugin.getDiseasePlugin(diseasePluginData);\n\n    PolicyPluginData policyPluginData = getPolicyPluginData();\n    Plugin policyPlugin = PolicyPlugin.getPolicyPlugin(policyPluginData);\n\n    Plugin modelPlugin = ModelPlugin.getModelPlugin();\n\n    Dimension dimension = FunctionalDimension.builder()//\n            .addLevel((context) -> {\n                DiseasePluginData.Builder builder = context.getPluginDataBuilder(DiseasePluginData.Builder.class);\n                double r0 = 2.5;\n                builder.setR0(r0);\n                ArrayList<String> result = new ArrayList<>();\n                result.add(Double.toString(r0));\n                return result;\n            })//\n\n            .addLevel((context) -> {\n                DiseasePluginData.Builder builder = context.getPluginDataBuilder(DiseasePluginData.Builder.class);\n                double r0 = 2.0;\n                builder.setR0(r0);\n                ArrayList<String> result = new ArrayList<>();\n                result.add(Double.toString(r0));\n                return result;\n            })//\n\n            .addMetaDatum(\"r0\")//\n\n            .build();\n\n    Experiment.builder()//\n            .addPlugin(diseasePlugin)//\n            .addPlugin(modelPlugin)//\n            .addPlugin(policyPlugin)//\n            .addDimension(dimension)//\n            .build()//\n            .execute();\n}\n\n\nIn the dimension we see that there are two levels and the addition of some meta data in the addMetaDatum(“r0”) invocation. The meta data here represents the information that each level is altering in the experiment. The main purpose of each level is to alter the state of a builder(s) but must also return meta data values to match the meta data for the dimension. The meta data of the dimension acts as a header to a table while the meta data for each level are the values in that table.\nThe building of the dimension can be streamlined without typing out each level:\n\n\nCode Block 2.37: Example 9 C improves on the creation of the R0 dimension.\npublic final class Example_9_C {\n\n    private Example_9_C() {\n    }\n\n    private static DiseasePluginData getDiseasePluginData() {\n        return DiseasePluginData.builder()//\n                .setR0(1.5)//\n                .setAsymptomaticDays(4.0)//\n                .setSymptomaticDays(12.0)//\n                .build();\n    }\n\n    private static PolicyPluginData getPolicyPluginData() {\n        return PolicyPluginData.builder()//\n                .setDistributeVaccineLocally(true)//\n                .setSchoolClosingInfectionRate(0.05)//\n                .build();\n    }\n\n    private static Dimension getDimension() {\n        FunctionalDimension.Builder builder = FunctionalDimension.builder();//\n\n        List<Double> r0Values = new ArrayList<>();\n        r0Values.add(0.5);\n        r0Values.add(0.75);\n        r0Values.add(1.0);\n        r0Values.add(1.5);\n        r0Values.add(2.0);\n        r0Values.add(2.5);\n\n        for (Double r0 : r0Values) {\n            builder.addLevel((context) -> {\n                DiseasePluginData.Builder pluginDataBuilder = context\n                        .getPluginDataBuilder(DiseasePluginData.Builder.class);\n                pluginDataBuilder.setR0(r0);\n                ArrayList<String> result = new ArrayList<>();\n                result.add(Double.toString(r0));\n                return result;\n            });//\n        }\n        builder.addMetaDatum(\"r0\");//\n\n        return builder.build();\n    }\n\n\nThe resulting experiment execution is more streamlined:\n\n\nCode Block 2.38: Execution of the experiment is cleaner.\npublic static void main(String[] args) {\n\n    DiseasePluginData diseasePluginData = getDiseasePluginData();\n    Plugin diseasePlugin = DiseasePlugin.getDiseasePlugin(diseasePluginData);\n\n    PolicyPluginData policyPluginData = getPolicyPluginData();\n    Plugin policyPlugin = PolicyPlugin.getPolicyPlugin(policyPluginData);\n\n    Plugin modelPlugin = ModelPlugin.getModelPlugin();\n\n    Dimension dimension = getDimension();\n\n    Experiment.builder()//\n            .addPlugin(diseasePlugin)//\n            .addPlugin(modelPlugin)//\n            .addPlugin(policyPlugin)//\n            .addDimension(dimension)//\n            .build()//\n            .execute();\n}\n\n\nWe have turned off the experiment report progress to console in the code above. We have chosen six values for r0 in our dimension and thus we have 6 simulation executions, each having the model actor print out the contents of the DiseaseDataManager:\n\n\n\nFigure 2.14: The model actor writes output for each of the five scenarios corresponding to the five values of the R0 dimension.\n\n\n\n\n\nModel Actor initializing  r0 = 0.5  asymptomatic days = 4.0  symptomatic days = 12.0  school closing infection rate = 0.05  distribute vaccine locally = true  Model Actor initializing  r0 = 0.75  asymptomatic days = 4.0  symptomatic days = 12.0  school closing infection rate = 0.05  distribute vaccine locally = true  Model Actor initializing  r0 = 1.0  asymptomatic days = 4.0  symptomatic days = 12.0  school closing infection rate = 0.05  distribute vaccine locally = true  Model Actor initializing  r0 = 1.5  asymptomatic days = 4.0  symptomatic days = 12.0  school closing infection rate = 0.05  distribute vaccine locally = true  Model Actor initializing  r0 = 2.0  asymptomatic days = 4.0  symptomatic days = 12.0  school closing infection rate = 0.05  distribute vaccine locally = true  Model Actor initializing  r0 = 2.5  asymptomatic days = 4.0  symptomatic days = 12.0  school closing infection rate = 0.05  distribute vaccine locally = true \n\n\n\n\n\n\n\n\nWe are extending the example again, reducing the r0 dimension to just three levels and introducing a dimension over the policy data. This new dimension has four levels controlling local vaccine distribution and school closing infection rates:\n\n\nCode Block 2.39: A dimension representing school related policies is added. Note that this dimension has four levels and covers two policies.\nprivate static Dimension getPolicyDimension() {\n    FunctionalDimension.Builder builder = FunctionalDimension.builder();//\n\n    List<Double> schoolClosingInfectionRates = new ArrayList<>();\n    schoolClosingInfectionRates.add(0.05);\n    schoolClosingInfectionRates.add(0.10);\n\n    List<Boolean> localVaccineDistributionValues = new ArrayList<>();\n    localVaccineDistributionValues.add(false);\n    localVaccineDistributionValues.add(true);\n\n    for (Boolean localVaccineDistribution : localVaccineDistributionValues) {\n        for (Double schoolClosingInfectionRate : schoolClosingInfectionRates) {\n            builder.addLevel((context) -> {\n                PolicyPluginData.Builder pluginDataBuilder = context\n                        .getPluginDataBuilder(PolicyPluginData.Builder.class);\n                pluginDataBuilder.setSchoolClosingInfectionRate(schoolClosingInfectionRate);\n                pluginDataBuilder.setDistributeVaccineLocally(localVaccineDistribution);\n\n                ArrayList<String> result = new ArrayList<>();\n                result.add(Double.toString(schoolClosingInfectionRate));\n                result.add(Boolean.toString(localVaccineDistribution));\n                return result;\n            });//\n        }\n    }\n    builder.addMetaDatum(\"school_closing_infection_rate\");//\n    builder.addMetaDatum(\"distribute_vaccine_locally\");//\n\n    return builder.build();\n}\n\n\nWe add the new dimension to the experiment:\n\n\nCode Block 2.40: The new policy dimension is added to the experiment with four levels. The R0 dimension was reduced to three levels. Thus the experiment will run twelve scenarios.\npublic static void main(String[] args) {\n\n    DiseasePluginData diseasePluginData = getDiseasePluginData();\n    Plugin diseasePlugin = DiseasePlugin.getDiseasePlugin(diseasePluginData);\n\n    PolicyPluginData policyPluginData = getPolicyPluginData();\n    Plugin policyPlugin = PolicyPlugin.getPolicyPlugin(policyPluginData);\n\n    Plugin modelPlugin = ModelPlugin.getModelPlugin();\n\n    Dimension r0Dimension = getR0Dimension();\n\n    Dimension policyDimension = getPolicyDimension();\n\n    Experiment.builder()//\n            .addPlugin(diseasePlugin)//\n            .addPlugin(modelPlugin)//\n            .addPlugin(policyPlugin)//\n            .addDimension(r0Dimension)//\n            .addDimension(policyDimension)//\n            .build()//\n            .execute();\n}\n\n\nThe result is now 12 executed scenarios:\n\n\n\nFigure 2.15: The first two scenarios.\n\n\n\n\n\nModel Actor initializing  r0 = 1.5  asymptomatic days = 4.0  symptomatic days = 12.0  school closing infection rate = 0.05  distribute vaccine locally = false  Model Actor initializing  r0 = 2.0  asymptomatic days = 4.0  symptomatic days = 12.0  school closing infection rate = 0.05  distribute vaccine locally = false \n\n\n\n\n\n\n\n\n…\n\n\n\nFigure 2.16: The last two scenarios.\n\n\n\n\n\nModel Actor initializing  r0 = 2.0  asymptomatic days = 4.0  symptomatic days = 12.0  school closing infection rate = 0.1  distribute vaccine locally = true  Model Actor initializing  r0 = 2.5  asymptomatic days = 4.0  symptomatic days = 12.0  school closing infection rate = 0.1  distribute vaccine locally = true \n\n\n\n\n\n\n\n\nSo far, the experiment has run in a single thread. We now run it in four threads by adding an ExperimentParameterData.\n\n\nCode Block 2.41: Executing the 12 scenarios of the previous experiment with four threads.\npublic static void main(String[] args) {\n\n    DiseasePluginData diseasePluginData = getDiseasePluginData();\n    Plugin diseasePlugin = DiseasePlugin.getDiseasePlugin(diseasePluginData);\n\n    PolicyPluginData policyPluginData = getPolicyPluginData();\n    Plugin policyPlugin = PolicyPlugin.getPolicyPlugin(policyPluginData);\n\n    Plugin modelPlugin = ModelPlugin.getModelPlugin();\n\n    Dimension r0Dimension = getR0Dimension();\n\n    Dimension policyDimension = getPolicyDimension();\n\n    ExperimentParameterData experimentParameterData = ExperimentParameterData.builder()//\n            .setThreadCount(4)//\n            .build();\n\n    /*\n         * Adding threads. Scrambled output\n         */\n    Experiment.builder()//\n            .addPlugin(diseasePlugin)//\n            .addPlugin(modelPlugin)//\n            .addPlugin(policyPlugin)//\n            .addDimension(r0Dimension)//\n            .addDimension(policyDimension)//\n            .setExperimentParameterData(experimentParameterData)//\n            .build()//\n            .execute();\n}\n\n\nThe experiment runs in the main thread and the scenarios now run the four additional threads. The resulting console output a bit jumbled since the writes to the console are now coming from four simultaneous simulation runs:\n\n\n\nFigure 2.17: The output from the four threads running the twelve scenarios is a bit jumbled and hard to follow. This will get resolved later with improved output handling.\n\n\n\n\n\nModel Actor initializing Model Actor initializing  r0 = 1.5 Model Actor initializing Model Actor initializing  r0 = 1.5  asymptomatic days = 4.0  symptomatic days = 12.0  r0 = 2.5  school closing infection rate = 0.05  asymptomatic days = 4.0  asymptomatic days = 4.0  symptomatic days = 12.0  r0 = 2.0  school closing infection rate = 0.1  distribute vaccine locally = false  …\n\n\n\n\n\n\n\n\n\nWe will alleviate this problem as we explore how the simulation and experiment manage output."
  },
  {
    "objectID": "ch02-GettingStarted.html#output-lesson-lesson-10",
    "href": "ch02-GettingStarted.html#output-lesson-lesson-10",
    "title": "2  Getting Started",
    "section": "2.10 Output Lesson (Lesson 10)",
    "text": "2.10 Output Lesson (Lesson 10)\nSo far we have only produced output by writing directly to the console in the various actors and data managers. The simulation contexts (ActorContext / ReportContext / DataManagerContext) provide for the release of output objects to an external handler (outside the simulation). In this lesson, the ModelActor class has been altered to use this mechanism:\n\n\nCode Block 2.42: The model actor now reports output via the release output method provided by its context.\npublic void init(ActorContext actorContext) {\n    DiseaseDataManager diseaseDataManager = actorContext.getDataManager(DiseaseDataManager.class);\n    actorContext.releaseOutput(\"Model Actor initializing\");\n    String tab = \"\\t\";\n    actorContext.releaseOutput(tab + \"r0 = \" + diseaseDataManager.getR0());\n    actorContext.releaseOutput(tab + \"asymptomatic days = \" + diseaseDataManager.getAsymptomaticDays());\n    actorContext.releaseOutput(tab + \"symptomatic days = \" + diseaseDataManager.getSymptomaticDays());\n    PolicyDataManager policyDataManager = actorContext.getDataManager(PolicyDataManager.class);\n    actorContext.releaseOutput(\n            tab + \"school closing infection rate = \" + policyDataManager.getSchoolClosingInfectionRate());\n    actorContext\n            .releaseOutput(tab + \"distribute vaccine locally = \" + policyDataManager.distributeVaccineLocally());\n}\n\n\nData managers can release output in a completely similar way. The output objects are handled by an external handler presented during the build of the simulation:\n\n\nCode Block 2.43: The simulation sends the released output from the contexts to an output consumer.\npublic final class Example_10_A {\n\n    private Example_10_A() {\n    }\n\n    private static DiseasePluginData getDiseasePluginData() {\n        return DiseasePluginData.builder()//\n                .setR0(1.5)//\n                .setAsymptomaticDays(4.0)//\n                .setSymptomaticDays(12.0)//\n                .build();\n    }\n\n    private static PolicyPluginData getPolicyPluginData() {\n        return PolicyPluginData.builder()//\n                .setDistributeVaccineLocally(true)//\n                .setSchoolClosingInfectionRate(0.05)//\n                .build();\n    }\n\n    public static void main(String[] args) {\n\n        DiseasePluginData diseasePluginData = getDiseasePluginData();\n        Plugin diseasePlugin = DiseasePlugin.getDiseasePlugin(diseasePluginData);\n\n        PolicyPluginData policyPluginData = getPolicyPluginData();\n        Plugin policyPlugin = PolicyPlugin.getPolicyPlugin(policyPluginData);\n\n        Plugin modelPlugin = ModelPlugin.getModelPlugin();\n\n        Simulation.builder()//\n                .addPlugin(diseasePlugin)//\n                .addPlugin(modelPlugin)//\n                .addPlugin(policyPlugin)//\n                .setOutputConsumer(new OutputConsumer_A()).build()//\n                .execute();\n    }\n}\n\n\nReleased output objects are sent to the output consumer. In the current example, that consumer is an instance of the class OutputConsumer_A and it simply prints the object to the console:\n\n\nCode Block 2.44: Output consumer A simply prints output to the console.\npublic class OutputConsumer_A implements Consumer<Object> {\n\n    @Override\n    public void accept(Object t) {\n        System.out.println(t);\n    }\n\n}\n\n\nAt first glance this mechanism seems simple and not particularly useful. In practice, one rarely uses the simulation directly and instead favors the experiment which has a somewhat more sophisticated handling of output. With experiments, GCM is potentially using multiple threads to execute each simulation, so output handling must be threadsafe.\n\n2.10.1 Experiment Context\nJust as the simulation supplies contexts, the experiment uses the ExperimentContext to give output consumers a view into the ongoing experiment. It gives each output consumer several capabilities:\n\nSubscription to output by output class type\nSubscription to the opening and closing of the experiment\nSubscription to the opening and closing of each simulation\nScenario status information\nExperiment and Scenario meta data\n\nIn Example_10_B, we bring back the dimensions from previous lessons and will excerpt just the main method:\n\n\nCode Block 2.45: The experiment is now involved in the output process. A new output consumer is used that has access to scenario level information.\npublic static void main(String[] args) {\n\n    DiseasePluginData diseasePluginData = getDiseasePluginData();\n    Plugin diseasePlugin = DiseasePlugin.getDiseasePlugin(diseasePluginData);\n\n    PolicyPluginData policyPluginData = getPolicyPluginData();\n    Plugin policyPlugin = PolicyPlugin.getPolicyPlugin(policyPluginData);\n\n    Plugin modelPlugin = ModelPlugin.getModelPlugin();\n\n    Dimension r0Dimension = getR0Dimension();\n\n    Dimension policyDimension = getPolicyDimension();\n\n    ExperimentParameterData experimentParameterData = ExperimentParameterData.builder()//\n            .setThreadCount(4)//\n            .build();\n\n    Experiment.builder()//\n            .addPlugin(diseasePlugin)//\n            .addPlugin(modelPlugin)//\n            .addPlugin(policyPlugin)//\n            .addDimension(r0Dimension)//\n            .addDimension(policyDimension)//\n            .addExperimentContextConsumer(new OutputConsumer_B())//\n            .setExperimentParameterData(experimentParameterData)//\n            .build()//\n            .execute();\n}\n\n\nLike the simulation, the experiment is adding a consumer for output, but this time that consumer is “consuming” an experiment context. Once the consumer receives that context, it will use it to further subscribe to output and various experiment level events.\n\n\nCode Block 2.46: Output consumer B has access to the experiment level data, so it prints the output to the console as before, but also adds the relevant scenario id.\npublic class OutputConsumer_B implements Consumer<ExperimentContext> {\n\n    @Override\n    public void accept(ExperimentContext experimentContext) {\n        experimentContext.subscribeToOutput(Object.class, this::handleOutput);\n    }\n\n    private void handleOutput(ExperimentContext experimentContext, Integer scenarioId, Object output) {\n        System.out.println(\"scenario \" + scenarioId + \": \" + output);\n    }\n}\n\n\nThe experiment can have any number of ExperimentContext consumers and initializes each at the beginning of its execution via the accept() method. In OuputConsumer_B, the only action the consumer takes is to subscribe to all output and have that output handled by the handleOutput() method. The resulting output shows the scenario id for each line:\n\n\n\nFigure 2.18: The output is still a bit scrambled, but each row now has the relevant scenario id.\n\n\n\n\n\nscenario 1: Model Actor initializing scenario 2: Model Actor initializing scenario 3: Model Actor initializing scenario 0: Model Actor initializing scenario 3: r0 = 1.5 scenario 0: r0 = 1.5 scenario 2: r0 = 2.5 scenario 2: asymptomatic days = 4.0 scenario 1: r0 = 2.0 scenario 2: symptomatic days = 12.0 scenario 1: asymptomatic days = 4.0 scenario 0: asymptomatic days = 4.0 scenario 2: school closing infection rate = 0.05 scenario 3: asymptomatic days = 4.0 scenario 2: distribute vaccine locally = false scenario 0: symptomatic days = 12.0 scenario 1: symptomatic days = 12.0 scenario 0: school closing infection rate = 0.05 scenario 1: school closing infection rate = 0.05 scenario 3: symptomatic days = 12.0 scenario 3: school closing infection rate = 0.1 scenario 1: distribute vaccine locally = false scenario 0: distribute vaccine locally = false scenario 3: distribute vaccine locally = false scenario 5: Model Actor initializing scenario 4: Model Actor initializing scenario 5: r0 = 2.5 scenario 4: r0 = 2.0  … \n\n\n\n\n\n\n\n\nExample_10_C switches the experiment context consumer to an instance of OuputConsumer_C which subscribes to all output types as well as the opening and closing of the experiment and all simulations (scenarios):\n\n\nCode Block 2.47: The output consumer C demonstrates the broader life cycle of the experiment context by printing out experiment and scenario status while still printing output to the console.\npublic class OutputConsumer_C implements Consumer<ExperimentContext> {\n\n    @Override\n    public void accept(ExperimentContext experimentContext) {\n        experimentContext.subscribeToOutput(Object.class, this::handleOutput);\n\n        experimentContext.subscribeToExperimentOpen(this::handleExperimentOpen);\n        experimentContext.subscribeToExperimentClose(this::handleExperimentClose);\n\n        experimentContext.subscribeToSimulationOpen(this::handleSimulationOpen);\n        experimentContext.subscribeToSimulationClose(this::handleSimulationClose);\n    }\n\n    private void handleOutput(ExperimentContext experimentContext, Integer scenarioId, Object output) {\n        System.out.println(\"scenario \" + scenarioId + \": \" + output);\n    }\n\n    private void handleExperimentOpen(ExperimentContext experimentContext) {\n        System.out.println(\"the experiment is open\");\n    }\n\n    private void handleExperimentClose(ExperimentContext experimentContext) {\n        System.out.println(\"the experiment is closed\");\n    }\n\n    private void handleSimulationOpen(ExperimentContext experimentContext, Integer scenarioId) {\n        System.out.println(\"scenario \" + scenarioId + \" is open\");\n    }\n\n    private void handleSimulationClose(ExperimentContext experimentContext, Integer scenarioId) {\n        System.out.println(\"scenario \" + scenarioId + \" is closed\");\n    }\n}\n\n\nThe resulting output shows the usual released output along with the opening and closing of each simulation:\n\n\n\nFigure 2.19: The first output lines for OutputConsumer_C.\n\n\n\n\n\nthe experiment is open scenario 0 is open scenario 1 is open scenario 2 is open scenario 3 is open scenario 0: Model Actor initializing scenario 2: Model Actor initializing scenario 1: Model Actor initializing scenario 2: r0 = 2.5 scenario 3: Model Actor initializing scenario 2: asymptomatic days = 4.0 scenario 1: r0 = 2.0 scenario 0: r0 = 1.5 scenario 2: symptomatic days = 12.0  … \n\n\n\n\n\n\n\n\n\n\n\nFigure 2.20: The last output lines for OutputConsumer_C.\n\n\n\n\n\n…  scenario 11: Model Actor initializing scenario 10: distribute vaccine locally = true scenario 11: r0 = 2.5 scenario 11: asymptomatic days = 4.0 scenario 10 is closed scenario 11: symptomatic days = 12.0 scenario 11: school closing infection rate = 0.1 scenario 11: distribute vaccine locally = true scenario 11 is closed the experiment is closed \n\n\n\n\n\n\n\n\nIn the final example, OuputConsumer_D, we drop the output handling and demonstrate that the meta data used to build the dimensions of the experiment can be retrieved from the experiment context and used for reporting:\n\n\nCode Block 2.48: OutputConsumer_D demonstrates that the meta data collected from the dimensions is available from the experiment context. Thus output can be associated with the scenario’s meta data.\npublic class OutputConsumer_D implements Consumer<ExperimentContext> {\n\n    @Override\n    public void accept(ExperimentContext experimentContext) {\n        experimentContext.subscribeToExperimentOpen(this::handleExperimentOpen);\n        experimentContext.subscribeToSimulationOpen(this::handleSimulationOpen);\n    }\n\n    private void handleExperimentOpen(ExperimentContext experimentContext) {\n\n        StringJoiner joiner = new StringJoiner(\"\\t\", \"\", \"\");\n        joiner.add(\"scenario\");\n        experimentContext.getExperimentMetaData().forEach(joiner::add);\n\n        System.out.println(joiner);\n    }\n\n    private void handleSimulationOpen(ExperimentContext experimentContext, Integer scenarioId) {\n\n        StringJoiner joiner = new StringJoiner(\"\\t\", \"\", \"\");\n        joiner.add(scenarioId.toString());\n        experimentContext.getScenarioMetaData(scenarioId).forEach(joiner::add);\n\n        System.out.println(joiner);\n    }\n\n}\n\n\nThe resulting output shows for each scenario the meta-data that defines that scenario:\n\n\n\nFigure 2.21: The output of consumer D showing the scenario meta data for the twelve scenarios.\n\n\n\n\n\n\nscenario\n\n\nr0\n\n\nschool_closing_infection_rate\n\n\ndistribute_vaccine_locally\n\n\n\n\n\n\n0\n\n\n1.5\n\n\n0.05\n\n\nFALSE\n\n\n\n\n1\n\n\n2.0\n\n\n0.05\n\n\nFALSE\n\n\n\n\n2\n\n\n2.5\n\n\n0.05\n\n\nFALSE\n\n\n\n\n3\n\n\n1.5\n\n\n0.10\n\n\nFALSE\n\n\n\n\n4\n\n\n2.0\n\n\n0.10\n\n\nFALSE\n\n\n\n\n5\n\n\n2.5\n\n\n0.10\n\n\nFALSE\n\n\n\n\n6\n\n\n1.5\n\n\n0.05\n\n\nTRUE\n\n\n\n\n7\n\n\n2.0\n\n\n0.05\n\n\nTRUE\n\n\n\n\n8\n\n\n2.5\n\n\n0.05\n\n\nTRUE\n\n\n\n\n9\n\n\n1.5\n\n\n0.10\n\n\nTRUE\n\n\n\n\n10\n\n\n2.0\n\n\n0.10\n\n\nTRUE\n\n\n\n\n11\n\n\n2.5\n\n\n0.10\n\n\nTRUE\n\n\n\n\n\n\n\n\n\nRecall that as the experiment executes, it utilizes multiple threads to execute the individual scenarios. Thus every experiment context consumer must be threadsafe. We have accomplished this by making each such consumer stateless. In practice, it is often necessary for experiment context consumers to be stateful and this can involve careful consideration of the use of synchronization and other concurrency issues. Fortunately, GCM provides a reporting plugin that deals with these issues and provides a general method for producing tabular reports."
  },
  {
    "objectID": "ch03-StochasticsPlugin.html#plugin-data-initialization",
    "href": "ch03-StochasticsPlugin.html#plugin-data-initialization",
    "title": "3  Stochastics Plugin",
    "section": "3.1 Plugin Data Initialization",
    "text": "3.1 Plugin Data Initialization\nThe plugin is initialized using a StochasticsPluginData object that collects starting seed values for the default RNG as well as any number of RNG identifiers. These identifiers are implemented via the RandomGeneratorId interface which only specifies that such an identifier have a non-null, non-empty and stable implementation of the Object.toString() method.\nAll RNGs in GCM are implemented using the org.apache.commons.math3.random.Well44497b random number generator. GCM introduces the class Well.java that extends the Well44497b to allow for the serialization of its internal state. The data that supports this serialization is contained in the WellState.java class that uses a standard builder pattern. Serialization concerns are beyond the scope of this chapter, so all WellState objects will be seeded with long values only."
  },
  {
    "objectID": "ch03-StochasticsPlugin.html#plugin-behavior",
    "href": "ch03-StochasticsPlugin.html#plugin-behavior",
    "title": "3  Stochastics Plugin",
    "section": "3.2 Plugin Behavior",
    "text": "3.2 Plugin Behavior\nThe plugin adds a single data manager to the simulation as an instance of the StochasticsDataManager that is initialized with the StochasticsPluginData."
  },
  {
    "objectID": "ch03-StochasticsPlugin.html#data-manager",
    "href": "ch03-StochasticsPlugin.html#data-manager",
    "title": "3  Stochastics Plugin",
    "section": "3.3 Data Manager",
    "text": "3.3 Data Manager\nThe data manager provides access to its RNGs via various getter methods."
  },
  {
    "objectID": "ch03-StochasticsPlugin.html#lesson-11-example-11a",
    "href": "ch03-StochasticsPlugin.html#lesson-11-example-11a",
    "title": "3  Stochastics Plugin",
    "section": "3.4 (Lesson 11) Example 11A",
    "text": "3.4 (Lesson 11) Example 11A\nOur first example lesson uses the disease, model and policy plugins again. This time we will have the single ModelActor schedule three random times to set the R0 value to a random number between 1 and 2. Four scenarios will result from a policy based dimension that alters the school closing infection rates, which will not influence the ModelActor.\n\n\nCode Block 3.1: The policy dimension has four levels for the infection rates that trigger school closure.\nprivate static Dimension getPolicyDimension() {\n    FunctionalDimension.Builder builder = FunctionalDimension.builder();//\n\n    List<Double> schoolClosingInfectionRates = new ArrayList<>();\n    schoolClosingInfectionRates.add(0.05);\n    schoolClosingInfectionRates.add(0.10);\n    schoolClosingInfectionRates.add(0.15);\n    schoolClosingInfectionRates.add(0.20);\n\n    for (Double schoolClosingInfectionRate : schoolClosingInfectionRates) {\n        builder.addLevel((context) -> {\n            PolicyPluginData.Builder pluginDataBuilder = context\n                    .getPluginDataBuilder(PolicyPluginData.Builder.class);\n            pluginDataBuilder.setSchoolClosingInfectionRate(schoolClosingInfectionRate);\n\n            ArrayList<String> result = new ArrayList<>();\n            result.add(Double.toString(schoolClosingInfectionRate));\n\n            return result;\n        });//\n    }\n\n    builder.addMetaDatum(\"school_closing_infection_rate\");//\n\n    return builder.build();\n\n}\n\n\n\n\nCode Block 3.2: Example 11 introduces the stochastics plugin and executes four scenarios. The random seed for each scenario will be identical.\npublic static void main(String[] args) {\n\n    DiseasePluginData diseasePluginData = getDiseasePluginData();\n    Plugin diseasePlugin = DiseasePlugin.getDiseasePlugin(diseasePluginData);\n\n    PolicyPluginData policyPluginData = getPolicyPluginData();\n    Plugin policyPlugin = PolicyPlugin.getPolicyPlugin(policyPluginData);\n\n    Plugin modelPlugin = ModelPlugin.getModelPlugin();\n\n    WellState wellState = WellState.builder().setSeed(0).build();\n    StochasticsPluginData stochasticsPluginData = StochasticsPluginData.builder().setMainRNGState(wellState)\n            .build();\n    Plugin stochasticsPlugin = StochasticsPlugin.getStochasticsPlugin(stochasticsPluginData);\n\n    Dimension policyDimension = getPolicyDimension();\n\n    ExperimentParameterData experimentParameterData = ExperimentParameterData.builder()//\n            .setThreadCount(4)//\n            .setHaltOnException(true)//\n            .build();\n\n    Experiment.builder()//\n            .addPlugin(stochasticsPlugin)//\n            .addPlugin(diseasePlugin)//\n            .addPlugin(modelPlugin)//\n            .addPlugin(policyPlugin)//\n            .addDimension(policyDimension)//\n            .addExperimentContextConsumer(new SimpleOutputConsumer())//\n            .setExperimentParameterData(experimentParameterData)//\n            .build()//\n            .execute();\n}\n\n\nThe stochastics plugin is initialized with a seed value of zero and that seed will be used in each scenario as the initial seeding for the default random generator. Thus we expect that each scenario will have identical output.\n\n\n\nFigure 3.1: The output for example 11 shows the four scenarios each reporting three changes to R0 by the model actor.\n\n\n\n\n\n\nscenario\n\n\nschool_closing_infection_rate\n\n\noutput\n\n\n\n\n\n\n1\n\n\n0.10\n\n\nsetting R0 to 1.432233562051883 at time = 3.252869296309885\n\n\n\n\n1\n\n\n0.10\n\n\nsetting R0 to 1.1828080336720215 at time = 4.115633147309184\n\n\n\n\n0\n\n\n0.05\n\n\nsetting R0 to 1.432233562051883 at time = 3.252869296309885\n\n\n\n\n3\n\n\n0.20\n\n\nsetting R0 to 1.432233562051883 at time = 3.252869296309885\n\n\n\n\n1\n\n\n0.10\n\n\nsetting R0 to 1.895526664357549 at time = 8.614888683848772\n\n\n\n\n0\n\n\n0.05\n\n\nsetting R0 to 1.1828080336720215 at time = 4.115633147309184\n\n\n\n\n2\n\n\n0.15\n\n\nsetting R0 to 1.432233562051883 at time = 3.252869296309885\n\n\n\n\n3\n\n\n0.20\n\n\nsetting R0 to 1.1828080336720215 at time = 4.115633147309184\n\n\n\n\n0\n\n\n0.05\n\n\nsetting R0 to 1.895526664357549 at time = 8.614888683848772\n\n\n\n\n2\n\n\n0.15\n\n\nsetting R0 to 1.1828080336720215 at time = 4.115633147309184\n\n\n\n\n3\n\n\n0.20\n\n\nsetting R0 to 1.895526664357549 at time = 8.614888683848772\n\n\n\n\n2\n\n\n0.15\n\n\nsetting R0 to 1.895526664357549 at time = 8.614888683848772"
  },
  {
    "objectID": "ch03-StochasticsPlugin.html#example-11b",
    "href": "ch03-StochasticsPlugin.html#example-11b",
    "title": "3  Stochastics Plugin",
    "section": "3.5 Example 11B",
    "text": "3.5 Example 11B\nOur next example lesson adds a dimension used to alter the initial seed value of the stochastics plugin data to one of three values. Combined with the policy dimension, this will result in 12 scenarios.\n\n\nCode Block 3.3: The stochastics dimension introduces three random seeds that will be used in creating the scenarios. Note that seeds are generated outside of the levels within the dimension.\nprivate static Dimension getStochasticsDimension(long seed) {\n    FunctionalDimension.Builder builder = FunctionalDimension.builder();//\n\n    Random random = new Random(seed);\n\n    List<Long> seedValues = new ArrayList<>();\n    for (int i = 0; i < 3; i++) {\n        seedValues.add(random.nextLong());\n    }\n\n    IntStream.range(0, seedValues.size()).forEach((i) -> {\n        builder.addLevel((context) -> {\n            StochasticsPluginData.Builder stochasticsPluginDataBuilder = context\n                    .getPluginDataBuilder(StochasticsPluginData.Builder.class);\n            long seedValue = seedValues.get(i);\n            WellState wellState = WellState.builder().setSeed(seedValue).build();\n            stochasticsPluginDataBuilder.setMainRNGState(wellState);\n\n            ArrayList<String> result = new ArrayList<>();\n            result.add(Integer.toString(i));\n            result.add(Long.toString(seedValue) + \"L\");\n\n            return result;\n        });\n    });\n\n    builder.addMetaDatum(\"seed index\");//\n    builder.addMetaDatum(\"seed value\");//\n\n    return builder.build();\n}\n\n\n\n\nCode Block 3.4: The experiment uses the stochastics dimension, resulting in twelve scenarios.\npublic static void main(String[] args) {\n\n    DiseasePluginData diseasePluginData = getDiseasePluginData();\n    Plugin diseasePlugin = DiseasePlugin.getDiseasePlugin(diseasePluginData);\n\n    PolicyPluginData policyPluginData = getPolicyPluginData();\n    Plugin policyPlugin = PolicyPlugin.getPolicyPlugin(policyPluginData);\n\n    Plugin modelPlugin = ModelPlugin.getModelPlugin();\n    WellState wellState = WellState.builder().setSeed(0).build();\n    StochasticsPluginData stochasticsPluginData = StochasticsPluginData.builder().setMainRNGState(wellState)\n            .build();\n    Plugin stochasticsPlugin = StochasticsPlugin.getStochasticsPlugin(stochasticsPluginData);\n\n    Dimension policyDimension = getPolicyDimension();\n    Dimension stochasticsDimension = getStochasticsDimension(539847398756272L);\n\n    ExperimentParameterData experimentParameterData = ExperimentParameterData.builder()//\n            .setThreadCount(4)//\n            .build();\n\n    Experiment.builder()//\n            .addPlugin(stochasticsPlugin)//\n            .addPlugin(diseasePlugin)//\n            .addPlugin(modelPlugin)//\n            .addPlugin(policyPlugin)//\n            .addDimension(policyDimension)//\n            .addDimension(stochasticsDimension)//\n            .addExperimentContextConsumer(new SimpleOutputConsumer())//\n            .setExperimentParameterData(experimentParameterData)//\n            .build()//\n            .execute();\n}\n\n\nThe resulting output shows the varying random number generation:\n\n\n\nFigure 3.2: The output show that twelve scearnios result in 36 output lines since the model actor update R0 three times per scenario.\n\n\n\n\n\n\nscenario\n\n\nschool_closing_infection_rate\n\n\nseed_index\n\n\nseed_value\n\n\noutput\n\n\n\n\n\n\n3\n\n\n0.2\n\n\n0\n\n\n1768604912325913878L\n\n\nsetting R0 to 1.4595120508977955 at time = 5.672294645832067\n\n\n\n\n2\n\n\n0.15\n\n\n0\n\n\n1768604912325913878L\n\n\nsetting R0 to 1.4595120508977955 at time = 5.672294645832067\n\n\n\n\n3\n\n\n0.2\n\n\n0\n\n\n1768604912325913878L\n\n\nsetting R0 to 1.672857576347001 at time = 9.396161237311702\n\n\n\n\n1\n\n\n0.1\n\n\n0\n\n\n1768604912325913878L\n\n\nsetting R0 to 1.4595120508977955 at time = 5.672294645832067\n\n\n\n\n0\n\n\n0.05\n\n\n0\n\n\n1768604912325913878L\n\n\nsetting R0 to 1.4595120508977955 at time = 5.672294645832067\n\n\n\n\n3\n\n\n0.2\n\n\n0\n\n\n1768604912325913878L\n\n\nsetting R0 to 1.4552243930124602 at time = 9.545450999459224\n\n\n\n\n1\n\n\n0.1\n\n\n0\n\n\n1768604912325913878L\n\n\nsetting R0 to 1.672857576347001 at time = 9.396161237311702\n\n\n\n\n2\n\n\n0.15\n\n\n0\n\n\n1768604912325913878L\n\n\nsetting R0 to 1.672857576347001 at time = 9.396161237311702\n\n\n\n\n0\n\n\n0.05\n\n\n0\n\n\n1768604912325913878L\n\n\nsetting R0 to 1.672857576347001 at time = 9.396161237311702\n\n\n\n\n1\n\n\n0.1\n\n\n0\n\n\n1768604912325913878L\n\n\nsetting R0 to 1.4552243930124602 at time = 9.545450999459224\n\n\n\n\n2\n\n\n0.15\n\n\n0\n\n\n1768604912325913878L\n\n\nsetting R0 to 1.4552243930124602 at time = 9.545450999459224\n\n\n\n\n0\n\n\n0.05\n\n\n0\n\n\n1768604912325913878L\n\n\nsetting R0 to 1.4552243930124602 at time = 9.545450999459224\n\n\n\n\n4\n\n\n0.05\n\n\n1\n\n\n2407662077113051075L\n\n\nsetting R0 to 1.7124977513361193 at time = 1.878219018807409\n\n\n\n\n4\n\n\n0.05\n\n\n1\n\n\n2407662077113051075L\n\n\nsetting R0 to 1.4297609713254456 at time = 2.4215934269433106\n\n\n\n\n4\n\n\n0.05\n\n\n1\n\n\n2407662077113051075L\n\n\nsetting R0 to 1.5167619787625548 at time = 5.992476899450338\n\n\n\n\n5\n\n\n0.1\n\n\n1\n\n\n2407662077113051075L\n\n\nsetting R0 to 1.7124977513361193 at time = 1.878219018807409\n\n\n\n\n5\n\n\n0.1\n\n\n1\n\n\n2407662077113051075L\n\n\nsetting R0 to 1.4297609713254456 at time = 2.4215934269433106\n\n\n\n\n5\n\n\n0.1\n\n\n1\n\n\n2407662077113051075L\n\n\nsetting R0 to 1.5167619787625548 at time = 5.992476899450338\n\n\n\n\n6\n\n\n0.15\n\n\n1\n\n\n2407662077113051075L\n\n\nsetting R0 to 1.7124977513361193 at time = 1.878219018807409\n\n\n\n\n6\n\n\n0.15\n\n\n1\n\n\n2407662077113051075L\n\n\nsetting R0 to 1.4297609713254456 at time = 2.4215934269433106\n\n\n\n\n6\n\n\n0.15\n\n\n1\n\n\n2407662077113051075L\n\n\nsetting R0 to 1.5167619787625548 at time = 5.992476899450338\n\n\n\n\n7\n\n\n0.2\n\n\n1\n\n\n2407662077113051075L\n\n\nsetting R0 to 1.7124977513361193 at time = 1.878219018807409\n\n\n\n\n7\n\n\n0.2\n\n\n1\n\n\n2407662077113051075L\n\n\nsetting R0 to 1.4297609713254456 at time = 2.4215934269433106\n\n\n\n\n7\n\n\n0.2\n\n\n1\n\n\n2407662077113051075L\n\n\nsetting R0 to 1.5167619787625548 at time = 5.992476899450338\n\n\n\n\n9\n\n\n0.1\n\n\n2\n\n\n-2698580492431892402L\n\n\nsetting R0 to 1.9665140789775497 at time = 4.990978097055602\n\n\n\n\n9\n\n\n0.1\n\n\n2\n\n\n-2698580492431892402L\n\n\nsetting R0 to 1.9525439902956225 at time = 6.227836574620975\n\n\n\n\n9\n\n\n0.1\n\n\n2\n\n\n-2698580492431892402L\n\n\nsetting R0 to 1.8972135699711736 at time = 7.764180353240558\n\n\n\n\n8\n\n\n0.05\n\n\n2\n\n\n-2698580492431892402L\n\n\nsetting R0 to 1.9665140789775497 at time = 4.990978097055602\n\n\n\n\n8\n\n\n0.05\n\n\n2\n\n\n-2698580492431892402L\n\n\nsetting R0 to 1.9525439902956225 at time = 6.227836574620975\n\n\n\n\n8\n\n\n0.05\n\n\n2\n\n\n-2698580492431892402L\n\n\nsetting R0 to 1.8972135699711736 at time = 7.764180353240558\n\n\n\n\n10\n\n\n0.15\n\n\n2\n\n\n-2698580492431892402L\n\n\nsetting R0 to 1.9665140789775497 at time = 4.990978097055602\n\n\n\n\n10\n\n\n0.15\n\n\n2\n\n\n-2698580492431892402L\n\n\nsetting R0 to 1.9525439902956225 at time = 6.227836574620975\n\n\n\n\n10\n\n\n0.15\n\n\n2\n\n\n-2698580492431892402L\n\n\nsetting R0 to 1.8972135699711736 at time = 7.764180353240558\n\n\n\n\n11\n\n\n0.2\n\n\n2\n\n\n-2698580492431892402L\n\n\nsetting R0 to 1.9665140789775497 at time = 4.990978097055602\n\n\n\n\n11\n\n\n0.2\n\n\n2\n\n\n-2698580492431892402L\n\n\nsetting R0 to 1.9525439902956225 at time = 6.227836574620975\n\n\n\n\n11\n\n\n0.2\n\n\n2\n\n\n-2698580492431892402L\n\n\nsetting R0 to 1.8972135699711736 at time = 7.764180353240558"
  },
  {
    "objectID": "ch04-ReportsPlugin.html#plugin-data-initialization",
    "href": "ch04-ReportsPlugin.html#plugin-data-initialization",
    "title": "4  Reports Plugin",
    "section": "4.1 Plugin Data Initialization",
    "text": "4.1 Plugin Data Initialization\nThere is no plugin initialization data class. Reports are contributed by other plugins via their initializers."
  },
  {
    "objectID": "ch04-ReportsPlugin.html#plugin-behavior",
    "href": "ch04-ReportsPlugin.html#plugin-behavior",
    "title": "4  Reports Plugin",
    "section": "4.2 Plugin Behavior",
    "text": "4.2 Plugin Behavior\nThe Plugin contains no data managers, actors or reports."
  },
  {
    "objectID": "ch04-ReportsPlugin.html#experiment-context-consumer",
    "href": "ch04-ReportsPlugin.html#experiment-context-consumer",
    "title": "4  Reports Plugin",
    "section": "4.3 Experiment Context Consumer",
    "text": "4.3 Experiment Context Consumer\nSo far we have seen that reports tend to be produced by specialized classes and that those classes can be added to the simulation via the plugin initialization data. This covers the production and release of the report items from each simulation instance but not what happens to the report items afterward. The output files that receive the report items must work with multiple threads. We manage this with a threadsafe experiment context consumer, the NIOReportItemHandler, that is added to the experiment. The NIOReportItemHandler is created via a builder pattern that allows the modeler to associate report ids to file paths."
  },
  {
    "objectID": "ch04-ReportsPlugin.html#example-reports-lesson-12",
    "href": "ch04-ReportsPlugin.html#example-reports-lesson-12",
    "title": "4  Reports Plugin",
    "section": "4.4 Example Reports (Lesson 12)",
    "text": "4.4 Example Reports (Lesson 12)\nWe reach back to the previous lessons where we introduced plugins for people, families and vaccines for a demonstration of reports. The reports will center on the vaccination of families in various forms and are implemented by three dedicated report classes in the vaccine plugin:\n\nFamilyVaccineReport – Immediate reporting based on observed events\nHourlyVaccineReport – Hourly reporting based on observed events\nStatelessVaccineReport – Hourly reports based on inspection of current state"
  },
  {
    "objectID": "ch04-ReportsPlugin.html#general-setup",
    "href": "ch04-ReportsPlugin.html#general-setup",
    "title": "4  Reports Plugin",
    "section": "4.5 General Setup",
    "text": "4.5 General Setup\nThis example uses the following plugins:\n\nPerson Plugin – provides containment for person identifiers\nStochastics Plugin – (GCM plugin) provides random number generation\nReports Plugin – (GCM plugin) provides reporting mechanisms\nFamily Plugin – defines families and associates people with families\nVaccine Plugin – maintains vaccine assignments with people and families and defines the three reports\nModel Plugin – provides an actor for loading the initial population and an actor for scheduling vaccinations\n\nThe general flow of action in the simulation is that the PopulationLoader actor will add people and families to the simulation based on the initial plugin data provided in the family plugin.  The VaccineScheduler actor will then schedule people at random times to be vaccinated. As people and families are created, people join families and people are vaccinated, the various data mangers will generate the relevant events for observation by the three reports.  The reports will observe these events and correspondingly generate report items that will flow out of the simulation into the experiment level report mechanisms that will result in report files being written.\nLet’s examine Example_12. In Code Block 4.1 we see that the plugins are generated with the person, vaccine and model plugins requiring no input data. The stochastics plugin is generated with a fixed seed value.  Next, the family plugin is created with initial data specifying that 30 families will be created and that each family will have a random number of members up to 5 people.\n\n\nCode Block 4.1: Initialization of the various plugins.\npublic static void main(String[] args) throws IOException {\n    if (args.length == 0) {\n        throw new RuntimeException(\"One output directory argument is required\");\n    }\n    Path outputDirectory = Paths.get(args[0]);\n    if (!Files.exists(outputDirectory)) {\n        Files.createDirectory(outputDirectory);\n    } else {\n        if (!Files.isDirectory(outputDirectory)) {\n            throw new IOException(\"Provided path is not a directory\");\n        }\n    }\n\n    Plugin personPlugin = PersonPlugin.getPersonPlugin();\n\n    Plugin vaccinePlugin = VaccinePlugin.getVaccinePlugin();\n\n    Plugin modelPlugin = ModelPlugin.getModelPlugin();\n\n    WellState wellState = WellState.builder().setSeed(452363456L).build();\n    StochasticsPluginData stochasticsPluginData = StochasticsPluginData.builder().setMainRNGState(wellState)\n            .build();\n    Plugin stochasticsPlugin = StochasticsPlugin.getStochasticsPlugin(stochasticsPluginData);\n\n    FamilyPluginData familyPluginData = FamilyPluginData.builder()//\n            .setFamilyCount(30)//\n            .setMaxFamilySize(5)//\n            .build();\n    Plugin familyPlugin = FamilyPlugin.getFamilyPlugin(familyPluginData);\n\n\nCode Block 4.2 continues with the association of report labels with specific report files. Recall that reports generally use a unique report label and mark each report item with that label. The three reports are added to the simulation by the vaccine plugin.\n\n\nCode Block 4.2: The three reports in this experiment each produce report items and release them as output. The NIOReportItemHandler is initialized here by indicating the file associated with each report.\nNIOReportItemHandler nioReportItemHandler = NIOReportItemHandler.builder()//\n        .addReport(ModelLabel.FAMILY_VACCINE_REPORT, outputDirectory.resolve(\"family_vaccine_report.xls\"))//\n        .addReport(ModelLabel.HOURLY_VACCINE_REPORT, outputDirectory.resolve(\"hourly_vaccine_report.xls\"))//\n        .addReport(ModelLabel.STATELESS_VACCINE_REPORT, outputDirectory.resolve(\"stateless_vaccine_report.xls\"))//\n        .build();\n\n\nEach report label is now associated with a particular file path. Although each file is a tab-delimited text file, we use the .xls file extension so that they can be automatically opened as a spreadsheet. Had we skipped adding these last specifications, the report items would flow out of the simulation and into the experiment but would not find an associated file and thus be ignored.\nFinally, in Code Block 4.3 and Code Block 4.4, we create a single experiment dimension that will override the maximum family size with four values and thus create four scenarios for the experiment.\n\n\nCode Block 4.3: The experiment is executed using the NIOReportItemHandler as an experiment output consumer.\nDimension familySizeDimension = getFamilySizeDimension();\n\nExperiment.builder()//\n        .addPlugin(vaccinePlugin)//\n        .addPlugin(familyPlugin)//\n        .addPlugin(personPlugin)//\n        .addPlugin(modelPlugin)//\n        .addPlugin(stochasticsPlugin)//\n        .addDimension(familySizeDimension)//\n        .addExperimentContextConsumer(nioReportItemHandler)//\n        .build()//\n        .execute();\n\n\n\n\nCode Block 4.4: The family dimension set the maximum family size to four values.\nprivate static Dimension getFamilySizeDimension() {\n    FunctionalDimension.Builder builder = FunctionalDimension.builder();//\n\n    List<Integer> maxFamilySizes = new ArrayList<>();\n\n    maxFamilySizes.add(3);\n    maxFamilySizes.add(5);\n    maxFamilySizes.add(7);\n    maxFamilySizes.add(10);\n\n    for (Integer maxFamilySize : maxFamilySizes) {\n        builder.addLevel((context) -> {\n            FamilyPluginData.Builder pluginDataBuilder = context\n                    .getPluginDataBuilder(FamilyPluginData.Builder.class);\n            pluginDataBuilder.setMaxFamilySize(maxFamilySize);\n\n            ArrayList<String> result = new ArrayList<>();\n            result.add(Double.toString(maxFamilySize));\n\n            return result;\n        });//\n    }\n\n    builder.addMetaDatum(\"max_family_size\");//\n\n    return builder.build();\n\n}"
  },
  {
    "objectID": "ch04-ReportsPlugin.html#the-family-vaccine-report",
    "href": "ch04-ReportsPlugin.html#the-family-vaccine-report",
    "title": "4  Reports Plugin",
    "section": "4.6 The Family Vaccine Report",
    "text": "4.6 The Family Vaccine Report\nThe first report documents the changes in the number of families that are vaccinated over time as individual people receive the vaccine. The field headers for the report are:\n\nscenario – the id of the scenario\nmax_family_size – the maximum family size dictated by the scenario\ntime – the time in days for each item in the report\nunvacinated_families – the number of families that have no members vaccinated\npartially_vaccinated_families – the number of families that have at least one, but not all members vaccinated\nfully_vaccinated_families – the number of families that have all members vaccinated\nunvaccinated_individuals – the number of people who are unvaccinated and have no family assignment\nvaccinated_individuals – the number of people who are vaccinated and have no family assignment\n\nThe experiment report mechanisms are responsible for reporting the scenario and the max_family_size fields since they are part of the experiment design. The remaining fields are contributed by the report. Note that family membership is not guaranteed and that some people may not be associated with any family id. The report accounts for these people in the last two fields.\nThere are four events that drive the report:\n\nthe addition of a person to the simulation\nthe addition of a family to the simulation\nthe assignment of a person to a family\nthe vaccination of a person\n\nNote that the model logic does not allow for the removal of a person from the simulation, the removal of person from a family or loss of vaccination coverage for a person. In a more nuanced model, there would likely be more events that would influence the report.\nThe FamilyVaccineReport has several private fields and classes for maintaining the five counts of the reports. In Code Block 4.5 we have two convenience enumerations for families and individuals that help with the creation of the report header and with maintaining counts.\n\n\nCode Block 4.5: The family vaccine report defines two enums for the vaccination status of families and individuals.\nprivate static enum FamilyVaccineStatus {\n    NONE(\"unvacinated_families\"), //\n    PARTIAL(\"partially_vaccinated_families\"), //\n    FULL(\"fully_vaccinated_families\");//\n\n    private final String description;\n\n    private FamilyVaccineStatus(final String description) {\n        this.description = description;\n    }\n}\n\nprivate static enum IndividualVaccineStatus {\n    NONE(\"unvaccinated_individuals\"), //\n    FULL(\"vaccinated_individuals\");//\n\n    private final String description;\n\n    private IndividualVaccineStatus(final String description) {\n        this.description = description;\n    }\n}\n\n\nCode Block 4.6 shows the remaining private fields.\n\nreport id – remains fixed from construction and is used to mark every report item\nreportHeader – is constructed once and used in the construction of every report item\nactorContext – a convenience reference kept by the actor to retrieve the simulation time\nvaccinationDataManager – a convenience reference to retrieve the vaccination status of each person\nfamilyDataManager – a convenience reference to retrieve the family members associated with a given person who has just been vaccinated\nstatusToFamiliesMap – a map from family vaccine status to a mutable counter\nfamilyToStatusMap – a map for recording the current family vaccine status for each family\nstatusToIndividualMap – a map from individual vaccine status to a mutable counter\nindividualToStatusMap – a map for recording the current individual vaccine status for each person not assigned to a family\n\n\n\nCode Block 4.6: The family vaccine report collects summary data as events unfold and requires a few private data structures to record these events.\nprivate final ReportLabel reportLabel;\n\nprivate ReportHeader reportHeader;\n\nprivate ReportContext reportContext;\n\nprivate VaccinationDataManager vaccinationDataManager;\n\nprivate FamilyDataManager familyDataManager;\n\nprivate final Map<FamilyVaccineStatus, MutableInteger> statusToFamiliesMap = new LinkedHashMap<>();\n\nprivate final Map<FamilyId, FamilyVaccineStatus> familyToStatusMap = new LinkedHashMap<>();\n\nprivate final Map<IndividualVaccineStatus, MutableInteger> statusToIndividualsMap = new LinkedHashMap<>();\n\nprivate final Map<PersonId, IndividualVaccineStatus> individualToStatusMap = new LinkedHashMap<>();\n\n\nThe report’s methods start with its constructor in Code Block 4.7. The report label is recorded and the report header field is built from the support enumerations.\n\n\nCode Block 4.7: The report initializes its data structures.\npublic FamilyVaccineReport(final ReportLabel reportLabel) {\n    this.reportLabel = reportLabel;\n\n    final ReportHeader.Builder builder = ReportHeader.builder();\n    builder.add(\"time\");\n    for (final FamilyVaccineStatus familyVaccineStatus : FamilyVaccineStatus.values()) {\n        builder.add(familyVaccineStatus.description);\n    }\n    for (final IndividualVaccineStatus individualVaccineStatus : IndividualVaccineStatus.values()) {\n        builder.add(individualVaccineStatus.description);\n    }\n    reportHeader = builder.build();\n}\n\n\nNext is the initialization method that was passed to the simulation. This is invoked by the simulation just once at the begining of time flow and gives the report a chance to register for events and to initialize the private fields from Code Block 4.6. The report records the actor context and subscribes to the four events of interest in Code Block 4.8. These subscriptions reference local private methods that will be discussed later.\n\n\nCode Block 4.8: The report must subscribe to the events that are pertinent to reporting individual and family vaccination status.\npublic void init(final ReportContext reportContext) {\n    this.reportContext = reportContext;\n    /*\n         * Subscribe to all the relevant events\n         */\n    reportContext.subscribe(VaccinationEvent.class, this::handleVaccinationEvent);\n    reportContext.subscribe(FamilyAdditionEvent.class, this::handleFamilyAdditionEvent);\n    reportContext.subscribe(FamilyMemberShipAdditionEvent.class, this::handleFamilyMemberShipAdditionEvent);\n    reportContext.subscribe(PersonAdditionEvent.class, this::handlePersonAdditionEvent);\n\n\nIn Code Block 4.9 we continue with the retrieval of the person, family and vaccination data managers. The maps containing the counts are initialized to zero.\n\n\nCode Block 4.9: The local data structures are initialized from the current vaccine states.\nfamilyDataManager = reportContext.getDataManager(FamilyDataManager.class);\nvaccinationDataManager = reportContext.getDataManager(VaccinationDataManager.class);\nPersonDataManager personDataManager = reportContext.getDataManager(PersonDataManager.class);\n\nfor (final FamilyVaccineStatus familyVaccineStatus : FamilyVaccineStatus.values()) {\n    statusToFamiliesMap.put(familyVaccineStatus, new MutableInteger());\n}\n\nfor (final IndividualVaccineStatus individualVaccineStatus : IndividualVaccineStatus.values()) {\n    statusToIndividualsMap.put(individualVaccineStatus, new MutableInteger());\n}\n\n\nCode Block 4.10 and Code Block 4.11 use the data managers to fill the count structures with the current state of the population.\n\n\nCode Block 4.10: Determining vaccine status for each family.\nfor (final FamilyId familyId : familyDataManager.getFamilyIds()) {\n\n    final int familySize = familyDataManager.getFamilySize(familyId);\n    final List<PersonId> familyMembers = familyDataManager.getFamilyMembers(familyId);\n    int vaccinatedCount = 0;\n    for (final PersonId personId : familyMembers) {\n        if (vaccinationDataManager.isPersonVaccinated(personId)) {\n            vaccinatedCount++;\n        }\n    }\n    FamilyVaccineStatus status;\n\n    if (vaccinatedCount == 0) {\n        status = FamilyVaccineStatus.NONE;\n    } else if (vaccinatedCount == familySize) {\n        status = FamilyVaccineStatus.FULL;\n    } else {\n        status = FamilyVaccineStatus.PARTIAL;\n    }\n\n    statusToFamiliesMap.get(status).increment();\n    familyToStatusMap.put(familyId, status);\n\n}\n\n\n\n\nCode Block 4.11: Capturing individuals who have no family association.\nfor (final PersonId personId : personDataManager.getPeople()) {\n    if (familyDataManager.getFamilyId(personId).isEmpty()) {\n\n        IndividualVaccineStatus status;\n        if (vaccinationDataManager.isPersonVaccinated(personId)) {\n            status = IndividualVaccineStatus.FULL;\n        } else {\n            status = IndividualVaccineStatus.NONE;\n        }\n        statusToIndividualsMap.get(status).increment();\n        individualToStatusMap.put(personId, status);\n    }\n}\n\n\nInitialization finishes with the release of a single report item that summarizes the state of family vaccination at time zero.\n\n\nCode Block 4.12: The initial state of the report is released as a single report item.\nreleaseReportItem();\n\n\nThe methods for handling each event are shown in Code Block 4.13. All four methods select some relevant family id or person id and process changes to the counting data structures using the refreshFamilyStatus() and refreshInidividual() methods. The accounting for reports that are synthesizing multiple events can be somewhat tricky. No assumptions are made as to how people are created, vaccinated and added to families so that changes to those processes in future versions of the model do not cause errors in the report.\n\n\nCode Block 4.13: The report will need to have handlers for each of the subscribed events.\nprivate void handleFamilyAdditionEvent(final ReportContext reportContext,\n        final FamilyAdditionEvent familyAdditionEvent) {\n    refreshFamilyStatus(familyAdditionEvent.getFamilyId());\n}\n\nprivate void handleFamilyMemberShipAdditionEvent(final ReportContext reportContext,\n        final FamilyMemberShipAdditionEvent familyMemberShipAdditionEvent) {\n    individualToStatusMap.remove(familyMemberShipAdditionEvent.getPersonId());\n    refreshFamilyStatus(familyMemberShipAdditionEvent.getFamilyId());\n}\n\nprivate void handlePersonAdditionEvent(final ReportContext reportContext,\n        final PersonAdditionEvent personAdditionEvent) {\n    final PersonId personId = personAdditionEvent.getPersonId();\n    final Optional<FamilyId> optional = familyDataManager.getFamilyId(personId);\n    if (optional.isEmpty()) {\n        refreshIndividualStatus(personId);\n    } else {\n        final FamilyId familyId = optional.get();\n        refreshFamilyStatus(familyId);\n    }\n}\n\nprivate void handleVaccinationEvent(final ReportContext reportContext, final VaccinationEvent vaccinationEvent) {\n    final PersonId personId = vaccinationEvent.getPersonId();\n\n    final Optional<FamilyId> optional = familyDataManager.getFamilyId(personId);\n\n    if (optional.isEmpty()) {\n        refreshIndividualStatus(personId);\n    } else {\n        final FamilyId familyId = optional.get();\n        refreshFamilyStatus(familyId);\n    }\n}\n\n\nThe refresh methods in Code Block 4.14 and Code Block 4.15 compare the current vaccination state of the families and individuals against the corresponding states tracked in the counting maps. If a change in the counts has occurred the counts are corrected and a new report item is released.\n\n\nCode Block 4.14: Events that effect the status of a family are processed centrally.\nprivate void refreshFamilyStatus(final FamilyId familyId) {\n\n    final int familySize = familyDataManager.getFamilySize(familyId);\n    final List<PersonId> familyMembers = familyDataManager.getFamilyMembers(familyId);\n    int vaccinatedCount = 0;\n    for (final PersonId personId : familyMembers) {\n        if (vaccinationDataManager.isPersonVaccinated(personId)) {\n            vaccinatedCount++;\n        }\n    }\n    FamilyVaccineStatus newStatus;\n\n    if (vaccinatedCount == 0) {\n        newStatus = FamilyVaccineStatus.NONE;\n    } else if (vaccinatedCount == familySize) {\n        newStatus = FamilyVaccineStatus.FULL;\n    } else {\n        newStatus = FamilyVaccineStatus.PARTIAL;\n    }\n\n    final FamilyVaccineStatus currentStatus = familyToStatusMap.get(familyId);\n    if (currentStatus == newStatus) {\n        return;\n    }\n    if (currentStatus != null) {\n        statusToFamiliesMap.get(currentStatus).decrement();\n    }\n    statusToFamiliesMap.get(newStatus).increment();\n    familyToStatusMap.put(familyId, newStatus);\n    releaseReportItem();\n}\n\n\n\n\nCode Block 4.15: Events that effect the status of an individual are processed centrally.\nprivate void refreshIndividualStatus(final PersonId personId) {\n    IndividualVaccineStatus newStatus;\n    if (vaccinationDataManager.isPersonVaccinated(personId)) {\n        newStatus = IndividualVaccineStatus.FULL;\n    } else {\n        newStatus = IndividualVaccineStatus.NONE;\n    }\n\n    final IndividualVaccineStatus currentStatus = individualToStatusMap.get(personId);\n\n    if (currentStatus == newStatus) {\n        return;\n    }\n\n    if (currentStatus != null) {\n        statusToIndividualsMap.get(currentStatus).decrement();\n    }\n    statusToIndividualsMap.get(newStatus).increment();\n    individualToStatusMap.put(personId, newStatus);\n    releaseReportItem();\n}\n\n\nReleasing the report items that summarizes the family vaccination counts requires building a new report item with the fixed report label and report header values determined in the constructor. We then go on to add the time and count values in the order dictated by the helper enumerations so that they follow the header values established in the report header. Once the report item is complete it is released as output via the report context. The simulation will in turn release the report item to the experiment where it will be distributed to the NIOReportItemHandler and then on the specific file manager(s) that record the items.\n\n\nCode Block 4.16: Each time a family or individual have a relevant change a report item is released.\nprivate void releaseReportItem() {\n    final ReportItem.Builder builder = ReportItem.builder().setReportLabel(reportLabel)\n            .setReportHeader(reportHeader);\n    builder.addValue(reportContext.getTime());\n    for (final FamilyVaccineStatus familyVaccineStatus : statusToFamiliesMap.keySet()) {\n        MutableInteger mutableInteger = statusToFamiliesMap.get(familyVaccineStatus);\n        builder.addValue(mutableInteger.getValue());\n    }\n    for (final IndividualVaccineStatus individualVaccineStatus : statusToIndividualsMap.keySet()) {\n        MutableInteger mutableInteger = statusToIndividualsMap.get(individualVaccineStatus);\n        builder.addValue(mutableInteger.getValue());\n    }\n    final ReportItem reportItem = builder.build();\n    reportContext.releaseOutput(reportItem);\n}\n\n\nThe resulting output in Figure 4.1 contains the four scenarios showing the buildup of the population with all families and individuals being unvaccinated. Over time the number of vaccinated families increase and each simulation ends when all people have been vaccinated. The increase of max family size over the experiment causes there to be more people and thus the number of days to reach full vaccination also increases as expected.\n\n\n\nFigure 4.1: Excerpt of the family vaccine report.\n\n\n\n\n\n\nscenario\n\n\nmax_family_size\n\n\ntime\n\n\nunvacinated_families\n\n\npartially_vaccinated_families\n\n\nfully_vaccinated_families\n\n\nunvaccinated_individuals\n\n\nvaccinated_individuals\n\n\n\n\n\n\n0\n\n\n3.0\n\n\n0.0\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n0\n\n\n3.0\n\n\n0.0\n\n\n1\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n0\n\n\n3.0\n\n\n0.0\n\n\n1\n\n\n0\n\n\n0\n\n\n1\n\n\n0\n\n\n\n\n0\n\n\n3.0\n\n\n0.0\n\n\n1\n\n\n0\n\n\n0\n\n\n2\n\n\n0\n\n\n\n\n0\n\n\n3.0\n\n\n0.0\n\n\n2\n\n\n0\n\n\n0\n\n\n2\n\n\n0\n\n\n\n\n…\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n3.0\n\n\n0.0\n\n\n15\n\n\n0\n\n\n0\n\n\n30\n\n\n0\n\n\n\n\n0\n\n\n3.0\n\n\n0.0\n\n\n16\n\n\n0\n\n\n0\n\n\n30\n\n\n0\n\n\n\n\n0\n\n\n3.0\n\n\n0.0\n\n\n16\n\n\n0\n\n\n0\n\n\n31\n\n\n0\n\n\n\n\n0\n\n\n3.0\n\n\n0.0\n\n\n16\n\n\n0\n\n\n0\n\n\n32\n\n\n0\n\n\n\n\n0\n\n\n3.0\n\n\n0.0\n\n\n17\n\n\n0\n\n\n0\n\n\n32\n\n\n0\n\n\n\n\n…\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n3.0\n\n\n1.0603090039611633\n\n\n28\n\n\n2\n\n\n0\n\n\n63\n\n\n0\n\n\n\n\n0\n\n\n3.0\n\n\n1.114413651330966\n\n\n27\n\n\n3\n\n\n0\n\n\n63\n\n\n0\n\n\n\n\n0\n\n\n3.0\n\n\n1.1516487861564502\n\n\n26\n\n\n4\n\n\n0\n\n\n63\n\n\n0\n\n\n\n\n0\n\n\n3.0\n\n\n1.1871612468129367\n\n\n25\n\n\n5\n\n\n0\n\n\n63\n\n\n0\n\n\n\n\n0\n\n\n3.0\n\n\n1.2426374003057261\n\n\n25\n\n\n4\n\n\n1\n\n\n63\n\n\n0\n\n\n\n\n…\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3\n\n\n10.0\n\n\n8.981789652547315\n\n\n0\n\n\n4\n\n\n26\n\n\n163\n\n\n3\n\n\n\n\n3\n\n\n10.0\n\n\n9.047774924066472\n\n\n0\n\n\n3\n\n\n27\n\n\n163\n\n\n3\n\n\n\n\n3\n\n\n10.0\n\n\n9.101648563188967\n\n\n0\n\n\n2\n\n\n28\n\n\n163\n\n\n3\n\n\n\n\n3\n\n\n10.0\n\n\n9.18260688675053\n\n\n0\n\n\n1\n\n\n29\n\n\n163\n\n\n3\n\n\n\n\n3\n\n\n10.0\n\n\n9.210064962863902\n\n\n0\n\n\n0\n\n\n30\n\n\n163\n\n\n3"
  },
  {
    "objectID": "ch04-ReportsPlugin.html#periodic-reports",
    "href": "ch04-ReportsPlugin.html#periodic-reports",
    "title": "4  Reports Plugin",
    "section": "4.7 Periodic Reports",
    "text": "4.7 Periodic Reports\nProducing a new report item each time a relevant event changes the internal tracking variable of a report actor will often produce too much output. An alternative is to periodically release one or more report items, usually on an hourly or daily basis. The reports plugin defines an abstract report class, the PeriodicReport, that manages the periodic flushing of the state of the report. This allows descendant report classes to concentrate on responding to events while leaving the periodic production of report items to the base class.\nThe PeriodicReport defines a constructor that requires both a report label and a reporting period. If the constructor is overridden, the super() constructor must be invoked. The init() method is declared final in the PeriodicReport class and the descendant report class should implement the prepare() method to conduct initialization. Several protected methods are introduced:\n\nprepare is called by the init() method of the periodic report, it provides the descendant report class with an opportunity to initialize\ngetReportLabel and getReportPeriod retrieve the label and report period passed in construction\naddTimeFieldHeaders is used to help create the report header\nfillTimeFields is used to help create report items\nflush is an abstract method for flushing the content of the report actor that must be implemented by the descendant report class\n\nOur next example report is the HourlyVaccineReport that descends from the PeriodicReport. It produces the same output as the FamilyVaccineReport, but does so on an hourly basis. This outputs a report item every hour whether or not there were stimulating events. The implementation of this report is nearly identical to the previous report and we will concentrate on highlighting the differences between the two approaches.\nIn Code Block 4.17 we see that the constructor invokes the super constructor. The construction of the report header is aided by the protected method addTimeFieldHeaders() which should be invoked as the first inputs to the report header builder. Note as well that we do not store the report label locally.\n\n\nCode Block 4.17: The hourly vaccine report covers the same content as the family vaccine report. Rather than report events as they happen, it instead periodically summarizes these events.\npublic HourlyVaccineReport(ReportLabel reportLabel, ReportPeriod reportPeriod) {\n    super(reportLabel, reportPeriod);\n\n    ReportHeader.Builder builder = ReportHeader.builder();\n    addTimeFieldHeaders(builder);\n    for (FamilyVaccineStatus familyVaccineStatus : FamilyVaccineStatus.values()) {\n        builder.add(familyVaccineStatus.description);\n    }\n    for (IndividualVaccineStatus individualVaccineStatus : IndividualVaccineStatus.values()) {\n        builder.add(individualVaccineStatus.description);\n    }\n    reportHeader = builder.build();\n}\n\n\nThe prepare() method is nearly identical to the previous report’s init() method.\n\n\nCode Block 4.18: The same subscriptions are created as before.\nprotected void prepare(ReportContext reportContext) {\n\n    /*\n         * Subscribe to all the relevant events\n         */     \n\n    reportContext.subscribe(VaccinationEvent.class, this::handleVaccinationEvent);\n    reportContext.subscribe(FamilyAdditionEvent.class, this::handleFamilyAdditionEvent);\n    reportContext.subscribe(FamilyMemberShipAdditionEvent.class, this::handleFamilyMemberShipAdditionEvent);\n    reportContext.subscribe(PersonAdditionEvent.class, this::handlePersonAdditionEvent);\n\n\nThe releaseReportItem() method of the previous report is now replaced by the flush() method override in Code Block 4.19.\n\n\nCode Block 4.19: Once an hour the report releases a report item that summarizes the family and individual vaccine status.\nprotected void flush(ReportContext reportContext) {\n    ReportItem.Builder builder = ReportItem.builder()//\n            .setReportLabel(getReportLabel())//\n            .setReportHeader(reportHeader);\n    fillTimeFields(builder);\n    for (FamilyVaccineStatus familyVaccineStatus : statusToFamiliesMap.keySet()) {\n        MutableInteger mutableInteger = statusToFamiliesMap.get(familyVaccineStatus);\n        builder.addValue(mutableInteger.getValue());\n    }\n    for (IndividualVaccineStatus individualVaccineStatus : statusToIndividualsMap.keySet()) {\n        MutableInteger mutableInteger = statusToIndividualsMap.get(individualVaccineStatus);\n        builder.addValue(mutableInteger.getValue());\n    }\n    ReportItem reportItem = builder.build();\n    reportContext.releaseOutput(reportItem);\n}\n\n\nThe corresponding invocations of the releaseReportItem() that would have generated a new report item each time an event changed the internal counting variables are dropped. The flush() method will be invoked each time the parent report class determines that the planned next period has occurred. Note also that the time fields of the report item are filled by invoking the fillTimeFields() method which will add the correct time value for the period being reported rather than the current time. Otherwise, the implementations are identical.\nThe resulting output in Figure 4.2 contains the four scenarios showing the buildup of the population with all families and individuals being unvaccinated. It shows the same overall pattern as the previous report, but treats the reporting of time in integer days and hours. Note that some of the output values repeat over the days and hours since there were no vaccinations during those periods.\n\n\n\nFigure 4.2: Excerpt from the hourly vaccine report.\n\n\n\n\n\n\nscenario\n\n\nmax_family_size\n\n\nday\n\n\nhour\n\n\nunvacinated_families\n\n\npartially_vaccinated_families\n\n\nfully_vaccinated_families\n\n\nunvaccinated_individuals\n\n\nvaccinated_individuals\n\n\n\n\n\n\n0\n\n\n3.0\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n0\n\n\n3.0\n\n\n0\n\n\n1\n\n\n30\n\n\n0\n\n\n0\n\n\n63\n\n\n0\n\n\n\n\n0\n\n\n3.0\n\n\n0\n\n\n2\n\n\n30\n\n\n0\n\n\n0\n\n\n63\n\n\n0\n\n\n\n\n0\n\n\n3.0\n\n\n0\n\n\n3\n\n\n30\n\n\n0\n\n\n0\n\n\n63\n\n\n0\n\n\n\n\n0\n\n\n3.0\n\n\n0\n\n\n4\n\n\n30\n\n\n0\n\n\n0\n\n\n63\n\n\n0\n\n\n\n\n…\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n3.0\n\n\n2\n\n\n11\n\n\n9\n\n\n17\n\n\n4\n\n\n62\n\n\n1\n\n\n\n\n0\n\n\n3.0\n\n\n2\n\n\n12\n\n\n9\n\n\n17\n\n\n4\n\n\n62\n\n\n1\n\n\n\n\n0\n\n\n3.0\n\n\n2\n\n\n13\n\n\n8\n\n\n17\n\n\n5\n\n\n62\n\n\n1\n\n\n\n\n0\n\n\n3.0\n\n\n2\n\n\n14\n\n\n8\n\n\n17\n\n\n5\n\n\n62\n\n\n1\n\n\n\n\n0\n\n\n3.0\n\n\n2\n\n\n15\n\n\n8\n\n\n17\n\n\n5\n\n\n62\n\n\n1\n\n\n\n\n…\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2\n\n\n7.0\n\n\n3\n\n\n3\n\n\n8\n\n\n21\n\n\n1\n\n\n128\n\n\n1\n\n\n\n\n2\n\n\n7.0\n\n\n3\n\n\n4\n\n\n8\n\n\n21\n\n\n1\n\n\n128\n\n\n1\n\n\n\n\n2\n\n\n7.0\n\n\n3\n\n\n5\n\n\n8\n\n\n21\n\n\n1\n\n\n128\n\n\n1\n\n\n\n\n2\n\n\n7.0\n\n\n3\n\n\n6\n\n\n8\n\n\n21\n\n\n1\n\n\n128\n\n\n1\n\n\n\n\n2\n\n\n7.0\n\n\n3\n\n\n7\n\n\n8\n\n\n21\n\n\n1\n\n\n128\n\n\n1\n\n\n\n\n…\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3\n\n\n10.0\n\n\n9\n\n\n2\n\n\n0\n\n\n3\n\n\n27\n\n\n163\n\n\n3\n\n\n\n\n3\n\n\n10.0\n\n\n9\n\n\n3\n\n\n0\n\n\n2\n\n\n28\n\n\n163\n\n\n3\n\n\n\n\n3\n\n\n10.0\n\n\n9\n\n\n4\n\n\n0\n\n\n2\n\n\n28\n\n\n163\n\n\n3\n\n\n\n\n3\n\n\n10.0\n\n\n9\n\n\n5\n\n\n0\n\n\n1\n\n\n29\n\n\n163\n\n\n3\n\n\n\n\n3\n\n\n10.0\n\n\n9\n\n\n6\n\n\n0\n\n\n0\n\n\n30\n\n\n163\n\n\n3\n\n\n\n\n\n\n\n\n\nOur final example, the StatelessVaccineReport , Code Block 4.20, continues from the HourlyVaccineReport but eschews the stateful counting mechanisms. Like the previous report, it is a periodic report actor but it does not store any state and does not subscribe to any events. Instead, it simply derives the report item on each flush() invocation.\n\n\nCode Block 4.20: The stateless vaccine report does not process any events. Instead, it periodically derives the report item by polling the relevant data managers.\nprotected void flush(ReportContext reportContext) {\n\n    FamilyDataManager familyDataManager = reportContext.getDataManager(FamilyDataManager.class);\n    VaccinationDataManager vaccinationDataManager = reportContext.getDataManager(VaccinationDataManager.class);\n    PersonDataManager personDataManager = reportContext.getDataManager(PersonDataManager.class);\n\n    Map<VaccineStatus, MutableInteger> statusMap = new LinkedHashMap<>();\n    for (VaccineStatus vaccineStatus : VaccineStatus.values()) {\n        statusMap.put(vaccineStatus, new MutableInteger());\n    }\n\n    // determine the family vaccine status for every family\n    for (FamilyId familyId : familyDataManager.getFamilyIds()) {\n        VaccineStatus vaccineStatus = getFamilyStatus(familyId, vaccinationDataManager, familyDataManager);\n        statusMap.get(vaccineStatus).increment();\n    }\n\n    // ensure that any person not assigned to a family is still counted\n    for (PersonId personId : personDataManager.getPeople()) {\n        if (familyDataManager.getFamilyId(personId).isEmpty()) {\n            VaccineStatus vaccineStatus = getIndividualStatus(personId, vaccinationDataManager);\n            statusMap.get(vaccineStatus).increment();\n        }\n    }\n    ReportHeader.Builder headerBuilder = ReportHeader.builder();\n    addTimeFieldHeaders(headerBuilder);\n    for (VaccineStatus vaccineStatus : VaccineStatus.values()) {\n        headerBuilder.add(vaccineStatus.description);\n    }\n    ReportHeader reportHeader = headerBuilder.build();\n\n    ReportItem.Builder builder = ReportItem.builder()//\n            .setReportLabel(getReportLabel())//\n            .setReportHeader(reportHeader);\n    fillTimeFields(builder);\n    for (VaccineStatus vaccineStatus : VaccineStatus.values()) {\n        int value = statusMap.get(vaccineStatus).getValue();\n        builder.addValue(value);\n    }\n\n    ReportItem reportItem = builder.build();\n    reportContext.releaseOutput(reportItem);\n\n}\n\n\nThis approach may seem wasteful since there is the potential for a great deal of recalculation, but since this is done on a daily basis, it may be well worth the reduction in memory if the report was actively tracking millions of families."
  },
  {
    "objectID": "ch05-Properties.html#property-identifiers",
    "href": "ch05-Properties.html#property-identifiers",
    "title": "5  Properties",
    "section": "5.1 Property Identifiers",
    "text": "5.1 Property Identifiers\nProperty Ids are generally marker interfaces used to force unambiguous types in method signatures dealing with property related concepts. Each plugin that uses properties will introduce its own marker interface(s) and instances of the identifier are left to client (other plugins) to implement. This is often accomplished with enumerations."
  },
  {
    "objectID": "ch05-Properties.html#property-definitions",
    "href": "ch05-Properties.html#property-definitions",
    "title": "5  Properties",
    "section": "5.2 Property Definitions",
    "text": "5.2 Property Definitions\nProperty definitions supply each plugin with:\n\nA class reference that defines the type of the property values\nA Boolean value indicating if property values are mutable\nAn optional default property value\n\nThe mutability indicator controls whether property values can be set after the initial value is established. For example, consider the integer property “age” that is defined for people. Each person has a distinct integer age upon initial value assignment. If the property definition asserts that the property is not mutable, then the age value cannot be changed during the simulation’s execution. This is often used to fix global property values so that there is no chance that they can be reset by mistake.\nIt is often useful to know when a property was last assigned. Some plugins will introduce tracking of property value assignment times based on a policy per property id to avoid recording such time values where there would be tens of millions of entries and no use of these values by the modeler.\nDefault property values are used to spare the modeler from having to set property values when introducing new items to the simulation. For example, when adding a person to the simulation it might be useful to have a default of false for the property of “vaccinated”. However, for some properties there may be no meaningful default value. For example, consider the “age” property for a person. What would constitute a good default value? For this reason, supplying a default value as part of the property definition is optional. Property values in GCM are never null. If a property definition does not supply a default value, then all assoicated property values must be explicitly set to non-null values."
  },
  {
    "objectID": "ch05-Properties.html#concurrency-requirements",
    "href": "ch05-Properties.html#concurrency-requirements",
    "title": "5  Properties",
    "section": "5.3 Concurrency Requirements",
    "text": "5.3 Concurrency Requirements\nProperty ids, property definitions and property values must be thread safe since they are shared across multiple scenarios (different simulation instances). It is usually best practice if they are implemented as immutable classes.\n\nProperty ids are usually marker interfaces and are often implemented by static enumerations and are thus generally threadsafe\nThe PropertyDefinition class is provided by the utility and is threadsafe subject to the thread safety of its default value\nProperty values are often boxed primitives and are generally threadsafe. In general, mutation of a property value in GCM does not mean that the property value is mutated. Rather, it usually means that a new immutable value is now associated with the property id."
  },
  {
    "objectID": "ch05-Properties.html#immutability",
    "href": "ch05-Properties.html#immutability",
    "title": "5  Properties",
    "section": "5.4 Immutability",
    "text": "5.4 Immutability\nFor a class to be immutable in Java it must meet three requirements:\n\nIts internal fields must not be mutated. There can be no setter methods or any other mechanism that changes an assignment post construction\nAll fields are declared final\nNo reference to the immutable object may be passed during its construction"
  },
  {
    "objectID": "ch05-Properties.html#expected-behaviors-of-plugins-using-properties",
    "href": "ch05-Properties.html#expected-behaviors-of-plugins-using-properties",
    "title": "5  Properties",
    "section": "5.5 Expected Behaviors of Plugins using properties",
    "text": "5.5 Expected Behaviors of Plugins using properties\nAll implementations of property mechanisms in GCM are expected to meet the following requirements:\n\nProperty values are never null\nProperty definitions that do not supply a default value must be supported by other mechanisms that ensure that property values are never null\nProperty instance values must always be assignment compatible to their corresponding property definition’s property type reference"
  },
  {
    "objectID": "ch06-GlobalPropertiesPlugin.html#plugin-data-initialization",
    "href": "ch06-GlobalPropertiesPlugin.html#plugin-data-initialization",
    "title": "6  Global Properties Plugin",
    "section": "6.1 Plugin Data Initialization",
    "text": "6.1 Plugin Data Initialization\nThe plugin is initialized using a GlobalPropertiesPluginData object that collects global property definitions and global property values. Even though the property definitions can contain default property values, the ability to set property values is included to add some flexibility to the collection process since the client model may separate definitions from values in its input files."
  },
  {
    "objectID": "ch06-GlobalPropertiesPlugin.html#plugin-behavior",
    "href": "ch06-GlobalPropertiesPlugin.html#plugin-behavior",
    "title": "6  Global Properties Plugin",
    "section": "6.2 Plugin Behavior",
    "text": "6.2 Plugin Behavior\nThe plugin adds a single data manager to the simulation as an instance of the GlobalPropertiesDataManager that is initialized with the GlobalPropertiesPluginData."
  },
  {
    "objectID": "ch06-GlobalPropertiesPlugin.html#data-manager",
    "href": "ch06-GlobalPropertiesPlugin.html#data-manager",
    "title": "6  Global Properties Plugin",
    "section": "6.3 Data Manager",
    "text": "6.3 Data Manager\nThe data manager provides access to the global properties and provides the ability to:\n\nDefine new global properties (not contained in the initial data)\nRetrieve global property definitions\nRetrieve global property ids\nRetrieve global property values and the times when they were set\nSet global property values\n\nThe data manager also produces observable events when a new global property is defined or when a global property value is assigned. The plugin provides the GlobalPropertyReport that subscribes to these events and produces a trace report of property value assignments."
  },
  {
    "objectID": "ch06-GlobalPropertiesPlugin.html#example-code-lesson-13",
    "href": "ch06-GlobalPropertiesPlugin.html#example-code-lesson-13",
    "title": "6  Global Properties Plugin",
    "section": "6.4 Example Code (Lesson 13)",
    "text": "6.4 Example Code (Lesson 13)\nExample_13.java shows a simple usage of the global properties plugin. In it we will add three double valued properties: ALPHA, BETA, and GAMMA. ALPHA and BETA will be used to vary the scenarios in the experiment and GAMMA will be set to a simple function of ALPHA and BETA that will change over time in the simulation. This will culminate in a report that shows each time the global variables are defined or their values are set.\nThe example includes two plugins:\n\nGlobal properties plugin – (GCM core plugin) used to manage the properties\nModel plugin – (local plugin) used to introduce a single actor that will alter the value of GAMMA over time\n\nThe example’s main method in Code Block 6.1 adds the two plugins:\n\nGlobal properties plugin\n\ninitialized with the three global properties\nadds the GlobalPropertyReport\n\nModel plugin\n\nUses no inputs, but will add a single instance of the GammaActor class\n\n\nThe main method continues by associating the report to a file via the NIOReportItemHandler. It then forms a dimension for the experiment from variant values of ALPHA and BETA. Finally, it executes the experiment.\n\n\nCode Block 6.1: Using the global properties plugin to add three global properties.\npublic static void main(String[] args) throws IOException {\n    if (args.length == 0) {\n        throw new RuntimeException(\"One output directory argument is required\");\n    }\n    Path outputDirectory = Paths.get(args[0]);\n    if (!Files.exists(outputDirectory)) {\n        Files.createDirectory(outputDirectory);\n    } else {\n        if (!Files.isDirectory(outputDirectory)) {\n            throw new IOException(\"Provided path is not a directory\");\n        }\n    }\n\n    GlobalPropertiesPluginData globalPropertiesPluginData = getGlobalPropertiesPluginData();\n\n    GlobalPropertyReportPluginData globalPropertyReportPluginData = GlobalPropertyReportPluginData.builder()//\n            .setReportLabel(ModelReportLabel.GLOBAL_PROPERTY_REPORT)//\n            .setDefaultInclusion(true)//\n            .build();\n\n    Plugin globalPropertiesPlugin = GlobalPropertiesPlugin.builder()\n            .setGlobalPropertiesPluginData(globalPropertiesPluginData)\n            .setGlobalPropertyReportPluginData(globalPropertyReportPluginData)//\n            .getGlobalPropertiesPlugin();\n\n    Plugin modelPlugin = ModelPlugin.getModelPlugin();\n\n    NIOReportItemHandler nioReportItemHandler = //\n            NIOReportItemHandler.builder()//\n                    .addReport(ModelReportLabel.GLOBAL_PROPERTY_REPORT, //\n                            outputDirectory.resolve(\"global property report.xls\"))//\n                    .build();\n\n    Dimension alphaBetaDimension = getAlphaBetaDimension();\n\n    Experiment.builder()//\n            .addPlugin(globalPropertiesPlugin)//\n            .addPlugin(modelPlugin)//\n            .addExperimentContextConsumer(nioReportItemHandler)//\n            .addDimension(alphaBetaDimension)//\n            .build()//\n            .execute();//\n\n}\n\n\nInitialization of the global properties is shown in Code Block 6.2.\n\n\nCode Block 6.2: Initializing the global properties plugin data with three property definitions.\nprivate static GlobalPropertiesPluginData getGlobalPropertiesPluginData() {\n    GlobalPropertiesPluginData.Builder builder = GlobalPropertiesPluginData.builder();//\n\n    PropertyDefinition propertyDefinition = PropertyDefinition.builder()//\n            .setType(Double.class)//\n            .setDefaultValue(2.0)//\n            .setPropertyValueMutability(false)//\n            .build();\n    builder.defineGlobalProperty(GlobalProperty.ALPHA, propertyDefinition, 0);\n\n    propertyDefinition = PropertyDefinition.builder()//\n            .setType(Double.class)//\n            .setDefaultValue(5.0)//\n            .setPropertyValueMutability(false)//\n            .build();\n\n    builder.defineGlobalProperty(GlobalProperty.BETA, propertyDefinition, 0);\n\n    propertyDefinition = PropertyDefinition.builder()//\n            .setType(Double.class)//\n            .setDefaultValue(1.0)//\n            .setPropertyValueMutability(true)//\n            .build();\n\n    builder.defineGlobalProperty(GlobalProperty.GAMMA, propertyDefinition, 0);\n\n    return builder.build();\n}\n\n\nCode Block 6.3 shows the construction of the experiment’s single dimension.\n\n\nCode Block 6.3: A dimension is created that adds five pairs of values over the ALPHA and BETA global properties.\nprivate static Dimension getAlphaBetaDimension() {\n    List<Pair<Double, Double>> alphaBetaPairs = new ArrayList<>();\n    alphaBetaPairs.add(new Pair<>(3.0, 10.0));\n    alphaBetaPairs.add(new Pair<>(12.0, 25.0));\n    alphaBetaPairs.add(new Pair<>(30.0, 40.0));\n    alphaBetaPairs.add(new Pair<>(45.0, 70.0));\n    alphaBetaPairs.add(new Pair<>(80.0, 100.0));\n\n    FunctionalDimension.Builder dimensionBuilder = FunctionalDimension.builder();\n\n    for (Pair<Double, Double> pair : alphaBetaPairs) {\n        dimensionBuilder.addLevel((c) -> {\n            List<String> result = new ArrayList<>();\n            GlobalPropertiesPluginData.Builder builder = c\n                    .getPluginDataBuilder(GlobalPropertiesPluginData.Builder.class);\n            builder.setGlobalPropertyValue(GlobalProperty.ALPHA, pair.getFirst(), 0);\n            builder.setGlobalPropertyValue(GlobalProperty.BETA, pair.getSecond(), 0);\n            result.add(pair.getFirst().toString());\n            result.add(pair.getSecond().toString());\n            return result;\n        });\n    }\n\n    dimensionBuilder.addMetaDatum(GlobalProperty.ALPHA.toString());\n    dimensionBuilder.addMetaDatum(GlobalProperty.BETA.toString());\n\n    return dimensionBuilder.build();\n}\n\n\nThe GammaActor class in Code Block 6.4 schedules 10 plans, set one day apart, to change the GAMMA value as a successive interpolation between the ALPHA and BETA values that are in turn controlled by the experiment.\n\n\nCode Block 6.4: The gamma actor sets the value of the GAMMA property over time as a function of the ALPHA and BETA properties.\npublic final class GammaActor {\n\n    public void init(ActorContext actorContext) {\n        int count = 10;\n        IntStream.range(0, count).forEach((i) -> {\n            actorContext.addPlan((c) -> {\n                GlobalPropertiesDataManager globalPropertiesDataManager = c\n                        .getDataManager(GlobalPropertiesDataManager.class);\n                Double alpha = globalPropertiesDataManager.getGlobalPropertyValue(GlobalProperty.ALPHA);\n                Double beta = globalPropertiesDataManager.getGlobalPropertyValue(GlobalProperty.BETA);\n                double gamma = (beta - alpha) * i / count + alpha;\n                globalPropertiesDataManager.setGlobalPropertyValue(GlobalProperty.GAMMA, gamma);\n            }, i + 1);\n        });\n    }\n}\n\n\nThe resultant global properties report shows the correct interpolated values for the five scenarios in Figure 6.1.\n\n\n\nFigure 6.1: An excerpt of the global property report showing the three global property values over time in the five scenarios.\n\n\n\n\n\n\nscenario\n\n\nALPHA\n\n\nBETA\n\n\ntime\n\n\nproperty\n\n\nvalue\n\n\n\n\n\n\n0\n\n\n3.0\n\n\n10.0\n\n\n0.0\n\n\nALPHA\n\n\n3.0\n\n\n\n\n0\n\n\n3.0\n\n\n10.0\n\n\n0.0\n\n\nBETA\n\n\n10.0\n\n\n\n\n0\n\n\n3.0\n\n\n10.0\n\n\n0.0\n\n\nGAMMA\n\n\n1.0\n\n\n\n\n0\n\n\n3.0\n\n\n10.0\n\n\n1.0\n\n\nGAMMA\n\n\n3.0\n\n\n\n\n0\n\n\n3.0\n\n\n10.0\n\n\n2.0\n\n\nGAMMA\n\n\n3.7\n\n\n\n\n0\n\n\n3.0\n\n\n10.0\n\n\n3.0\n\n\nGAMMA\n\n\n4.4\n\n\n\n\n0\n\n\n3.0\n\n\n10.0\n\n\n4.0\n\n\nGAMMA\n\n\n5.1\n\n\n\n\n0\n\n\n3.0\n\n\n10.0\n\n\n5.0\n\n\nGAMMA\n\n\n5.8\n\n\n\n\n0\n\n\n3.0\n\n\n10.0\n\n\n6.0\n\n\nGAMMA\n\n\n6.5\n\n\n\n\n0\n\n\n3.0\n\n\n10.0\n\n\n7.0\n\n\nGAMMA\n\n\n7.2\n\n\n\n\n…\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\n\n\n12.0\n\n\n25.0\n\n\n9.0\n\n\nGAMMA\n\n\n22.4\n\n\n\n\n1\n\n\n12.0\n\n\n25.0\n\n\n10.0\n\n\nGAMMA\n\n\n23.7\n\n\n\n\n2\n\n\n30.0\n\n\n40.0\n\n\n0.0\n\n\nALPHA\n\n\n30.0\n\n\n\n\n2\n\n\n30.0\n\n\n40.0\n\n\n0.0\n\n\nBETA\n\n\n40.0\n\n\n\n\n2\n\n\n30.0\n\n\n40.0\n\n\n0.0\n\n\nGAMMA\n\n\n1.0\n\n\n\n\n2\n\n\n30.0\n\n\n40.0\n\n\n1.0\n\n\nGAMMA\n\n\n30.0\n\n\n\n\n…\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4\n\n\n80.0\n\n\n100.0\n\n\n7.0\n\n\nGAMMA\n\n\n92.0\n\n\n\n\n4\n\n\n80.0\n\n\n100.0\n\n\n8.0\n\n\nGAMMA\n\n\n94.0\n\n\n\n\n4\n\n\n80.0\n\n\n100.0\n\n\n9.0\n\n\nGAMMA\n\n\n96.0\n\n\n\n\n4\n\n\n80.0\n\n\n100.0\n\n\n10.0\n\n\nGAMMA\n\n\n98.0"
  },
  {
    "objectID": "ch07-PeoplePlugin.html#plugin-data-initialization",
    "href": "ch07-PeoplePlugin.html#plugin-data-initialization",
    "title": "7  People Plugin",
    "section": "7.1 Plugin Data Initialization",
    "text": "7.1 Plugin Data Initialization\nThe plugin is initialized using a PeoplePluginData object that collects person id values in contiguous ranges. Note that there is no auxiliary data about people and only their existence as a person at the start of the simulation is captured. Other plugins that deal with the various characteristics of people will separately handle adding that data via their own plugin data structures."
  },
  {
    "objectID": "ch07-PeoplePlugin.html#plugin-behavior",
    "href": "ch07-PeoplePlugin.html#plugin-behavior",
    "title": "7  People Plugin",
    "section": "7.2 Plugin Behavior",
    "text": "7.2 Plugin Behavior\nThe plugin adds a single data manager to the simulation as an instance of the PeopleDataManager that is initialized with the PeoplePluginData."
  },
  {
    "objectID": "ch07-PeoplePlugin.html#data-manager",
    "href": "ch07-PeoplePlugin.html#data-manager",
    "title": "7  People Plugin",
    "section": "7.3 Data Manager",
    "text": "7.3 Data Manager\nThe data manager provides access to people and provides the ability to:\n\nAdd or remove a person\nAnswer questions about person existence\n\nGet the current set of PersonId values\n\nGet the total number of people\nTransform PersonId objects to and from int values\n\nAnswer questions about int value ranges used in managing internal data structures in various data managers\n\n\nThe data manager also produces observable events when people are added or removed from the simulation:\n\nPersonImminentAdditionEvent – notifies that a person is about to be removed\nPersonAdditionEvent – notifies that a person is removed\nPersonImminentRemovalEvent – notifies that a person is being added\nPersonRemovalEvent – notifies that a person is fully added"
  },
  {
    "objectID": "ch07-PeoplePlugin.html#addremove-event-patterns",
    "href": "ch07-PeoplePlugin.html#addremove-event-patterns",
    "title": "7  People Plugin",
    "section": "7.4 Add/Remove event patterns",
    "text": "7.4 Add/Remove event patterns\nA common pattern used throughout many plugins for events signifying the addition or removal of an item from the simulation is to represent each of these with two events. The first event is to notify all concerned actors and data managers that an item is about to be removed, but the removal has not yet occurred so any reference to the item will still be available and any finalization or bookkeeping can be performed. The second event will act as an instruction to remove the item and it is expected that the item will not be available for further inspection.\nAs an example, let’s consider the removal of a person by an actor. The person to remove is PersonId[47] and the actor requests the person be removed by the PeopleDataManager. The data manager first plans to release the PersonRemovalEvent as soon as possible. This will schedule the release of the event onto the planning queue and time will not move forward before the execution of this event. However, this is a plan and it will only take place after the all current activities are complete. The data manager next releases the PersonImminentRemovalEvent. This event will propagate immediately to the other data managers and to any actors or reports that are subscribed to person removals. Since the data managers generally do not act on the imminent removal, the actors are able to retrieve any information about the person they need to take final actions or produce reports. Once everyone has had a chance to see that the person will be removed, the planned PersonRemovalEvent will be released and the data managers will finally remove any information related to the person from their data structures. This two-phase removal pattern is useful and practical but does present one problem: Consider the original actor that was deleting person 47. On the very next line of their code after they request the removal of the person, the person still exists. The removal is not immediate, but is slightly delayed in that it will occur only after flow of control has returned to the simulation. This delay will not correspond to any time flow, so the removal of the person will occur at the same time as the request for the removal.\nThe addition of a person follows a similar pattern. To understand this, we first need to look at the PersonConstructionData used to add a person. The PersonConstructionData is a container for zero to many objects that carry information about the new person to be used by the various data managers who will need to integrate corresponding data about the person. For example, if the Regions plugin is being used, it requires that every person has a region assignment and thus a RegionId will need to be included in the PersonConstructionData. The people data manager does not understand this auxiliary data but simply repackages it into the PersonImminentAdditionEvent. The event is released and all the relevant data managers take what they need from the data stored in the event to fully initialize the state of the person. Once all data managers have initialized the person, the people data manager releases the PersonAdditionEvent and actors/reports, will now see that the new person has been added to the simulation and will have access to the person’s full initialized complement of data.\nIn summary, the general convention is:\n\nimminent addition event\n\nused by data managers to piecemeal add an item’s details\nignored by actors and reports\n\naddition event\n\nignored by data managers\nused by actors and reports to integrate the addition now that all the details are in place\n\nimminent removal event\n\nignored by data managers\nused by actors to have a last chance to reference details on the item\n\nremoval event\n\nused by data managers to fully remove all stored data on the item\nignored by the actors since the item will be fully removed"
  },
  {
    "objectID": "ch07-PeoplePlugin.html#example-code-lesson-14",
    "href": "ch07-PeoplePlugin.html#example-code-lesson-14",
    "title": "7  People Plugin",
    "section": "7.5 Example Code (Lesson 14)",
    "text": "7.5 Example Code (Lesson 14)\nExample_14.java shows the use of the people plugin. The example includes four plugins:\n\nPeople plugin – (GCM core plugin) used to manage people\nStochastics Plugin – (GCM plugin) provides random number generation\nModel plugin – (local plugin) used to introduce two actors that will\n\nadd/remove people\nvaccinate people\n\nVaccine plugin – (local plugin) used to track vaccinations for each person\n\nThe example’s main method starts in Code Block 7.1 by establishing two reports:\n\nThe population trace report simply lists the additions and deletions of people by time. The report is managed by the PopulationTraceReport and is added to the simulation by the model plugin.\nThe vaccination report shows a daily accounting of the number of people having 0, 1…6+ vaccinations. The report is managed by the VaccineReport class added by the vaccine plugin.\n\n\n\nCode Block 7.1: The population trace and vaccination reports are associated with corresponding file names via the NIO report item handler.\npublic static void main(String[] args) throws IOException {\n    if (args.length == 0) {\n        throw new RuntimeException(\"One output directory argument is required\");\n    }\n    Path outputDirectory = Paths.get(args[0]);\n    if (!Files.exists(outputDirectory)) {\n        Files.createDirectory(outputDirectory);\n    } else {\n        if (!Files.isDirectory(outputDirectory)) {\n            throw new IOException(\"Provided path is not a directory\");\n        }\n    }\n\n    // reports\n    NIOReportItemHandler nioReportItemHandler = //\n            NIOReportItemHandler.builder()//\n                    .addReport(ModelReportLabel.POPULATION_TRACE, //\n                            outputDirectory.resolve(\"population_trace_report.xls\"))//\n                    .addReport(ModelReportLabel.VACCINATION, //\n                            outputDirectory.resolve(\"vaccination_report.xls\"))//\n                    .build();\n\n\nThe main method continues by creating the people plugin and initializing it with 10 people. Note that the people will have id values of 1, 3, 5, … ,19 showing that any set of non-negative values are acceptable. The stochastics plugin is next and is initialized with a seed value. We will be controlling the random seed values via a dimension as presented in Code Block 7.3. As a result, the experiment will have 5 scenarios, with each scenario differing in only the random seed value that starts the simulation.\n\n\nCode Block 7.2: The various plugins are initialized with data and added to the experiment.\n        // create the people plugin with an initial population of ten people,\n        // numbered 1, 3, 5,...,19\n        PeoplePluginData.Builder peoplePluginDataBuilder = PeoplePluginData.builder();\n        for (int i = 0; i < 10; i++) {\n            PersonId personId = new PersonId(i * 2 + 1);\n            peoplePluginDataBuilder.addPersonRange(new PersonRange(personId.getValue(), personId.getValue()));\n        }\n        PeoplePluginData peoplePluginData = peoplePluginDataBuilder.build();\n        Plugin peoplePlugin = PeoplePlugin.getPeoplePlugin(peoplePluginData);\n\n        // create the stochastics plugin and build a dimension with 5 seed\n        // values\n        WellState wellState = WellState.builder().setSeed(463390897335624435L).build();\n        StochasticsPluginData stochasticsPluginData = StochasticsPluginData.builder().setMainRNGState(wellState)\n                .build();\n        Plugin stochasticsPlugin = StochasticsPlugin.getStochasticsPlugin(stochasticsPluginData);\n\n        Dimension stochasticsDimension = getStochasticsDimension(5, 8265427588292179209L);\n\n        // create the vaccine and model plugins\n        Plugin vaccinePlugin = VaccinePlugin.getVaccinePlugin();\n        Plugin modelPlugin = ModelPlugin.getModelPlugin();\n\n        Experiment.builder()//\n                .addPlugin(modelPlugin)//\n                .addPlugin(peoplePlugin)//\n                .addPlugin(stochasticsPlugin)//\n                .addPlugin(vaccinePlugin)//\n                .addExperimentContextConsumer(nioReportItemHandler)//\n                .addDimension(stochasticsDimension)//\n                .build()//\n                .execute();//\n    }\n\n\n\n\nCode Block 7.3: The stochastics dimension contains levels for each replication value. Note that the generation of the random seed values occurs outside of the lambda code.\nprivate static Dimension getStochasticsDimension(int replicationCount, long seed) {\n    FunctionalDimension.Builder builder = FunctionalDimension.builder();//\n\n    RandomGenerator randomGenerator = RandomGeneratorProvider.getRandomGenerator(seed);\n\n    List<Long> seedValues = new ArrayList<>();\n    for (int i = 0; i < replicationCount; i++) {\n        seedValues.add(randomGenerator.nextLong());\n    }\n\n    IntStream.range(0, seedValues.size()).forEach((i) -> {\n        builder.addLevel((context) -> {\n            StochasticsPluginData.Builder stochasticsPluginDataBuilder = context\n                    .getPluginDataBuilder(StochasticsPluginData.Builder.class);\n            long seedValue = seedValues.get(i);\n            WellState wellState = WellState.builder().setSeed(seedValue).build();\n            stochasticsPluginDataBuilder.setMainRNGState(wellState);\n\n            ArrayList<String> result = new ArrayList<>();\n            result.add(Integer.toString(i));\n            result.add(Long.toString(seedValue) + \"L\");\n\n            return result;\n        });//\n    });\n\n    builder.addMetaDatum(\"seed_index\");//\n    builder.addMetaDatum(\"seed_value\");//\n\n    return builder.build();\n}\n\n\nThere are two actors provided by the model plugin. The first is the PopulationManager (Code Block 7.4) that upon its initialization plans 100 future actions to randomly remove (10% chance) or add (90% chance) people to the simulation. For people who are added, an initial vaccination count is included in the request to add the person so that the vaccine data manager can set the proper count.\n\n\nCode Block 7.4: The population manager schedules 100 randomized actions to either add or remove people.\npublic void init(ActorContext actorContext) {\n    StochasticsDataManager stochasticsDataManager = actorContext.getDataManager(StochasticsDataManager.class);\n    RandomGenerator randomGenerator = stochasticsDataManager.getRandomGenerator();\n    double planTime = randomGenerator.nextDouble();\n    for (int i = 0; i < 100; i++) {\n        actorContext.addPlan((c) -> {\n            PeopleDataManager peopleDataManager = c.getDataManager(PeopleDataManager.class);\n            if (randomGenerator.nextDouble() < 0.1) {\n                List<PersonId> people = peopleDataManager.getPeople();\n                if (!people.isEmpty()) {\n                    PersonId personId = people.get(randomGenerator.nextInt(people.size()));\n                    peopleDataManager.removePerson(personId);\n                }\n            } else {\n                int intialVaccineCount = randomGenerator.nextInt(3);\n                VaccineInitialization vaccineInitialization = new VaccineInitialization(intialVaccineCount);\n                PersonConstructionData personConstructionData = PersonConstructionData.builder()//\n                        .add(vaccineInitialization)//\n                        .build();\n                peopleDataManager.addPerson(personConstructionData);\n            }\n        }, planTime);\n        planTime += randomGenerator.nextDouble();\n    }\n}\n\n\nCode Block 7.5 shows the second actor, the Vaccinator. It plans 300 vaccination actions over a period of approximately 100 days, selecting a random person to vaccinate each time. There is no limit to the number of vaccinations a person can have and we would expect that some people will have a relatively high number of vaccinations in the vaccine report.\n\n\nCode Block 7.5: The vaccinator administers 300 vaccine doses over 100 days.\npublic void init(ActorContext actorContext) {\n    StochasticsDataManager stochasticsDataManager = actorContext.getDataManager(StochasticsDataManager.class);\n    RandomGenerator randomGenerator = stochasticsDataManager.getRandomGenerator();\n    double planTime = randomGenerator.nextDouble();\n    for (int i = 0; i < 300; i++) {\n        actorContext.addPlan((c) -> {\n            PeopleDataManager peopleDataManager = c.getDataManager(PeopleDataManager.class);\n            VaccinationDataManager vaccinationDataManager = c.getDataManager(VaccinationDataManager.class);\n            List<PersonId> people = peopleDataManager.getPeople();\n            if (!people.isEmpty()) {\n                PersonId personId = people.get(randomGenerator.nextInt(people.size()));\n                vaccinationDataManager.vaccinatePerson(personId);\n            }\n        }, planTime);\n        planTime += randomGenerator.nextDouble() / 3;\n    }\n}"
  },
  {
    "objectID": "ch07-PeoplePlugin.html#interacting-with-the-addition-and-removal-events",
    "href": "ch07-PeoplePlugin.html#interacting-with-the-addition-and-removal-events",
    "title": "7  People Plugin",
    "section": "7.6 Interacting with the addition and removal events",
    "text": "7.6 Interacting with the addition and removal events\nThe remaining code blocks will focus on the handling of the four person addition and removal events in the vaccine data manager and the population trace report. The vaccine report is periodic and does not subscribe to any events and is left for the reader to examine.\nFollowing the general conventions above, the vaccine data manager subscribes to the PersonRemovalEvent and the PersonImminentAdditionEvent during its initialization in Code Block 7.6.\n\n\nCode Block 7.6: The vaccination data manager initializes by recording initial vaccine counts for each person and subscribing to person addition, person removal and person vaccination events.\npublic void init(DataManagerContext dataManagerContext) {\n    super.init(dataManagerContext);\n    dataManagerContext.subscribe(PersonRemovalEvent.class, this::handlePersonRemovalEvent);\n    dataManagerContext.subscribe(PersonImminentAdditionEvent.class, this::handlePersonImminentAdditionEvent);\n    personDataManager = dataManagerContext.getDataManager(PeopleDataManager.class);\n    this.dataManagerContext = dataManagerContext;\n    for (PersonId personId : personDataManager.getPeople()) {\n        vaccinationCounts.put(personId, new MutableInteger());\n    }\n    dataManagerContext.subscribe(VaccinationMutationEvent.class, this::handleVaccinationMutationEvent);\n}\n\n\nThe vaccine data manager uses a simple map from person id to a counter to track the number of vaccinations for each person:\n\n\nCode Block 7.7: The vaccination data manager uses a simple map from person id to a counter to track the number of vaccinations for each person.\nprivate Map<PersonId, MutableInteger> vaccinationCounts = new LinkedHashMap<>();\n\n\nThe subscriptions above refer to the local methods of the vaccine data manager in Code Block 7.8. Handling the removal of a person is simple; the person id dropped from the map. Handling the addition requires that the manager try to locate a VaccinationInitialization object (which is just a wrapper around and integer count) contained in the construction. If the VaccinationInitialization is present, then the manager further validates the count is not negative.\n\n\nCode Block 7.8: The vaccination manager removes people from its count tracking as needed. Newly added people may enter into the simulation with some vaccinations.\n    private void handlePersonRemovalEvent(DataManagerContext dataManagerContext,\n            PersonRemovalEvent personRemovalEvent) {\n        PersonId personId = personRemovalEvent.personId();\n        vaccinationCounts.remove(personId);\n    }\n\n    private void handlePersonImminentAdditionEvent(DataManagerContext dataManagerContext,\n            PersonImminentAdditionEvent personImminentAdditionEvent) {\n        PersonId personId = personImminentAdditionEvent.personId();\n        validateNewPersonId(personId);\n        MutableInteger mutableInteger = new MutableInteger();\n        vaccinationCounts.put(personId, mutableInteger);\n        Optional<VaccineInitialization> optional = personImminentAdditionEvent//\n                .personConstructionData()//\n                .getValue(VaccineInitialization.class);\n        if (optional.isPresent()) {\n            VaccineInitialization vaccineInitialization = optional.get();\n            int vaccineCount = vaccineInitialization.getVaccineCount();\n            validateInitialVaccineCount(vaccineCount);\n            mutableInteger.setValue(vaccineCount);\n        }\n    }"
  },
  {
    "objectID": "ch07-PeoplePlugin.html#inspecting-the-output",
    "href": "ch07-PeoplePlugin.html#inspecting-the-output",
    "title": "7  People Plugin",
    "section": "7.7 Inspecting the output",
    "text": "7.7 Inspecting the output\nFigure 7.1 shows the population trace report spanning the five scenarios and 500 additions and removals of people. In Figure 7.2 we have the vaccination report showing the number of people having from 0 to 6+ vaccinations over each day of the simulation across the five scenarios. As expected, the number of people having six or more vaccinations starts out at zero and monotonically increases as the days progress.\n\n\n\nFigure 7.1: An excerpt of the population trace report.\n\n\n\n\n\n\nscenario\n\n\nseed_index\n\n\nseed_value\n\n\ntime\n\n\npersonId\n\n\naction\n\n\n\n\n\n\n0\n\n\n0\n\n\n1126862960420803077L\n\n\n0.0000000\n\n\n1\n\n\nADDITION\n\n\n\n\n0\n\n\n0\n\n\n1126862960420803077L\n\n\n0.0000000\n\n\n3\n\n\nADDITION\n\n\n\n\n0\n\n\n0\n\n\n1126862960420803077L\n\n\n0.0000000\n\n\n5\n\n\nADDITION\n\n\n\n\n0\n\n\n0\n\n\n1126862960420803077L\n\n\n0.0000000\n\n\n7\n\n\nADDITION\n\n\n\n\n0\n\n\n0\n\n\n1126862960420803077L\n\n\n0.0000000\n\n\n9\n\n\nADDITION\n\n\n\n\n0\n\n\n0\n\n\n1126862960420803077L\n\n\n0.0000000\n\n\n11\n\n\nADDITION\n\n\n\n\n0\n\n\n0\n\n\n1126862960420803077L\n\n\n0.0000000\n\n\n13\n\n\nADDITION\n\n\n\n\n0\n\n\n0\n\n\n1126862960420803077L\n\n\n0.0000000\n\n\n15\n\n\nADDITION\n\n\n\n\n0\n\n\n0\n\n\n1126862960420803077L\n\n\n0.0000000\n\n\n17\n\n\nADDITION\n\n\n\n\n0\n\n\n0\n\n\n1126862960420803077L\n\n\n0.0000000\n\n\n19\n\n\nADDITION\n\n\n\n\n0\n\n\n0\n\n\n1126862960420803077L\n\n\n0.8335755\n\n\n19\n\n\nREMOVAL\n\n\n\n\n0\n\n\n0\n\n\n1126862960420803077L\n\n\n1.2826070\n\n\n20\n\n\nADDITION\n\n\n\n\n0\n\n\n0\n\n\n1126862960420803077L\n\n\n1.6263299\n\n\n21\n\n\nADDITION\n\n\n\n\n…\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\n\n\n1\n\n\n-4486033808643580070L\n\n\n0.0000000\n\n\n17\n\n\nADDITION\n\n\n\n\n1\n\n\n1\n\n\n-4486033808643580070L\n\n\n0.0000000\n\n\n19\n\n\nADDITION\n\n\n\n\n1\n\n\n1\n\n\n-4486033808643580070L\n\n\n0.0667491\n\n\n20\n\n\nADDITION\n\n\n\n\n1\n\n\n1\n\n\n-4486033808643580070L\n\n\n0.9322293\n\n\n21\n\n\nADDITION\n\n\n\n\n1\n\n\n1\n\n\n-4486033808643580070L\n\n\n1.6514183\n\n\n22\n\n\nADDITION\n\n\n\n\n1\n\n\n1\n\n\n-4486033808643580070L\n\n\n2.1177839\n\n\n23\n\n\nADDITION\n\n\n\n\n1\n\n\n1\n\n\n-4486033808643580070L\n\n\n2.2623884\n\n\n24\n\n\nADDITION\n\n\n\n\n1\n\n\n1\n\n\n-4486033808643580070L\n\n\n2.4082708\n\n\n25\n\n\nADDITION\n\n\n\n\n1\n\n\n1\n\n\n-4486033808643580070L\n\n\n2.8132398\n\n\n26\n\n\nADDITION\n\n\n\n\n1\n\n\n1\n\n\n-4486033808643580070L\n\n\n2.9103862\n\n\n27\n\n\nADDITION\n\n\n\n\n1\n\n\n1\n\n\n-4486033808643580070L\n\n\n3.1314042\n\n\n28\n\n\nADDITION\n\n\n\n\n1\n\n\n1\n\n\n-4486033808643580070L\n\n\n3.9782907\n\n\n29\n\n\nADDITION\n\n\n\n\n1\n\n\n1\n\n\n-4486033808643580070L\n\n\n4.8481078\n\n\n30\n\n\nADDITION\n\n\n\n\n1\n\n\n1\n\n\n-4486033808643580070L\n\n\n5.7753568\n\n\n31\n\n\nADDITION\n\n\n\n\n1\n\n\n1\n\n\n-4486033808643580070L\n\n\n6.0714214\n\n\n32\n\n\nADDITION\n\n\n\n\n1\n\n\n1\n\n\n-4486033808643580070L\n\n\n6.4493810\n\n\n33\n\n\nADDITION\n\n\n\n\n…\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4\n\n\n4\n\n\n2435395143614485495L\n\n\n44.8710482\n\n\n100\n\n\nADDITION\n\n\n\n\n4\n\n\n4\n\n\n2435395143614485495L\n\n\n45.0533288\n\n\n101\n\n\nADDITION\n\n\n\n\n4\n\n\n4\n\n\n2435395143614485495L\n\n\n45.1289192\n\n\n102\n\n\nADDITION\n\n\n\n\n4\n\n\n4\n\n\n2435395143614485495L\n\n\n45.5197380\n\n\n103\n\n\nADDITION\n\n\n\n\n4\n\n\n4\n\n\n2435395143614485495L\n\n\n45.8369307\n\n\n104\n\n\nADDITION\n\n\n\n\n4\n\n\n4\n\n\n2435395143614485495L\n\n\n46.2957569\n\n\n105\n\n\nADDITION\n\n\n\n\n4\n\n\n4\n\n\n2435395143614485495L\n\n\n46.8744186\n\n\n106\n\n\nADDITION\n\n\n\n\n4\n\n\n4\n\n\n2435395143614485495L\n\n\n47.3473702\n\n\n107\n\n\nADDITION\n\n\n\n\n4\n\n\n4\n\n\n2435395143614485495L\n\n\n48.3166466\n\n\n108\n\n\nADDITION\n\n\n\n\n4\n\n\n4\n\n\n2435395143614485495L\n\n\n49.2053410\n\n\n109\n\n\nADDITION\n\n\n\n\n4\n\n\n4\n\n\n2435395143614485495L\n\n\n49.2524537\n\n\n110\n\n\nADDITION\n\n\n\n\n4\n\n\n4\n\n\n2435395143614485495L\n\n\n49.5378229\n\n\n111\n\n\nADDITION\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 7.2: An excerpt of the vaccination report.\n\n\n\n\n\n\nscenario\n\n\nseed_index\n\n\nseed_value\n\n\nday\n\n\ncount_0\n\n\ncount_1\n\n\ncount_2\n\n\ncount_3\n\n\ncount_4\n\n\ncount_5\n\n\ncount_6+\n\n\n\n\n\n\n0\n\n\n0\n\n\n1126862960420803077L\n\n\n0\n\n\n10\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n0\n\n\n0\n\n\n1126862960420803077L\n\n\n1\n\n\n7\n\n\n2\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n0\n\n\n0\n\n\n1126862960420803077L\n\n\n2\n\n\n4\n\n\n5\n\n\n2\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n0\n\n\n0\n\n\n1126862960420803077L\n\n\n3\n\n\n2\n\n\n3\n\n\n8\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n0\n\n\n0\n\n\n1126862960420803077L\n\n\n4\n\n\n1\n\n\n2\n\n\n10\n\n\n0\n\n\n1\n\n\n0\n\n\n0\n\n\n\n\n0\n\n\n0\n\n\n1126862960420803077L\n\n\n5\n\n\n2\n\n\n3\n\n\n6\n\n\n3\n\n\n3\n\n\n0\n\n\n0\n\n\n\n\n0\n\n\n0\n\n\n1126862960420803077L\n\n\n6\n\n\n1\n\n\n5\n\n\n5\n\n\n3\n\n\n2\n\n\n2\n\n\n0\n\n\n\n\n0\n\n\n0\n\n\n1126862960420803077L\n\n\n7\n\n\n0\n\n\n7\n\n\n4\n\n\n4\n\n\n2\n\n\n3\n\n\n0\n\n\n\n\n0\n\n\n0\n\n\n1126862960420803077L\n\n\n8\n\n\n0\n\n\n7\n\n\n6\n\n\n5\n\n\n2\n\n\n2\n\n\n1\n\n\n\n\n…\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n0\n\n\n1126862960420803077L\n\n\n52\n\n\n6\n\n\n13\n\n\n13\n\n\n7\n\n\n10\n\n\n9\n\n\n22\n\n\n\n\n0\n\n\n0\n\n\n1126862960420803077L\n\n\n53\n\n\n7\n\n\n13\n\n\n15\n\n\n7\n\n\n10\n\n\n9\n\n\n22\n\n\n\n\n0\n\n\n0\n\n\n1126862960420803077L\n\n\n54\n\n\n7\n\n\n13\n\n\n16\n\n\n7\n\n\n10\n\n\n9\n\n\n22\n\n\n\n\n1\n\n\n1\n\n\n-4486033808643580070L\n\n\n0\n\n\n10\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n1\n\n\n1\n\n\n-4486033808643580070L\n\n\n1\n\n\n9\n\n\n3\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n1\n\n\n1\n\n\n-4486033808643580070L\n\n\n2\n\n\n5\n\n\n6\n\n\n2\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n1\n\n\n1\n\n\n-4486033808643580070L\n\n\n3\n\n\n5\n\n\n8\n\n\n4\n\n\n1\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n1\n\n\n1\n\n\n-4486033808643580070L\n\n\n4\n\n\n5\n\n\n6\n\n\n5\n\n\n3\n\n\n1\n\n\n0\n\n\n0\n\n\n\n\n1\n\n\n1\n\n\n-4486033808643580070L\n\n\n5\n\n\n4\n\n\n6\n\n\n6\n\n\n2\n\n\n3\n\n\n0\n\n\n0\n\n\n\n\n1\n\n\n1\n\n\n-4486033808643580070L\n\n\n6\n\n\n2\n\n\n6\n\n\n7\n\n\n3\n\n\n4\n\n\n0\n\n\n0\n\n\n\n\n1\n\n\n1\n\n\n-4486033808643580070L\n\n\n7\n\n\n2\n\n\n4\n\n\n11\n\n\n4\n\n\n4\n\n\n0\n\n\n0\n\n\n\n\n…\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3\n\n\n3\n\n\n-821383327301461075L\n\n\n42\n\n\n5\n\n\n13\n\n\n15\n\n\n9\n\n\n8\n\n\n10\n\n\n15\n\n\n\n\n3\n\n\n3\n\n\n-821383327301461075L\n\n\n43\n\n\n5\n\n\n13\n\n\n15\n\n\n9\n\n\n8\n\n\n11\n\n\n15\n\n\n\n\n3\n\n\n3\n\n\n-821383327301461075L\n\n\n44\n\n\n6\n\n\n12\n\n\n15\n\n\n10\n\n\n8\n\n\n9\n\n\n17\n\n\n\n\n3\n\n\n3\n\n\n-821383327301461075L\n\n\n45\n\n\n6\n\n\n13\n\n\n15\n\n\n9\n\n\n8\n\n\n7\n\n\n19\n\n\n\n\n3\n\n\n3\n\n\n-821383327301461075L\n\n\n46\n\n\n6\n\n\n13\n\n\n15\n\n\n8\n\n\n8\n\n\n7\n\n\n20\n\n\n\n\n3\n\n\n3\n\n\n-821383327301461075L\n\n\n47\n\n\n6\n\n\n14\n\n\n17\n\n\n5\n\n\n11\n\n\n6\n\n\n21\n\n\n\n\n3\n\n\n3\n\n\n-821383327301461075L\n\n\n48\n\n\n5\n\n\n14\n\n\n17\n\n\n6\n\n\n10\n\n\n5\n\n\n22\n\n\n\n\n3\n\n\n3\n\n\n-821383327301461075L\n\n\n49\n\n\n5\n\n\n13\n\n\n18\n\n\n7\n\n\n9\n\n\n6\n\n\n22\n\n\n\n\n…\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4\n\n\n4\n\n\n2435395143614485495L\n\n\n42\n\n\n11\n\n\n12\n\n\n11\n\n\n10\n\n\n12\n\n\n7\n\n\n19\n\n\n\n\n4\n\n\n4\n\n\n2435395143614485495L\n\n\n43\n\n\n9\n\n\n13\n\n\n12\n\n\n9\n\n\n11\n\n\n8\n\n\n20\n\n\n\n\n4\n\n\n4\n\n\n2435395143614485495L\n\n\n44\n\n\n7\n\n\n14\n\n\n11\n\n\n10\n\n\n10\n\n\n8\n\n\n21\n\n\n\n\n4\n\n\n4\n\n\n2435395143614485495L\n\n\n45\n\n\n7\n\n\n16\n\n\n10\n\n\n11\n\n\n9\n\n\n7\n\n\n23\n\n\n\n\n4\n\n\n4\n\n\n2435395143614485495L\n\n\n46\n\n\n7\n\n\n16\n\n\n13\n\n\n10\n\n\n11\n\n\n6\n\n\n24\n\n\n\n\n4\n\n\n4\n\n\n2435395143614485495L\n\n\n47\n\n\n8\n\n\n14\n\n\n15\n\n\n10\n\n\n11\n\n\n7\n\n\n24\n\n\n\n\n4\n\n\n4\n\n\n2435395143614485495L\n\n\n48\n\n\n9\n\n\n13\n\n\n15\n\n\n11\n\n\n11\n\n\n7\n\n\n24\n\n\n\n\n4\n\n\n4\n\n\n2435395143614485495L\n\n\n49\n\n\n9\n\n\n13\n\n\n15\n\n\n12\n\n\n11\n\n\n7\n\n\n24\n\n\n\n\n4\n\n\n4\n\n\n2435395143614485495L\n\n\n50\n\n\n12\n\n\n13\n\n\n15\n\n\n12\n\n\n11\n\n\n7\n\n\n24"
  },
  {
    "objectID": "ch08-RegionsPlugin.html#plugin-data-initialization",
    "href": "ch08-RegionsPlugin.html#plugin-data-initialization",
    "title": "8  Regions Plugin",
    "section": "8.1 Plugin Data Initialization",
    "text": "8.1 Plugin Data Initialization\nThe plugin is initialized using a RegionsPluginData object that collects person to region assignments and region property values."
  },
  {
    "objectID": "ch08-RegionsPlugin.html#plugin-behavior",
    "href": "ch08-RegionsPlugin.html#plugin-behavior",
    "title": "8  Regions Plugin",
    "section": "8.2 Plugin Behavior",
    "text": "8.2 Plugin Behavior\nThe plugin adds a single data manager to the simulation as an instance of the RegionsDataManager that is initialized with the RegionsPluginData."
  },
  {
    "objectID": "ch08-RegionsPlugin.html#data-manager",
    "href": "ch08-RegionsPlugin.html#data-manager",
    "title": "8  Regions Plugin",
    "section": "8.3 Data Manager",
    "text": "8.3 Data Manager\nThe data manager controls regions, their properties and the assignment of people to those regions. The data manager provides public methods that:\n\nAdd a region\nDefine a region property\nSet a region property value\nMove a person from one region to another\nAnswer various questions about:\n\nPerson membership in regions\nRegion property values\n\n\nThe data manager also produces observable events:\n\nPersonRegionUpdateEvent – when a person is moved from one region to another\nRegionAdditionEvent – when a region is added to the simulation\nRegionPropertyDefintionEvent – when a new region property is defined\nRegionPropertyUpdateEvent – when a region property value is assigned"
  },
  {
    "objectID": "ch08-RegionsPlugin.html#example-code-lesson-15",
    "href": "ch08-RegionsPlugin.html#example-code-lesson-15",
    "title": "8  Regions Plugin",
    "section": "8.4 Example Code (Lesson 15)",
    "text": "8.4 Example Code (Lesson 15)\nExample_15.java shows the use of the regions plugin. In it we will examine\n\nThe initialization of the regions plugin\nThe movement of people between regions\nThe dynamic addition of regions\nThe dynamic addition of region properties\nThe update of region property values\n\nThe example includes five plugins:\n\nRegions Plugin– (GCM core plugin) used to manage regions, their properties and person membership in regions\nPeople plugin – (GCM core plugin) used to manage people\nStochastics plugin – (GCM core plugin) used to generate random numbers used in various decisions\nModel plugin – (local plugin) used to introduce three actors that will:\n\nMove people between regions\nCreate new regions\nVaccinate people, reacting to changes in region properties\n\nVaccine plugin – (local plugin) used to track vaccinations for each person\n\nThe example’s main method starts in Code Block 8.1 by creating an instance of the example class rather than building the experiment directly since this example is somewhat more complex than previous examples.\n\n\nCode Block 8.1: Executing example 15 with an output directory.\npublic static void main(String[] args) throws IOException {\n    if (args.length == 0) {\n        throw new RuntimeException(\"One output directory argument is required\");\n    }\n    Path outputDirectory = Paths.get(args[0]);\n    if (!Files.exists(outputDirectory)) {\n        Files.createDirectory(outputDirectory);\n    } else {\n        if (!Files.isDirectory(outputDirectory)) {\n            throw new IOException(\"Provided path is not a directory\");\n        }\n    }\n\n    new Example_15(outputDirectory).execute();\n}\n\n\nThe execution method first gathers together the five plugins in Code Block 8.2:\n\n\nCode Block 8.2: The various plugins are gathered from their initial data.\nprivate void execute() {\n    /*\n         * Create person ids and region ids that are shared across the plugins\n         */\n    initializePeopleAndRegions();\n\n    /*\n         * Create the reports\n         */\n\n    NIOReportItemHandler nioReportItemHandler = getNIOReportItemHandler();\n\n    /*\n         * Create the people plugin filled with 1000 people\n         */\n    Plugin peoplePlugin = getPeoplePlugin();\n\n    /*\n         * Create the region plugin 5 regions, each having a lat and lon and assign the\n         * people to random regions.\n         * \n         */\n    Plugin regionsPlugin = getRegionsPlugin();\n\n    /*\n         * create the stochastics plugin and build a dimension with 5 seed values\n         */\n    Plugin stochasticsPlugin = getStochasticsPlugin();\n    Dimension stochasticsDimension = getStochasticsDimension(5, randomGenerator.nextLong());\n\n    /*\n         * Create the vaccine and model plugins\n         */\n    Plugin vaccinePlugin = VaccinePlugin.getVaccinePlugin();\n\n    Plugin modelPlugin = ModelPlugin.getModelPlugin();\n\n\nThe first action is to create 1000 people and 5 regions that will be used in the creation of both the people plugin and the regions plugin.\n\n\nCode Block 8.3: Lists of initial people and regions are created and will be used to initialize the various plugins.\nprivate void initializePeopleAndRegions() {\n    for (int i = 0; i < 1000; i++) {\n        initialPeople.add(new PersonId(i));\n    }\n    for (int i = 0; i < 5; i++) {\n        initialRegions.add(new Region(i));\n    }\n}\n\n\nThe regions plugin defines a region id with a marker interface. Marker interfaces are used to differentiate arguments and reduce variable type ambiguities while not imposing any particular implementation on the modeler. Region ids might reasonably be implemented as integer based identifiers or as strings that represent place names. In this example we will implement the region ids with an integer based class, the Region (Code Block 8.4), which is a boiler-plate wrapper around an int id value.\n\n\nCode Block 8.4: The region id is implemented as a wrapper class of int.\npublic final class Region implements RegionId {\n\n    private final int id;\n\n    /**\n     * Constructs the region\n     * \n     * @throws ContractException\n     *                           <li>{@linkplain ModelError#NEGATIVE_REGION_ID}</li>\n     */\n    public Region(int id) {\n        if (id < 0) {\n            throw new ContractException(ModelError.NEGATIVE_REGION_ID);\n        }\n        this.id = id;\n    }\n\n    public int getValue() {\n        return id;\n    }\n\n    @Override\n    public int hashCode() {\n        return id;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof Region)) {\n            return false;\n        }\n        Region other = (Region) obj;\n        if (id != other.id) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Region_\" + id;\n    }\n}\n\n\nThe example contains three reports in Code Block 8.5:\n\nRegionPropertyReport - shows changes to region property values\nRegionTransferReport - shows movements of people between regions\nVaccinationReport - shows vaccinations of people\n\n\n\nCode Block 8.5: The region property, region transfer and vaccination reports are mapped to distinct file names.\nprivate NIOReportItemHandler getNIOReportItemHandler() {\n    return NIOReportItemHandler.builder()//\n            .addReport(ModelReportLabel.REGION_PROPERTY_REPORT, //\n                    outputDirectory.resolve(\"region_property_report.xls\"))//\n            .addReport(ModelReportLabel.REGION_TRANSFER_REPORT, //\n                    outputDirectory.resolve(\"region_transfer_report.xls\"))//\n            .addReport(ModelReportLabel.VACCINATION, //\n                    outputDirectory.resolve(\"vaccine_report.xls\"))//\n            .build();\n}\n\n\nThe people plugin, Code Block 8.6, is built from the 1000 people created earlier.\n\n\nCode Block 8.6: The people plugin is initialized with the starting populaiton.\nprivate Plugin getPeoplePlugin() {\n    PeoplePluginData.Builder peoplePluginDataBuilder = PeoplePluginData.builder();\n    for (PersonId personId : initialPeople) {\n        peoplePluginDataBuilder.addPersonRange(new PersonRange(personId.getValue(), personId.getValue()));\n    }\n    PeoplePluginData peoplePluginData = peoplePluginDataBuilder.build();\n    return PeoplePlugin.getPeoplePlugin(peoplePluginData);\n}\n\n\nCreating the regions plugin Code Block 8.7 is a bit more involved. First, the five regions created before are added to the plugin. Since the plugin requires that every person always have a region assignment, we assign a randomly selected region to each person. We define the LAT and LON properties to give the regions a geographic location. Notice that the definitions do not have default values since it does not make sense to say a region has a default position. This then will require that we assign specific latitude and longitude values for each region. Later on we will examine adding a new region property definition dynamically as the simulation is running.\n\n\nCode Block 8.7: The regions plugin is initialized with the starting regions and people, with each person assigned to a randomly selected region. The two region-based reports are also initialized and added to the region plugin’s data.\nprivate Plugin getRegionsPlugin() {\n    // create the region plugin with an initial five regions, each region\n    // having 200 people\n    RegionsPluginData.Builder regionsPluginDataBuilder = RegionsPluginData.builder();\n    for (Region region : initialRegions) {\n        regionsPluginDataBuilder.addRegion(region);\n    }\n\n    for (PersonId personId : initialPeople) {\n        Region region = initialRegions.get(randomGenerator.nextInt(initialRegions.size()));\n        regionsPluginDataBuilder.addPerson(personId, region);\n    }\n\n    PropertyDefinition propertyDefinition = PropertyDefinition.builder()//\n            .setType(Double.class)//\n            .setPropertyValueMutability(false)//\n            .build();\n    regionsPluginDataBuilder.defineRegionProperty(RegionProperty.LAT, propertyDefinition);\n    regionsPluginDataBuilder.defineRegionProperty(RegionProperty.LON, propertyDefinition);\n\n    for (Region region : initialRegions) {\n        regionsPluginDataBuilder.setRegionPropertyValue(region, RegionProperty.LAT,\n                randomGenerator.nextDouble() + 45.0);\n        regionsPluginDataBuilder.setRegionPropertyValue(region, RegionProperty.LON,\n                randomGenerator.nextDouble() + 128.0);\n    }\n\n    RegionsPluginData regionsPluginData = regionsPluginDataBuilder.build();\n\n    RegionPropertyReportPluginData regionPropertyReportPluginData = //\n            RegionPropertyReportPluginData.builder()//\n                    .setReportLabel(ModelReportLabel.REGION_PROPERTY_REPORT)//\n                    .build();\n\n    RegionTransferReportPluginData regionTransferReportPluginData = RegionTransferReportPluginData.builder()//\n            .setReportLabel(ModelReportLabel.REGION_TRANSFER_REPORT)//\n            .setReportPeriod(ReportPeriod.END_OF_SIMULATION)//\n            .build();//\n\n    return RegionsPlugin.builder()//\n            .setRegionsPluginData(regionsPluginData)//\n            .setRegionPropertyReportPluginData(regionPropertyReportPluginData)//\n            .setRegionTransferReportPluginData(regionTransferReportPluginData)//\n            .getRegionsPlugin();\n}\n\n\nAdding the stochastics plugin with a corresponding dimension that will create five scenarios proceeds in the usual way in Code Block 8.8:\n\n\nCode Block 8.8: The stochastics plugin is initialized with a random seed value. A dimension is added to add new seeds to the resulting scenarios.\nprivate Plugin getStochasticsPlugin() {\n\n    WellState wellState = WellState.builder().setSeed(randomGenerator.nextLong()).build();\n    StochasticsPluginData stochasticsPluginData = StochasticsPluginData.builder()//\n            .setMainRNGState(wellState).build();\n    return StochasticsPlugin.getStochasticsPlugin(stochasticsPluginData);\n}\n\nprivate Dimension getStochasticsDimension(int replicationCount, long seed) {\n    FunctionalDimension.Builder builder = FunctionalDimension.builder();//\n\n    RandomGenerator randomGenerator = RandomGeneratorProvider.getRandomGenerator(seed);\n\n    List<Long> seedValues = new ArrayList<>();\n    for (int i = 0; i < replicationCount; i++) {\n        seedValues.add(randomGenerator.nextLong());\n    }\n\n    IntStream.range(0, seedValues.size()).forEach((i) -> {\n        builder.addLevel((context) -> {\n            StochasticsPluginData.Builder stochasticsPluginDataBuilder = context\n                    .getPluginDataBuilder(StochasticsPluginData.Builder.class);\n            long seedValue = seedValues.get(i);\n            WellState wellState = WellState.builder().setSeed(seedValue).build();\n            stochasticsPluginDataBuilder.setMainRNGState(wellState);\n\n            ArrayList<String> result = new ArrayList<>();\n            result.add(Integer.toString(i));\n            result.add(Long.toString(seedValue) + \"L\");\n\n            return result;\n        });//\n    });\n\n    builder.addMetaDatum(\"seed index\");//\n    builder.addMetaDatum(\"seed value\");//\n\n    return builder.build();\n}\n\n\nFinally, we add the vaccine and model plugins. This will add the vaccine data manager as well as three previously mentioned actors that will be used to demonstrate the various capabilities of the regions plugin.\n\nPersonMover – used to move people between regions\nRegionCreator – used to create new regions during the simulation run\nVaccinator – used to vaccinate people, reacting to changes in region properties\n\nThe execute method finishes (Code Block 8.9) by constructing and executing the experiment:\n\n\nCode Block 8.9: The experiment is run with five scenarios, each using distinct random seed values.\nExperiment.builder()//\n        .addPlugin(modelPlugin)//\n        .addPlugin(regionsPlugin)//\n        .addPlugin(peoplePlugin)//\n        .addPlugin(stochasticsPlugin)//\n        .addPlugin(vaccinePlugin)//\n        .addExperimentContextConsumer(nioReportItemHandler)//\n        .addDimension(stochasticsDimension)//\n        .build()//\n        .execute();//"
  },
  {
    "objectID": "ch08-RegionsPlugin.html#the-actors",
    "href": "ch08-RegionsPlugin.html#the-actors",
    "title": "8  Regions Plugin",
    "section": "8.5 The actors",
    "text": "8.5 The actors\nWe will finish this chapter by reviewing the three actors of the model plugin and then examine the three reports.\nThe PersonMover actor, in Code Block 8.10 and Code Block 8.11, schedules 1000 random moves of a person from one region to another over the course of 100 days.\n\n\nCode Block 8.10: The person mover actor plans for 1000 movements of people over time.\npublic void init(ActorContext actorContext) {\n    for (int i = 0; i < 1000; i++) {\n        double planTime = ((double) i) * 0.1;\n        actorContext.addPlan(this::moveRandomPerson, planTime);\n    }\n}\n\n\nMoving the person requires that we use the stochastics plugin and the people plugin to select a random person. We next use the regions plugin to first select a random new region for the person and then move the person to that region.\n\n\nCode Block 8.11: The person mover actor attempts to move a randomly selected person from their current region to a new region.\nprivate void moveRandomPerson(ActorContext actorContext) {\n    StochasticsDataManager stochasticsDataManager = actorContext.getDataManager(StochasticsDataManager.class);\n    RandomGenerator randomGenerator = stochasticsDataManager.getRandomGenerator();\n    PeopleDataManager peopleDataManager = actorContext.getDataManager(PeopleDataManager.class);\n    RegionsDataManager regionsDataManager = actorContext.getDataManager(RegionsDataManager.class);\n\n    // pick a random person\n    List<PersonId> people = peopleDataManager.getPeople();\n    if (people.isEmpty()) {\n        return;\n    }\n    PersonId personId = people.get(randomGenerator.nextInt(people.size()));\n\n    // pick a new random new region for that person\n    List<RegionId> regionIds = new ArrayList<>(regionsDataManager.getRegionIds());\n    RegionId personRegion = regionsDataManager.getPersonRegion(personId);\n    regionIds.remove(personRegion);\n    if (regionIds.isEmpty()) {\n        return;\n    }\n    RegionId newPersonRegion = regionIds.get(randomGenerator.nextInt(regionIds.size()));\n\n    // assign the region to the person\n    regionsDataManager.setPersonRegion(personId, newPersonRegion);\n}\n\n\nThe RegionCreator actor, in Code Block 8.12 and Code Block 8.13, follows a similar pattern, scheduling the creation of five new regions over 101 days.\n\n\nCode Block 8.12: The region creator actor plans the addition of five new regions.\npublic void init(ActorContext actorContext) {\n    for (int i = 0; i < 5; i++) {\n        double planTime = 20 * i + 1;\n        actorContext.addPlan(this::addRegion, planTime);\n    }\n}\n\n\nWhen adding a region, we have to be aware that the region will have LAT and LON properties and that these properties were not defined with default values. Thus we must supply values for the region’s latitude and longitude as part of the RegionConstructionData object that is passed to the regions data manager. We will similarly assign a new random Boolean value for the VACCINE_PRIORITY property. The VACCINE_PRIORITY is a dynamically added property that is introduced later. Note that we first check for the existence of the property and only then set a value since setting such a value before the property is defined will result in a runtime exception.\n\n\n\n\n\n\nNote\n\n\n\nSuch considerations are unusual since properties are usually defined in the plugin initialization data or added very early in the simulation before any actors have initialized. We do so here for the purposes of demonstrating dynamic property definitions.\n\n\n\n\nCode Block 8.13: When the region creator actor adds a new region, it assigns a random lat-lon corrdinate and possibly assigns a vaccine priority status to the region.\nprivate void addRegion(ActorContext actorContext) {\n    RegionsDataManager regionsDataManager = actorContext.getDataManager(RegionsDataManager.class);\n    StochasticsDataManager stochasticsDataManager = actorContext.getDataManager(StochasticsDataManager.class);\n    RandomGenerator randomGenerator = stochasticsDataManager.getRandomGenerator();\n\n    Set<Region> regions = regionsDataManager.getRegionIds();\n    int maxRegionValue = -1;\n    for (Region region : regions) {\n        int value = region.getValue();\n        maxRegionValue = FastMath.max(value, maxRegionValue);\n    }\n    Region newRegion = new Region(maxRegionValue + 1);\n    Builder regionBuilder = RegionConstructionData.builder().setRegionId(newRegion);\n    regionBuilder.setRegionPropertyValue(RegionProperty.LAT, 35 + randomGenerator.nextDouble());\n    regionBuilder.setRegionPropertyValue(RegionProperty.LON, 128 + randomGenerator.nextDouble());\n\n    if (regionsDataManager.regionPropertyIdExists(RegionProperty.VACCINE_PRIORITY)) {\n        regionBuilder.setRegionPropertyValue(RegionProperty.VACCINE_PRIORITY, randomGenerator.nextBoolean());\n    }\n    RegionConstructionData regionConstructionData = regionBuilder.build();\n    regionsDataManager.addRegion(regionConstructionData);\n}\n\n\nThe Vaccinator actor is somewhat more complicated than the other actors. It initializes (Code Block 8.14) by storing references to various data managers for convenience and then plans 5000 vaccinations spread over 100 days. It also plans to add the VACCINE_PRIORITY property on day 50.\n\n\nCode Block 8.14: The vaccinator initializes by planning the vaccination of 5000 people carried out over approximately 50 days.\npublic void init(ActorContext actorContext) {\n    StochasticsDataManager stochasticsDataManager = actorContext.getDataManager(StochasticsDataManager.class);\n    randomGenerator = stochasticsDataManager.getRandomGenerator();\n    regionsDataManager = actorContext.getDataManager(RegionsDataManager.class);\n    vaccinationDataManager = actorContext.getDataManager(VaccinationDataManager.class);\n\n    double planTime = randomGenerator.nextDouble();\n    for (int i = 0; i < 5000; i++) {\n        actorContext.addPlan(this::vaccinateRandomPerson, planTime);\n        planTime += randomGenerator.nextDouble() * 0.02;\n    }\n\n    actorContext.addPlan(this::addVaccinePriorityPropertyToRegions, 50);\n}\n\n\nLet’s first look at the addition of the new region property on day 50 in Code Block 8.15. The new property is a Boolean value defaulted to false and indicates whether people should be chosen from regions randomly or by preferring people with the fewest vaccinations. Since the property has a default value, we do not have to set values for each region in the RegionPropertyDefinitionInitialization object that is passed to the regions data manager when creating the region. We do so anyway to demonstrate such value assignments. Once the new property is in place, the Vaccinator schedules the switching of the value for random regions once per day for the next 50 days.\n\n\nCode Block 8.15: On day 50, the vaccinator defines the Boolean VACCINE PRIORITY property and assigns randomized values to the existing regions. It then plans for updates to 50 regional vaccine priority property values over 50 days.\nprivate void addVaccinePriorityPropertyToRegions(ActorContext actorContext) {\n\n    PropertyDefinition propertyDefinition = //\n            PropertyDefinition.builder()//\n                    .setType(Boolean.class)//\n                    .setDefaultValue(false)//\n                    .build();\n\n    RegionPropertyDefinitionInitialization.Builder defBuilder = RegionPropertyDefinitionInitialization.builder()//\n            .setPropertyDefinition(propertyDefinition)//\n            .setRegionPropertyId(RegionProperty.VACCINE_PRIORITY);\n\n    for (RegionId regionId : regionsDataManager.getRegionIds()) {\n        defBuilder.addPropertyValue(regionId, randomGenerator.nextBoolean());\n    }\n\n    RegionPropertyDefinitionInitialization regionPropertyDefinitionInitialization = defBuilder.build();\n    regionsDataManager.defineRegionProperty(regionPropertyDefinitionInitialization);\n\n    for (int i = 0; i < 50; i++) {\n        double planTime = actorContext.getTime() + i;\n        actorContext.addPlan(this::alterVaccinePriorityPropertyOnRandomRegion, planTime);\n    }\n}\n\n\nIn Code Block 8.16 the Vaccinator performs this value switching:\n\n\nCode Block 8.16: Toggling the vaccine priority for a randomly selected region.\nprivate void alterVaccinePriorityPropertyOnRandomRegion(ActorContext actorContext) {\n    List<RegionId> regionids = new ArrayList<>(regionsDataManager.getRegionIds());\n    if (regionids.isEmpty()) {\n        return;\n    }\n    RegionId regionId = regionids.get(randomGenerator.nextInt(regionids.size()));\n    Boolean vaccinePriority = regionsDataManager.getRegionPropertyValue(regionId, RegionProperty.VACCINE_PRIORITY);\n    regionsDataManager.setRegionPropertyValue(regionId, RegionProperty.VACCINE_PRIORITY, !vaccinePriority);\n}\n\n\nThe Vaccinator vaccinates people at random (Code Block 8.17) by first selecting a random region and then selecting a random person in that region. The selection of the person is subject to the presence of the VACCINE_PRIORITY property and whether the value of the property is true for the selected region. If the priority selection is being used, then a first pass through the people in the region establishes the lowest number of vaccines received by any person. A second pass through the same people now selects only those having this number of vaccinations. Finally, a person is selected at random from the eligible people.\n\n\nCode Block 8.17: The vaccinator selects a person at random from the population to vaccinate. If the region is using the VACCINE_PRIORITY policy, then those with the least number of vaccinations have preference.\nprivate void vaccinateRandomPerson(ActorContext actorContext) {\n\n    List<RegionId> regionIds = new ArrayList<>(regionsDataManager.getRegionIds());\n    if (regionIds.isEmpty()) {\n        return;\n    }\n    RegionId regionId = regionIds.get(randomGenerator.nextInt(regionIds.size()));\n    List<PersonId> peopleInRegion = regionsDataManager.getPeopleInRegion(regionId);\n\n    Boolean prioritizePeople = false;\n    boolean vaccinePriorityPropertyExists = regionsDataManager\n            .regionPropertyIdExists(RegionProperty.VACCINE_PRIORITY);\n    if (vaccinePriorityPropertyExists) {\n        prioritizePeople = regionsDataManager.getRegionPropertyValue(regionId, RegionProperty.VACCINE_PRIORITY);\n    }\n\n    PersonId selectedPersonId = null;\n    if (prioritizePeople) {\n        int minVaccinationCount = Integer.MAX_VALUE;\n        for (PersonId personId : peopleInRegion) {\n            int personVaccinationCount = vaccinationDataManager.getPersonVaccinationCount(personId);\n            if (personVaccinationCount < minVaccinationCount) {\n                minVaccinationCount = personVaccinationCount;\n            }\n        }\n        List<PersonId> eligiblePeople = new ArrayList<>();\n        for (PersonId personId : peopleInRegion) {\n            int personVaccinationCount = vaccinationDataManager.getPersonVaccinationCount(personId);\n            if (personVaccinationCount == minVaccinationCount) {\n                eligiblePeople.add(personId);\n            }\n        }\n        if (!eligiblePeople.isEmpty()) {\n            selectedPersonId = eligiblePeople.get(randomGenerator.nextInt(eligiblePeople.size()));\n        }\n    } else {\n        if (!peopleInRegion.isEmpty()) {\n            selectedPersonId = peopleInRegion.get(randomGenerator.nextInt(peopleInRegion.size()));\n        }\n    }\n\n    if (selectedPersonId != null) {\n        vaccinationDataManager.vaccinatePerson(selectedPersonId);\n    }\n}"
  },
  {
    "objectID": "ch08-RegionsPlugin.html#inspecting-the-output",
    "href": "ch08-RegionsPlugin.html#inspecting-the-output",
    "title": "8  Regions Plugin",
    "section": "8.6 Inspecting the output",
    "text": "8.6 Inspecting the output\nThe region transfer report shows the number of transfers of a person from one region to another across all days in the simulation. The rows where the source and destination regions are the same represent the addition of people at the start of the simulation and, as expected, the sum of such transfers equals to 1000. We also expect to see regions that were added beyond the original five regions and that transfers in and out of those regions should be reduced compared to the original regions since they start out with no people and come into the simulation only after day 50.\nno vaccinations during those periods.\n\n\n\nFigure 8.1: Excerpts from the region transfer report.\n\n\n\n\n\n\nscenario\n\n\nseed_index\n\n\nseed_value\n\n\nsource_region\n\n\ndestination_region\n\n\ntransfers\n\n\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\nRegion_2\n\n\nRegion_2\n\n\n215\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\nRegion_0\n\n\nRegion_0\n\n\n188\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\nRegion_3\n\n\nRegion_3\n\n\n208\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\nRegion_4\n\n\nRegion_4\n\n\n215\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\nRegion_1\n\n\nRegion_1\n\n\n174\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\nRegion_4\n\n\nRegion_3\n\n\n26\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\nRegion_4\n\n\nRegion_0\n\n\n36\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\nRegion_3\n\n\nRegion_4\n\n\n24\n\n\n\n\n…\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\n\n\n1\n\n\n-7320358285742045393L\n\n\nRegion_2\n\n\nRegion_2\n\n\n215\n\n\n\n\n1\n\n\n1\n\n\n-7320358285742045393L\n\n\nRegion_0\n\n\nRegion_0\n\n\n188\n\n\n\n\n1\n\n\n1\n\n\n-7320358285742045393L\n\n\nRegion_3\n\n\nRegion_3\n\n\n208\n\n\n\n\n1\n\n\n1\n\n\n-7320358285742045393L\n\n\nRegion_4\n\n\nRegion_4\n\n\n215\n\n\n\n\n1\n\n\n1\n\n\n-7320358285742045393L\n\n\nRegion_1\n\n\nRegion_1\n\n\n174\n\n\n\n\n…\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2\n\n\n2\n\n\n-4619948863677044400L\n\n\nRegion_3\n\n\nRegion_0\n\n\n26\n\n\n\n\n2\n\n\n2\n\n\n-4619948863677044400L\n\n\nRegion_3\n\n\nRegion_1\n\n\n33\n\n\n\n\n2\n\n\n2\n\n\n-4619948863677044400L\n\n\nRegion_0\n\n\nRegion_4\n\n\n22\n\n\n\n\n2\n\n\n2\n\n\n-4619948863677044400L\n\n\nRegion_1\n\n\nRegion_4\n\n\n29\n\n\n\n\n2\n\n\n2\n\n\n-4619948863677044400L\n\n\nRegion_4\n\n\nRegion_0\n\n\n32\n\n\n\n\n…\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4\n\n\n4\n\n\n-7584580254621783722L\n\n\nRegion_8\n\n\nRegion_4\n\n\n1\n\n\n\n\n4\n\n\n4\n\n\n-7584580254621783722L\n\n\nRegion_9\n\n\nRegion_1\n\n\n1\n\n\n\n\n4\n\n\n4\n\n\n-7584580254621783722L\n\n\nRegion_9\n\n\nRegion_0\n\n\n2\n\n\n\n\n4\n\n\n4\n\n\n-7584580254621783722L\n\n\nRegion_9\n\n\nRegion_6\n\n\n2\n\n\n\n\n\n\n\n\n\nIn the region property report (Figure 8.2) we see that the LAT and LON properties were set for the first five regions at the start of the simulation. Starting on day 1, new regions were added and each has an assigned LAT and LON value at that time. Beginning on day 50, all regions are assigned a VACCINE_PRIOITY value and assignments to that property continue daily for random regions.\n\n\n\nFigure 8.2: Excerpts from the region property report.\n\n\n\n\n\n\nscenario\n\n\nseed_index\n\n\nseed_value\n\n\ntime\n\n\nregion\n\n\nproperty\n\n\nvalue\n\n\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\n0.0\n\n\nRegion_0\n\n\nLAT\n\n\n45.08307901948476\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\n0.0\n\n\nRegion_0\n\n\nLON\n\n\n128.5497267736204\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\n0.0\n\n\nRegion_1\n\n\nLAT\n\n\n45.73317078392115\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\n0.0\n\n\nRegion_1\n\n\nLON\n\n\n128.98292164396958\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\n0.0\n\n\nRegion_2\n\n\nLAT\n\n\n45.74702447122078\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\n0.0\n\n\nRegion_2\n\n\nLON\n\n\n128.5118606592755\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\n0.0\n\n\nRegion_3\n\n\nLAT\n\n\n45.8303102139607\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\n0.0\n\n\nRegion_3\n\n\nLON\n\n\n128.55192626408567\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\n0.0\n\n\nRegion_4\n\n\nLAT\n\n\n45.59334365958997\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\n0.0\n\n\nRegion_4\n\n\nLON\n\n\n128.7915941303198\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\n1.0\n\n\nRegion_5\n\n\nLAT\n\n\n35.99754757587744\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\n1.0\n\n\nRegion_5\n\n\nLON\n\n\n128.2594279657217\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\n21.0\n\n\nRegion_6\n\n\nLAT\n\n\n35.84682720256188\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\n21.0\n\n\nRegion_6\n\n\nLON\n\n\n128.2211833000355\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\n41.0\n\n\nRegion_7\n\n\nLAT\n\n\n35.07267582475035\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\n41.0\n\n\nRegion_7\n\n\nLON\n\n\n128.37457313813837\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\n50.0\n\n\nRegion_0\n\n\nVACCINE_PRIORITY\n\n\nfalse\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\n50.0\n\n\nRegion_1\n\n\nVACCINE_PRIORITY\n\n\nfalse\n\n\n\n\n…\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4\n\n\n4\n\n\n-7584580254621783722L\n\n\n93.0\n\n\nRegion_2\n\n\nVACCINE_PRIORITY\n\n\nfalse\n\n\n\n\n4\n\n\n4\n\n\n-7584580254621783722L\n\n\n94.0\n\n\nRegion_1\n\n\nVACCINE_PRIORITY\n\n\ntrue\n\n\n\n\n4\n\n\n4\n\n\n-7584580254621783722L\n\n\n95.0\n\n\nRegion_2\n\n\nVACCINE_PRIORITY\n\n\ntrue\n\n\n\n\n4\n\n\n4\n\n\n-7584580254621783722L\n\n\n96.0\n\n\nRegion_7\n\n\nVACCINE_PRIORITY\n\n\ntrue\n\n\n\n\n4\n\n\n4\n\n\n-7584580254621783722L\n\n\n97.0\n\n\nRegion_0\n\n\nVACCINE_PRIORITY\n\n\nfalse\n\n\n\n\n4\n\n\n4\n\n\n-7584580254621783722L\n\n\n98.0\n\n\nRegion_1\n\n\nVACCINE_PRIORITY\n\n\nfalse\n\n\n\n\n4\n\n\n4\n\n\n-7584580254621783722L\n\n\n99.0\n\n\nRegion_0\n\n\nVACCINE_PRIORITY\n\n\ntrue\n\n\n\n\n\n\n\n\n\nFinally, the vaccine report shows the number of people having various vaccine counts at the end of each simulation. Although the priority policy was being used, most vaccinations were for randomly selected people so we expect a fairly wide distribution in those values.\n\n\n\nFigure 8.3: The vaccine report shows vaccine counts at the end of each simulation.\n\n\n\n\n\n\nscenario\n\n\nseed_index\n\n\nseed_value\n\n\ncount_0\n\n\ncount_1\n\n\ncount_2\n\n\ncount_3\n\n\ncount_4\n\n\ncount_5\n\n\ncount_6+\n\n\n\n\n\n\n0\n\n\n0\n\n\n-7834265884293137617L\n\n\n13\n\n\n67\n\n\n145\n\n\n168\n\n\n170\n\n\n148\n\n\n289\n\n\n\n\n1\n\n\n1\n\n\n-7320358285742045393L\n\n\n13\n\n\n63\n\n\n141\n\n\n181\n\n\n187\n\n\n133\n\n\n282\n\n\n\n\n2\n\n\n2\n\n\n-4619948863677044400L\n\n\n17\n\n\n53\n\n\n157\n\n\n196\n\n\n176\n\n\n140\n\n\n261\n\n\n\n\n3\n\n\n3\n\n\n3282202756261196294L\n\n\n10\n\n\n72\n\n\n159\n\n\n166\n\n\n163\n\n\n146\n\n\n284\n\n\n\n\n4\n\n\n4\n\n\n-7584580254621783722L\n\n\n4\n\n\n66\n\n\n153\n\n\n198\n\n\n163\n\n\n136\n\n\n280"
  },
  {
    "objectID": "ch09-PersonPropertiesPlugin.html#plugin-data-initialization",
    "href": "ch09-PersonPropertiesPlugin.html#plugin-data-initialization",
    "title": "9  Person Properties Plugin",
    "section": "9.1 Plugin Data Initialization",
    "text": "9.1 Plugin Data Initialization\nThe plugin is initialized using a PersonPropertiesPluginData object that collects person property definitions and person property value assignments for the initial population."
  },
  {
    "objectID": "ch09-PersonPropertiesPlugin.html#plugin-behavior",
    "href": "ch09-PersonPropertiesPlugin.html#plugin-behavior",
    "title": "9  Person Properties Plugin",
    "section": "9.2 Plugin Behavior",
    "text": "9.2 Plugin Behavior\nThe plugin adds a single data manager to the simulation as an instance of the PersonPropertiesDataManager that is initialized with the PersonPropertiesPluginData."
  },
  {
    "objectID": "ch09-PersonPropertiesPlugin.html#data-manager",
    "href": "ch09-PersonPropertiesPlugin.html#data-manager",
    "title": "9  Person Properties Plugin",
    "section": "9.3 Data Manager",
    "text": "9.3 Data Manager\nThe data manager manages person properties and stores their property values in a memory dense fashion that is transparent to the modeler. The data manager provides public methods that:\n\nDefine person properties\nSet person property values\nAnswer various questions about:\n\nThe value of a person property for particular people\nThe people associated with a particular property value\nThe existence and value of property definitions\n\n\nThe data manager also produces observable events:\n\nPersonPropertyUpdateEvent – when a person is assigned a person property value\nPersonPropertyDefintionEvent – when a new person property is defined"
  },
  {
    "objectID": "ch09-PersonPropertiesPlugin.html#example-code-lesson-16",
    "href": "ch09-PersonPropertiesPlugin.html#example-code-lesson-16",
    "title": "9  Person Properties Plugin",
    "section": "9.4 Example Code (Lesson 16)",
    "text": "9.4 Example Code (Lesson 16)\nExample_16.java shows the use of the person properties plugin. In it we will examine\n\nThe initialization of the person properties plugin\nThe assignment of values to individuals\nThe dynamic definition of person properties\n\nThe example includes six plugins:\n\nPeople plugin – (GCM core plugin) used to manage people\nPerson properties plugin– (GCM core plugin) used to decorate properties onto people\nGlobal properties plugin– (GCM core plugin) used to store policies and initial conditions affecting vaccination\nStochastics plugin – (GCM core plugin) used to generate random numbers used in various decisions\nRegions Plugin – (GCM core plugin) used to represent regions\nModel plugin – (local plugin) used to introduce three actors that will:\n\nLoad the population\nVaccinate people\nEducate people on the vaccine\n\n\nThe example’s main method starts in Code Block 9.1 by creating an instance of the example class rather than building the experiment directly since this example is somewhat more complex than previous examples. The population starts out being unvaccinated and some proportion of people initially refuse the vaccine. Attempts to both vaccinate and educate people are ongoing until a person is vaccinated. This will demonstrate the planning capability as well. If education is successful, the person is immediately vaccinated, demonstrating the cancellation of planning. At some point in the timeline, immunity will become discoverable during vaccine attempts and immune people will no longer pursue vaccination. The simulation is terminated at one year and output reports are then generated.\n\n\nCode Block 9.1: Executing example 16 with an output directory.\npublic static void main(String[] args) throws IOException {\n    if (args.length == 0) {\n        throw new RuntimeException(\"One output directory argument is required\");\n    }\n    Path outputPath = Paths.get(args[0]);\n    if (!Files.exists(outputPath)) {\n        Files.createDirectory(outputPath);\n    } else {\n        if (!Files.isDirectory(outputPath)) {\n            throw new IOException(\"Provided path is not a directory\");\n        }\n    }\n    new Example_16(outputPath).execute();\n}\n\n\nThe execution method first gathers together the six plugins in Code Block 9.2:\n\n\nCode Block 9.2: The various plugins are gathered from their initial data.\nprivate void execute() {\n\n    /*\n         * Create the global properties plugin\n         */\n    Plugin globalPropertiesPlugin = getGlobalPropertiesPlugin();\n\n    /*\n         * Create the reports\n         */\n\n    NIOReportItemHandler nioReportItemHandler = getNIOReportItemHandler();\n\n    /*\n         * Create the people plugin filled with 1000 people\n         */\n    Plugin peoplePlugin = getPeoplePlugin();\n\n    /*\n         * Create the region plugin 5 regions, each having a lat and lon and assign the\n         * people to random regions.\n         * \n         */\n    Plugin regionsPlugin = getRegionsPlugin();\n\n    // Create the person properties plugin\n    Plugin personPropertiesPlugin = getPersonPropertiesPlugin();\n\n    /*\n         * create the stochastics plugin\n         */\n    Plugin stochasticsPlugin = getStochasticsPlugin();\n\n    Plugin modelPlugin = ModelPlugin.getModelPlugin();\n\n\nThe first action is to generate the global properties plugin, (Code Block 9.3). All of the global properties are marked as immutable since they will not change over the course of the simulation:\n\nVACCINE_ATTEMPT_INTERVAL – The maximum time between attempts to vaccinate an unvaccinated person. Specific intervals are chosen using a uniform random time between zero and the maximum.\nEDUCATION_ATTEMPT_INTERVAL – The maximum time between attempts to educate an unvaccinated person who is currently refusing vaccination. Specific intervals are chosen using a uniform random time between zero and the maximum.\nVACCINE_REFUSAL_PROPBABILTY – The initial probability that a person will refuse vaccination. Used to initialize the person property REFUSES_VACCINE.\nEDUCATION_SUCCESS_RATE – The probability that an attempt to educate a person to accept vaccination will succeed.\nIMMUNITY_START_TIME – The time when immunity is detectable in people. Used to halt attempts at vaccination and to demonstrate the dynamic addition of the person property IS_IMMUNE.\nIMMUNITY_PROBABILITY – The probability that a person will be immune when the IS_IMMUNE person property is added.\nPOPULATION_SIZE – The number of people in the simulation.\nSIMULATION_DURATION – The maximum time (in days) that the simulation will execute.\n\n\n\nCode Block 9.3: The global properties plugin is initialized with several properties.\nprivate Plugin getGlobalPropertiesPlugin() {\n    GlobalPropertiesPluginData.Builder builder = GlobalPropertiesPluginData.builder();//\n\n    PropertyDefinition propertyDefinition = PropertyDefinition.builder()//\n            .setType(Double.class)//\n            .setDefaultValue(0.0)//\n            .setPropertyValueMutability(false)//\n            .build();\n\n    builder.defineGlobalProperty(GlobalProperty.IMMUNITY_START_TIME, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.VACCINE_ATTEMPT_INTERVAL, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.EDUCATION_ATTEMPT_INTERVAL, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.EDUCATION_SUCCESS_RATE, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.VACCINE_REFUSAL_PROBABILITY, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.IMMUNITY_PROBABILITY, propertyDefinition, 0);\n\n    propertyDefinition = PropertyDefinition.builder()//\n            .setType(Double.class)//\n            .setDefaultValue(365.0)//\n            .setPropertyValueMutability(false)//\n            .build();\n    builder.defineGlobalProperty(GlobalProperty.SIMULATION_DURATION, propertyDefinition, 0);\n\n    propertyDefinition = PropertyDefinition.builder()//\n            .setType(Integer.class)//\n            .setDefaultValue(1000)//\n            .setPropertyValueMutability(false)//\n            .build();\n\n    builder.defineGlobalProperty(GlobalProperty.POPULATION_SIZE, propertyDefinition, 0);\n\n    GlobalPropertiesPluginData globalPropertiesPluginData = builder.build();\n\n    return GlobalPropertiesPlugin.builder().setGlobalPropertiesPluginData(globalPropertiesPluginData)\n            .getGlobalPropertiesPlugin();\n\n}\n\n\nThe execution method then loads reports (Code Block 9.4). The person property report will be quite large and is set to only show the state of each person at the end of the simulation for brevity. The vaccine report will show the state of vaccination and immunity at the end of the simulation to allow for analysis of the experiment.\nThe people plugin is created without any initial people since that will be handled by one of the model plugin’s actors. The regions plugin is initialized with five regions and only plays a role in the person property report.\nThe person properties plugin is generated in Code Block 9.4. All of the person properties are mutable since they will change over the course of the simulation:\n\nEDUCATION_ATTEMPTS – The number of attempts to change a person’s vaccine refusal.\nVACCINE_ATTEMPTS – The number of attempts to vaccinate a person.\nREFUSES_VACCINE – Boolean indicating whether the person will refuse vaccination attempts. Note that there is no default value and that new people must have this property set as part of the addition of the person to the simulation.\nVACCINATED – Boolean indicating that a person has been vaccinated. People all start out with no vaccination and receive at most one vaccination.\n\nNote that the final person property, IS_IMMUNE, is not added at the beginning of the simulation as a demonstration of the dynamic addition of person properties.\n\n\nCode Block 9.4: The person properties plugin is built with the four person properties needed to model each person. The person property report is set to report only at the end of the simulation.\nprivate Plugin getPersonPropertiesPlugin() {\n    PersonPropertiesPluginData.Builder builder = PersonPropertiesPluginData.builder();\n    PropertyDefinition propertyDefinition = PropertyDefinition.builder()//\n            .setType(Integer.class)//\n            .setDefaultValue(0)//\n            .build();\n    builder.definePersonProperty(PersonProperty.EDUCATION_ATTEMPTS, propertyDefinition, 0, false);\n    builder.definePersonProperty(PersonProperty.VACCINE_ATTEMPTS, propertyDefinition, 0, false);\n\n    propertyDefinition = PropertyDefinition.builder()//\n            .setType(Boolean.class)//\n            .build();\n    builder.definePersonProperty(PersonProperty.REFUSES_VACCINE, propertyDefinition, 0, false);\n\n    propertyDefinition = PropertyDefinition.builder()//\n            .setType(Boolean.class)//\n            .setDefaultValue(false)//\n            .build();\n    builder.definePersonProperty(PersonProperty.VACCINATED, propertyDefinition, 0, false);\n\n    PersonPropertiesPluginData personPropertiesPluginData = builder.build();\n\n    PersonPropertyReportPluginData personPropertyReportPluginData = PersonPropertyReportPluginData.builder()//\n            .setReportLabel(ModelReportLabel.PERSON_PROPERTY_REPORT)//\n            .setReportPeriod(ReportPeriod.END_OF_SIMULATION)//\n            .setDefaultInclusion(true)//\n            .build();//\n\n    return PersonPropertiesPlugin.builder()//\n            .setPersonPropertiesPluginData(personPropertiesPluginData)//\n            .setPersonPropertyReportPluginData(personPropertyReportPluginData)//\n            .getPersonPropertyPlugin();\n}\n\n\nAdding the stochastics plugin involves setting only the seed that will be used in every simulation instance. It will not play a role in defining the experiment space since that will be quite large already with various global property variants. Finally, the execution method generates the model plugin which in turn adds three actors:\n\nVaccinator – vaccinates people at random times\nVaccine Educator – seeks to get people to accept vaccination\nPopulation Loader – initializes the population\n\nThe execute method finishes (Code Block 9.5) by constructing and executing the experiment.\n\n\nCode Block 9.5: The experiment executes 810 scenarios on 8 threads.\n        ExperimentParameterData experimentParameterData = ExperimentParameterData.builder()//\n                .setThreadCount(8)//\n                .build();\n\n        Experiment.builder()//\n\n                .addPlugin(personPropertiesPlugin)//\n                .addPlugin(globalPropertiesPlugin)//\n                .addPlugin(modelPlugin)//\n                .addPlugin(regionsPlugin)//\n                .addPlugin(peoplePlugin)//\n                .addPlugin(stochasticsPlugin)//\n\n                .addDimension(getImmunityStartTimeDimension())//\n                .addDimension(getImmunityProbabilityDimension())//\n                .addDimension(getVaccineAttemptIntervalDimension())//\n                .addDimension(getEducationAttemptIntervalDimension())//\n                .addDimension(getEducationSuccessRatedimension())//\n                .addDimension(getVaccineRefusalProbabilityDimension())//\n                .addExperimentContextConsumer(nioReportItemHandler)//\n                .setExperimentParameterData(experimentParameterData)//\n                .build()//\n                .execute();//\n\n\nFive dimensions are added to the experiment that define alternate values for five of the global properties resulting in 810 scenarios. These values are:\n\nImmunity start time – 120 and 180 days\nImmunity probability – 0, 10 and 20 percent\nVaccine attempt interval – 30, 45 and 60 days\nEducation attempt interval – 30, 60 and 180 days\nEducation success rate – 0, 10 and 20 percent\nInitial vaccine refusal – 0, 25, 50, 75 and 100 percent"
  },
  {
    "objectID": "ch09-PersonPropertiesPlugin.html#the-actors",
    "href": "ch09-PersonPropertiesPlugin.html#the-actors",
    "title": "9  Person Properties Plugin",
    "section": "9.5 The actors",
    "text": "9.5 The actors\nWe will finish this chapter by reviewing the three actors of the model plugin and then examining the vaccine report.\nThe PopulationLoader actor, in Code Block 9.6, adds people to the simulation based on the number in the POPULATION_SIZE global property. Each person is assigned a random region and the person property, REFUSES_VACCINE, is randomly assigned based on the global property VACCINE_REFUSAL_PROBABILITY.\n\n\nCode Block 9.6: The population loader initializes by creating people dictated by the POPULATION_SIZE global property. Each person is assigned a region and random value for the person property, REFUSES_VACCINE, based on the global property, VACCINE_REFUSAL_PROBABILITY.\npublic void init(ActorContext actorContext) {\n    peopleDataManager = actorContext.getDataManager(PeopleDataManager.class);\n    personPropertiesDataManager = actorContext.getDataManager(PersonPropertiesDataManager.class);\n    globalPropertiesDataManager = actorContext.getDataManager(GlobalPropertiesDataManager.class);\n    RegionsDataManager regionsDataManager = actorContext.getDataManager(RegionsDataManager.class);\n    StochasticsDataManager stochasticsDataManager = actorContext.getDataManager(StochasticsDataManager.class);\n    randomGenerator = stochasticsDataManager.getRandomGenerator();\n    List<RegionId> regionIds = new ArrayList<>(regionsDataManager.getRegionIds());\n\n    int populationSize = globalPropertiesDataManager.getGlobalPropertyValue(GlobalProperty.POPULATION_SIZE);\n    double refusalProbability = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.VACCINE_REFUSAL_PROBABILITY);\n\n    Builder personConstructionDataBuilder = PersonConstructionData.builder();\n    for (int i = 0; i < populationSize; i++) {\n        RegionId regionId = regionIds.get(randomGenerator.nextInt(regionIds.size()));\n        personConstructionDataBuilder.add(regionId);\n\n        boolean refusesVaccine = randomGenerator.nextDouble() < refusalProbability;\n        PersonPropertyValueInitialization personPropertyInitialization = new PersonPropertyValueInitialization(\n                PersonProperty.REFUSES_VACCINE, refusesVaccine);\n        personConstructionDataBuilder.add(personPropertyInitialization);\n        PersonConstructionData personConstructionData = personConstructionDataBuilder.build();\n        peopleDataManager.addPerson(personConstructionData);\n    }\n\n    double simulationDuration = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.SIMULATION_DURATION);\n    actorContext.addPlan((c) -> c.halt(), simulationDuration);\n\n    double immunityStartTime = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.IMMUNITY_START_TIME);\n    actorContext.addPlan((c) -> addImmunityProperty(), immunityStartTime);\n}\n\n\nThe actor finishes its initialization by scheduling a time to halt the simulation based on the global property, SIMULATION_DURATION. It also schedules the addition of the person property, IS_IMMUNE, based on the global property, IMMUNITY_START_TIME. Code Block 9.7 shows the details of this dynamic definition.\n\n\nCode Block 9.7: At the time set via the global property, IMMUNITY_START_TIME, the population loader defines the person property, IS_IMMUNE, and sets the property value for each person.\nprivate void addImmunityProperty() {\n    PersonPropertyDefinitionInitialization.Builder builder = PersonPropertyDefinitionInitialization.builder();\n    builder.setPersonPropertyId(PersonProperty.IS_IMMUNE);\n    PropertyDefinition propertyDefinition = PropertyDefinition.builder().setType(Boolean.class).build();\n    builder.setPropertyDefinition(propertyDefinition);\n    double immunityProbability = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.IMMUNITY_PROBABILITY);\n\n    for (PersonId personId : peopleDataManager.getPeople()) {\n        boolean isImmune = randomGenerator.nextDouble() < immunityProbability;\n        builder.addPropertyValue(personId, isImmune);\n    }\n    PersonPropertyDefinitionInitialization personPropertyDefinitionInitialization = builder.build();\n    personPropertiesDataManager.definePersonProperty(personPropertyDefinitionInitialization);\n}\n\n\nThe vaccine educator (Code Block 9.8) attempts to change unvaccinated people who refuse vaccination to vaccine acceptance. It initializes by planning an educational attempt for each person in the existing population who has not been vaccinated and who will refuse vaccination. It also subscribes to the addition of people so that it might plan education for newly added people.\n\n\nCode Block 9.8: The vaccine educator initializes by planning the education for each person who refuses vaccination.\npublic void init(ActorContext actorContext) {\n    this.actorContext = actorContext;\n\n    StochasticsDataManager stochasticsDataManager = actorContext.getDataManager(StochasticsDataManager.class);\n    randomGenerator = stochasticsDataManager.getRandomGenerator();\n    PeopleDataManager peopleDataManager = actorContext.getDataManager(PeopleDataManager.class);\n    personPropertiesDataManager = actorContext.getDataManager(PersonPropertiesDataManager.class);\n    globalPropertiesDataManager = actorContext.getDataManager(GlobalPropertiesDataManager.class);\n\n    educationAttemptInterval = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.EDUCATION_ATTEMPT_INTERVAL);\n    educationSuccessRate = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.EDUCATION_SUCCESS_RATE);\n\n    List<PersonId> unvaccinatedPeople = personPropertiesDataManager\n            .getPeopleWithPropertyValue(PersonProperty.VACCINATED, false);\n    for (PersonId personId : unvaccinatedPeople) {\n        Boolean refusesVaccine = personPropertiesDataManager.getPersonPropertyValue(personId,\n                PersonProperty.REFUSES_VACCINE);\n        if (refusesVaccine) {\n            planEducation(personId);\n        }\n    }\n\n    actorContext.subscribe(peopleDataManager.getEventFilterForPersonAdditionEvent(), (c, e) -> {\n        handleNewPerson(e.personId());\n    });\n}\n\n\nThe education of a person (Code Block 9.9) is accomplished with planning that schedules the education at a random time between the current time and a globally defined attempt interval.\n\n\nCode Block 9.9: Attempts to educate a person on vaccination are scheduled at random times in the future based on the global property, EDUCATION_ATTEMPT_INTERVAL.\nprivate void planEducation(PersonId personId) {\n    double planTime = actorContext.getTime() + randomGenerator.nextDouble() * educationAttemptInterval;\n    Consumer<ActorContext> plan = (c) -> educatePerson(personId);\n    actorContext.addPlan(plan, planTime);\n}\n\nprivate void handleNewPerson(PersonId personId) {\n    boolean vaccinated = personPropertiesDataManager.getPersonPropertyValue(personId, PersonProperty.VACCINATED);\n    if (!vaccinated) {\n        Boolean refusesVaccine = personPropertiesDataManager.getPersonPropertyValue(personId,\n                PersonProperty.REFUSES_VACCINE);\n        if (refusesVaccine) {\n            planEducation(personId);\n        }\n    }\n}\n\n\nThe education attempt sets the vaccine refusal to false on a random draw based on the EDUCATION_SUCCESS_RATE global variable in Code Block 9.10.\n\n\nCode Block 9.10: After updating the number of educational attempts for a person, the vaccine educator succeeds in educating the person to stop refusing vaccination based on the global property, EDUCATION_SUCCESS_RATE.\nprivate void educatePerson(PersonId personId) {\n    int educationAttempts = personPropertiesDataManager.getPersonPropertyValue(personId,\n            PersonProperty.EDUCATION_ATTEMPTS);\n    personPropertiesDataManager.setPersonPropertyValue(personId, PersonProperty.EDUCATION_ATTEMPTS,\n            educationAttempts + 1);\n\n    if (randomGenerator.nextDouble() < educationSuccessRate) {\n        personPropertiesDataManager.setPersonPropertyValue(personId, PersonProperty.REFUSES_VACCINE, false);\n    } else {\n        planEducation(personId);\n    }\n}\n\n\nThe Vaccinator (Code Block 9.11) tries to vaccinate the population. It initializes by planning a vaccination attempt for each person in the existing population who has not yet been vaccinated. It subscribes to the addition of people so that it might plan vaccination for newly added people. It also subscribes to changes to the VACCINE_REFUSAL person property so that it can immediately attempt vaccination.\n\n\nCode Block 9.11: The vaccinator initializes by planning vaccination attempts for each person who is unvaccinated. It also subscribes to changes in the vaccine refusal property for all people so that when a person stops refusing vaccine, they can be vaccinated immediately.\npublic void init(ActorContext actorContext) {\n    this.actorContext = actorContext;\n    StochasticsDataManager stochasticsDataManager = actorContext.getDataManager(StochasticsDataManager.class);\n    randomGenerator = stochasticsDataManager.getRandomGenerator();\n    peopleDataManager = actorContext.getDataManager(PeopleDataManager.class);\n    personPropertiesDataManager = actorContext.getDataManager(PersonPropertiesDataManager.class);\n    globalPropertiesDataManager = actorContext.getDataManager(GlobalPropertiesDataManager.class);\n\n    List<PersonId> unvaccinatedPeople = personPropertiesDataManager\n            .getPeopleWithPropertyValue(PersonProperty.VACCINATED, false);\n    vaccineAttemptInterval = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.VACCINE_ATTEMPT_INTERVAL);\n    for (PersonId personId : unvaccinatedPeople) {\n        planVaccination(personId);\n    }\n\n    EventFilter<PersonPropertyUpdateEvent> eventFilter = personPropertiesDataManager//\n            .getEventFilterForPersonPropertyUpdateEvent(PersonProperty.REFUSES_VACCINE);\n\n    actorContext.subscribe(eventFilter, this::handleVaccineAcceptance);\n\n    actorContext.subscribe(peopleDataManager.getEventFilterForPersonAdditionEvent(), (c, e) -> {\n        handleNewPerson(e.personId());\n    });\n\n}\n\n\nVaccination of a person (Code Block 9.12) is accomplished with planning that schedules the vaccination at a random time between the current time and a globally defined attempt interval.\n\n\nCode Block 9.12: Each unvaccinated person has a planned vaccination based on the VACCINE_ATTEMPT_INTERVAL global property.\nprivate void planVaccination(PersonId personId) {\n    double planTime = actorContext.getTime() + randomGenerator.nextDouble() * vaccineAttemptInterval;\n    Object planKey = personId;\n    Plan<ActorContext> plan = Plan.builder(ActorContext.class)//\n            .setCallbackConsumer((c) -> vaccinatePerson(personId))//\n            .setKey(planKey)//\n            .setTime(planTime)//\n            .build();//\n    actorContext.addPlan(plan);\n}\n\nprivate void handleNewPerson(PersonId personId) {\n    boolean vaccinated = personPropertiesDataManager.getPersonPropertyValue(personId, PersonProperty.VACCINATED);\n    if (!vaccinated) {\n        planVaccination(personId);\n    }\n}\n\n\nNote that the plan uses a key value set to the person id. This is used when reacting to a person changing from refusal of the vaccine to acceptance. Instead of waiting for the next vaccine attempt (Code Block 9.13), the current plan to vaccinate is removed and the person is immediately vaccinated.\n\n\nCode Block 9.13: When a person stops refusing vaccination, the vaccinator immediately attempts the vaccination of that person.\nprivate void handleVaccineAcceptance(ActorContext actorContext,\n        PersonPropertyUpdateEvent personPropertyUpdateEvent) {\n    /*\n         * We know that the person property is PersonProperty.REFUSES_VACCINE since we\n         * used an event filter when subscribing\n         */\n    Boolean refusesVaccine = personPropertyUpdateEvent.getCurrentPropertyValue();\n    if (!refusesVaccine) {\n        PersonId personId = personPropertyUpdateEvent.personId();\n        // drop the current plan\n        actorContext.removePlan(personId);\n        vaccinatePerson(personId);\n    }\n}\n\n\nThe vaccination attempt (Code Block 9.14) first considers whether the IS_IMMUNE property has been added. If it has then immunity for the person is determined. Immune people do not receive the vaccine and no more attempts to vaccinate the person will be scheduled. If the person is still refusing the vaccine, then a new attempt to vaccinate the person is scheduled. Otherwise the person is vaccinated and no further attempts are scheduled.\n\n\nCode Block 9.14: With each vaccination attempt, the vaccinator updates the VACCINE_ATTEMPTS person property for the person. People who refuse vaccination are scheduled for another vaccination attempt.\nprivate void vaccinatePerson(PersonId personId) {\n    int vaccineAttempts = personPropertiesDataManager.getPersonPropertyValue(personId,\n            PersonProperty.VACCINE_ATTEMPTS);\n    personPropertiesDataManager.setPersonPropertyValue(personId, PersonProperty.VACCINE_ATTEMPTS,\n            vaccineAttempts + 1);\n\n    boolean isImmune = false;\n    if (personPropertiesDataManager.personPropertyIdExists(PersonProperty.IS_IMMUNE)) {\n        isImmune = personPropertiesDataManager.getPersonPropertyValue(personId, PersonProperty.IS_IMMUNE);\n    }\n\n    Boolean refusesVaccine = personPropertiesDataManager.getPersonPropertyValue(personId,\n            PersonProperty.REFUSES_VACCINE);\n    if (!isImmune) {\n        if (refusesVaccine) {\n            double planTime = actorContext.getTime() + randomGenerator.nextDouble() * vaccineAttemptInterval;\n            Object planKey = personId;\n\n            Plan<ActorContext> plan = Plan.builder(ActorContext.class)//\n                    .setCallbackConsumer((c) -> vaccinatePerson(personId))//\n                    .setKey(planKey)//\n                    .setTime(planTime)//\n                    .build();//\n\n            actorContext.addPlan(plan);\n        } else {\n            personPropertiesDataManager.setPersonPropertyValue(personId, PersonProperty.VACCINATED, true);\n        }\n    }\n}"
  },
  {
    "objectID": "ch09-PersonPropertiesPlugin.html#inspecting-the-output",
    "href": "ch09-PersonPropertiesPlugin.html#inspecting-the-output",
    "title": "9  Person Properties Plugin",
    "section": "9.6 Inspecting the output",
    "text": "9.6 Inspecting the output\nThe 810 scenarios result in a large amount of output in the person properties report with over 125,000 entries. The vaccine report is a bit too large to fully present here. Its fields are:\n\nScenario – 0 to 809\nExperiment fields that show what differentiates each scenario\n\nimmunity start time\nimmunity probabilty\nvaccine attempt interval\neducation attempt interval\neducation success rate\nintial refusal probability\n\nThe metric fields produced as a result of the experiment choices\n\nvaccinated immune\nvaccinated susceptible\nunvaccinated immune\nunvaccinated susceptible\n\n\nAnalyzing the output yields no surprises. Higher education attempt rates and greater probabilities of education success yield more people getting vaccinated. Similarly, early and high levels of immunity have a slight dampening effect on vaccinations."
  },
  {
    "objectID": "ch10-GroupsPlugins.html#plugin-data-dependency",
    "href": "ch10-GroupsPlugins.html#plugin-data-dependency",
    "title": "10  Groups Plugin",
    "section": "10.1 Plugin Data Dependency",
    "text": "10.1 Plugin Data Dependency\nThe groups plugin depends on the people plugin and the stochastics plugin. The stochastics plugin is used for random sampling of people from groups."
  },
  {
    "objectID": "ch10-GroupsPlugins.html#plugin-data-initialization",
    "href": "ch10-GroupsPlugins.html#plugin-data-initialization",
    "title": "10  Groups Plugin",
    "section": "10.2 Plugin Data initialization",
    "text": "10.2 Plugin Data initialization\nThe plugin is initialized using a GroupsPluginData object that:\n\nadds group types\ndefines group properties for each group type\nsets group property value per group\nadds groups\ninitializes the person membership in groups"
  },
  {
    "objectID": "ch10-GroupsPlugins.html#plugin-behavior",
    "href": "ch10-GroupsPlugins.html#plugin-behavior",
    "title": "10  Groups Plugin",
    "section": "10.3 Plugin Behavior",
    "text": "10.3 Plugin Behavior\nThe plugin adds a single data manager to the simulation as an instance of the GroupsDataManager that is initialized with the GroupsPluginData."
  },
  {
    "objectID": "ch10-GroupsPlugins.html#data-manager",
    "href": "ch10-GroupsPlugins.html#data-manager",
    "title": "10  Groups Plugin",
    "section": "10.4 Data Manager",
    "text": "10.4 Data Manager\nThe data manager manages group memberships and group property values. The data manager provides public methods that:\n\nAdd/Remove a group\nAdd a group type\nAdd/Remove a person to/from a group\nDefine a group property\nSet a group property value\nSample a random person from a group\nProvide many queries about the state of groups\n\nThe data manager also produces observable events:\n\nGroupAdditionEvent – when a group is added\nGroupImminentRemovalEvent – when a group is about to be removed\nGroupMembershipAdditionEvent – when a person is added to a group\nGroupMembershipRemovalEvent – when a person is removed from a group\nGroupPropertyDefinitionEvent – when a new group property is defined\nGroupPropertyUpdateEvent – when a group property value is updated\nGroupTypeAdditionEvent – when a new group type is added"
  },
  {
    "objectID": "ch10-GroupsPlugins.html#example-code-lesson-17",
    "href": "ch10-GroupsPlugins.html#example-code-lesson-17",
    "title": "10  Groups Plugin",
    "section": "10.5 Example Code (Lesson 17)",
    "text": "10.5 Example Code (Lesson 17)\nExample_17.java shows the use of the groups plugin. In it we will examine:\n\nThe initialization of the groups plugin\nThe movement of people in and out of groups\n\nThe example includes seven plugins:\n\nGroups plugin – (GCM core plugin) used to manage groups\nPeople plugin – (GCM core plugin) used to manage people\nPerson properties plugin – (GCM core plugin) used to decorate properties onto people\nGlobal properties plugin – (GCM core plugin) used to store policies and initial conditions affecting groups and disease transmission\nStochastics plugin – (GCM core plugin) used to generate random numbers used in various decisions\nRegions Plugin – (GCM core plugin) used for various reports\nModel plugin – (local plugin) used to introduce four actors that will:\n\nLoad the population\nManage the spread of disease through transmission in groups\nManage group-based mitigation strategies in schools\nManage group-based mitigation strategies in work places"
  },
  {
    "objectID": "ch10-GroupsPlugins.html#model",
    "href": "ch10-GroupsPlugins.html#model",
    "title": "10  Groups Plugin",
    "section": "10.6 Model",
    "text": "10.6 Model\nThe example’s model represents a disease that is not treatable but can be mitigated through social distancing, school closures and the use of telework arrangements. People at the start of the simulation are either immune or susceptible. Infection is spread through personal contact in groups and is subject to public policies triggered by the number of infectious people present in the total population or in specific groups. The population is set to 10,000 people and the groups are synthetically derived using fixed proportions (global properties) for school aged children (0-18 yrs), working adults (19 to 64 yrs) and non-working seniors (65+yrs). All people are assigned a home group. School aged children are assigned to a single school group and working age adults are assigned to a single work group. The number of each group type is determined by fixed expected groups sizes (global properties).\nAt the beginning of the model, a small number of adults are infected at random. Each infected person is immediately infectious and will infect one person per day over a random period from 3 to 12 days inclusive. Without mitigations, each transmission is successful. Public policies are reviewed on a weekly basis. As the number of total public infections increase, some work groups may elect to move to a telework status, reducing transmissions by 50% in those groups. Similarly, when a school’s level of infection increases it will move to a split cohort mode, reducing transmission success to 50%. If infection within a cohort continues to rise, the cohort is closed and the children are no longer assigned to a school group. For simplicity of modeling, telework arrangements, cohort schools and school closures do not revert as infection levels subside."
  },
  {
    "objectID": "ch10-GroupsPlugins.html#model-execution",
    "href": "ch10-GroupsPlugins.html#model-execution",
    "title": "10  Groups Plugin",
    "section": "10.7 Model Execution",
    "text": "10.7 Model Execution\nThe example’s execution is shown in Code Block 10.1 and Code Block 10.2.\n\n\nCode Block 10.1: Executing example 17 with an output directory.\npublic static void main(String[] args) throws IOException {\n    if (args.length == 0) {\n        throw new RuntimeException(\"One output directory argument is required\");\n    }\n    Path outputDirectory = Paths.get(args[0]);\n    if (!Files.exists(outputDirectory)) {\n        Files.createDirectory(outputDirectory);\n    } else {\n        if (!Files.isDirectory(outputDirectory)) {\n            throw new IOException(\"Provided path is not a directory\");\n        }\n    }\n\n    new Example_17(outputDirectory).execute();\n}\n\n\n\n\nCode Block 10.2: The various plugins are gathered from their initial data, dimensions are added and the experiment is executed over 36 scenarios using 8 threads.\nprivate void execute() {\n\n    ExperimentParameterData experimentParameterData = ExperimentParameterData.builder()//\n            .setThreadCount(8)//\n            .build();\n\n    Experiment.builder()\n\n            .addPlugin(getGlobalPropertiesPlugin())//\n            .addPlugin(getPersonPropertiesPlugin())//\n            .addPlugin(getRegionsPlugin())//\n            .addPlugin(getPeoplePlugin())//\n            .addPlugin(getGroupsPlugin())//\n            .addPlugin(getStochasticsPlugin())//\n            .addPlugin(ModelPlugin.getModelPlugin())//\n\n            .addDimension(getTeleworkProbabilityDimension())//\n            .addDimension(getTeleworkInfectionThresholdDimension())//\n            .addDimension(getSchoolDimension())//\n\n            .addExperimentContextConsumer(getNIOReportItemHandler())//\n            .setExperimentParameterData(experimentParameterData)//              \n            .build()//\n            .execute();//\n}\n\n\nThe first action is to load the global properties plugin (Code Block 10.3). The fifteen global properties are marked as immutable since they will not change over the course of the simulation. Further, eleven of the properties are fixed and their values are set in the plugin data. The four remaining properties participate in the dimensions of the experiment and are not directly set in the global plugin.\n\nSUSCEPTIBLE_POPULATION_PROPORTION – The fraction of the population that is susceptible\nINITIAL_INFECTIONS – The number of adults initially infected\nMIN_INFECTIOUS_PERIOD – The minimum number of days a person is infectious\nMAX_INFECTIOUS_PERIOD – The maximum number of days a person is infectious\nPOPULATION_SIZE – The initial size of the population\nCHILD_POPULATION_PROPORTION – The fraction of the population between the ages of 0 and 18, inclusive\nSENIOR_POPULATION_PROPORTION – The fraction of the population 65 and older\nR0 – The expected number of people a single person will infect if all contacts are susceptible and transmission success is 100% likely\nAVERAGE_HOME_SIZE – The average number of people per household\nAVERAGE_SCHOOL_SIZE – The average number of students in a school\nAVERAGE_WORK_SIZE – The average number of people per work place\nTELEWORK_INFECTION_THRESHOLD – The total infection density that triggers some work places to institute telework mode\nTELEWORK_PROBABILTY – The probability that a work place will convert to telework mode once telework is allowed\nSCHOOL_COHORT_INFECTION_THRESHOLD – The infection density within a school that triggers the school moving to a split cohort\nSCHOOL_CLOSURE_INFECTION_THRESHOLD – The infection density within a school cohort that triggers the closure of that cohort.\n\n\n\nCode Block 10.3: The global properties plugin is initialized with several properties\nprivate Plugin getGlobalPropertiesPlugin() {\n    GlobalPropertiesPluginData.Builder builder = GlobalPropertiesPluginData.builder();//\n\n    PropertyDefinition propertyDefinition = PropertyDefinition.builder()//\n            .setType(Double.class)//\n            .setPropertyValueMutability(false)//\n            .setDefaultValue(0.0).build();\n\n    builder.defineGlobalProperty(GlobalProperty.SUSCEPTIBLE_POPULATION_PROPORTION, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.AVERAGE_HOME_SIZE, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.AVERAGE_SCHOOL_SIZE, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.AVERAGE_WORK_SIZE, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.CHILD_POPULATION_PROPORTION, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.SENIOR_POPULATION_PROPORTION, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.R0, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.TELEWORK_INFECTION_THRESHOLD, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.TELEWORK_PROBABILTY, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.SCHOOL_COHORT_INFECTION_THRESHOLD, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.SCHOOL_CLOSURE_INFECTION_THRESHOLD, propertyDefinition, 0);\n\n    propertyDefinition = PropertyDefinition.builder()//\n            .setType(Integer.class)//\n            .setPropertyValueMutability(false)//\n            .build();\n    builder.defineGlobalProperty(GlobalProperty.INITIAL_INFECTIONS, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.MIN_INFECTIOUS_PERIOD, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.MAX_INFECTIOUS_PERIOD, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.POPULATION_SIZE, propertyDefinition, 0);\n\n    builder.setGlobalPropertyValue(GlobalProperty.POPULATION_SIZE, 10_000, 0);\n    builder.setGlobalPropertyValue(GlobalProperty.SUSCEPTIBLE_POPULATION_PROPORTION, 1.0, 0);\n    builder.setGlobalPropertyValue(GlobalProperty.INITIAL_INFECTIONS, 10, 0);\n    builder.setGlobalPropertyValue(GlobalProperty.MIN_INFECTIOUS_PERIOD, 3, 0);\n    builder.setGlobalPropertyValue(GlobalProperty.MAX_INFECTIOUS_PERIOD, 12, 0);\n    builder.setGlobalPropertyValue(GlobalProperty.R0, 2.0, 0);\n    builder.setGlobalPropertyValue(GlobalProperty.CHILD_POPULATION_PROPORTION, 0.235, 0);\n    builder.setGlobalPropertyValue(GlobalProperty.SENIOR_POPULATION_PROPORTION, 0.169, 0);\n    builder.setGlobalPropertyValue(GlobalProperty.AVERAGE_HOME_SIZE, 2.5, 0);\n    builder.setGlobalPropertyValue(GlobalProperty.AVERAGE_SCHOOL_SIZE, 250.0, 0);\n    builder.setGlobalPropertyValue(GlobalProperty.AVERAGE_WORK_SIZE, 30.0, 0);\n\n    GlobalPropertiesPluginData globalPropertiesPluginData = builder.build();\n\n    return GlobalPropertiesPlugin.builder().setGlobalPropertiesPluginData(globalPropertiesPluginData)\n            .getGlobalPropertiesPlugin();\n}\n\n\nThe person properties plugin is loaded in (Code Block 10.4). The properties are:\n\nAGE – An integer value for the age of a person: child (0-18), adult (19-64), senior (65+)\nDISEASE_STATE – The state for a person: IMMUNE, SUSCEPTIBLE, INFECTIOUS, RECOVERED\nINFECTED_COUNT – The number of people infected by each particular person\n\n\n\nCode Block 10.4: The person properties plugin is initialized with several properties.\nprivate Plugin getPersonPropertiesPlugin() {\n\n    PersonPropertiesPluginData.Builder builder = PersonPropertiesPluginData.builder();\n\n    PropertyDefinition propertyDefinition = PropertyDefinition.builder()//\n            .setType(Integer.class)//\n            .build();\n\n    builder.definePersonProperty(PersonProperty.AGE, propertyDefinition, 0, false);//\n\n    propertyDefinition = PropertyDefinition.builder()//\n            .setType(DiseaseState.class)//\n            .setDefaultValue(DiseaseState.SUSCEPTIBLE).build();\n\n    builder.definePersonProperty(PersonProperty.DISEASE_STATE, propertyDefinition, 0, false);//\n\n    propertyDefinition = PropertyDefinition.builder()//\n            .setType(Integer.class)//\n            .setDefaultValue(0).build();\n\n    builder.definePersonProperty(PersonProperty.INFECTED_COUNT, propertyDefinition, 0, false);//\n\n    PersonPropertiesPluginData personPropertiesPluginData = builder.build();\n\n    PersonPropertyReportPluginData personPropertyReportPluginData = PersonPropertyReportPluginData.builder()//\n            .setReportLabel(ModelReportLabel.PERSON_PROPERTY)//\n            .setReportPeriod(ReportPeriod.DAILY)//\n            .includePersonProperty(PersonProperty.DISEASE_STATE)//\n            .build();\n\n    return PersonPropertiesPlugin.builder()//\n            .setPersonPropertiesPluginData(personPropertiesPluginData)//\n            .setPersonPropertyReportPluginData(personPropertyReportPluginData)//\n            .getPersonPropertyPlugin();\n}\n\n\nThe groups plugin (Code Block 10.5) loads the group types and their corresponding group properties. The creation of groups is left to the Population Loader.\n\nHOME\nSCHOOL\n\nSCHOOL_STATUS : OPEN, COHORT (50% transmission reduction), CLOSED (100% transmission reduction)\n\nWORK\n\nTELEWORK – Boolean designating work place as telework, reducing transmission by 50%\n\n\n\n\nCode Block 10.5: The groups plugin includes a tele-work property for work places and open status properties for schools.\nprivate Plugin getGroupsPlugin() {\n    GroupsPluginData.Builder builder = GroupsPluginData.builder();\n    for (GroupType groupType : GroupType.values()) {\n        builder.addGroupTypeId(groupType);\n    }\n    PropertyDefinition propertyDefinition = PropertyDefinition.builder()//\n            .setType(Boolean.class)//\n            .setDefaultValue(false)//\n            .build();\n\n    builder.defineGroupProperty(GroupType.WORK, GroupProperty.TELEWORK, propertyDefinition);\n\n    propertyDefinition = PropertyDefinition.builder()//\n            .setType(SchoolStatus.class)//\n            .setDefaultValue(SchoolStatus.OPEN)//\n            .build();\n\n    builder.defineGroupProperty(GroupType.SCHOOL, GroupProperty.SCHOOL_STATUS, propertyDefinition);\n\n    GroupsPluginData groupsPluginData = builder.build();\n\n    GroupPopulationReportPluginData groupPopulationReportPluginData = //\n            GroupPopulationReportPluginData.builder()//\n                    .setReportLabel(ModelReportLabel.GROUP_POPULATON)//\n                    .setReportPeriod(ReportPeriod.END_OF_SIMULATION)//\n                    .build();//\n    return GroupsPlugin.builder()//\n            .setGroupsPluginData(groupsPluginData)//\n            .setGroupPopulationReportPluginData(groupPopulationReportPluginData)//\n            .getGroupsPlugin();\n}\n\n\nThe stochastics plugin is initialized with a random seed and all simulations will start in the same stochastic state. The regions plugin has five regions and the people plugin is loaded in an empty state. People are added by an actor in the model plugin.\nThe model plugin adds four actors\n\nPopulationLoader – Adds people and groups to the simulation and initializes immunity.\nInfectionManager– Infects a small number of randomly chosen adults. Manages the progress of infections and the spread of infection from one per to another via their shared groups.\nTeleworkManager – Reviews the status of infections within the greater population every week and triggers randomly selected work places to move to telework mode.\nSchoolManager – Reviews the status of infections per school every week and splits school groups into cohorts. If infections increase it can close individual schools.\n\nThe reports in this model are:\n\nGroupPopulationReport – Shows the distribution of group sizes for each group type at the end of the simulation.\nPersonPropertyReport – Shows the distribution of disease state values over each day by regions\nDiseaseStateReport – Shows the distribution of disease state at the end of the simulation with a single line per scenario\nContagionReport – Shows the distribution of the number of infections spread per person"
  },
  {
    "objectID": "ch10-GroupsPlugins.html#experiment-dimensions",
    "href": "ch10-GroupsPlugins.html#experiment-dimensions",
    "title": "10  Groups Plugin",
    "section": "10.8 Experiment dimensions",
    "text": "10.8 Experiment dimensions\nThree dimensions are added to the experiment that define alternate values for telework infection thresholds, telework adoption probability, school cohort infection thresholds and school closure infection thresholds, yielding 36 scenarios. The values are:\n\nTelework infection threshold – 0.1, 1, and 10 percent\nTelework adoption probability – 10, 30, 50 and 80 percent\nSchool cohort and closure infection thresholds\n\n0.1 and 1 percent\n1 and 2 percent\n10 and 20 percent"
  },
  {
    "objectID": "ch10-GroupsPlugins.html#the-actors",
    "href": "ch10-GroupsPlugins.html#the-actors",
    "title": "10  Groups Plugin",
    "section": "10.9 The actors",
    "text": "10.9 The actors\nWe will finish this chapter by reviewing the four actors of the model plugin and then examine the output."
  },
  {
    "objectID": "ch10-GroupsPlugins.html#population-loader",
    "href": "ch10-GroupsPlugins.html#population-loader",
    "title": "10  Groups Plugin",
    "section": "10.10 Population Loader",
    "text": "10.10 Population Loader\nThe PopulationLoader actor, in Code Block 10.6, adds people to the simulation based on the number in the POPULATION_SIZE global property. The population is split evenly between the regions. For each region, the manager determines the number of homes needed to house the people based on the AVERAGE_HOME_SIZE. The people are grouped into children, working adults and seniors based on related global properties. Similar calculations determine the number of schools and workplaces. The people are randomly distributed based on their ages into homes, work places and schools. Some care is given to ensure that every household has at least one adult.\n\n\nCode Block 10.6: The population loader initializes by establishing various constants from the global properties and establishing the population of each region.\npublic void init(ActorContext actorContext) {\n    personPropertiesDataManager = actorContext.getDataManager(PersonPropertiesDataManager.class);\n    groupsDataManager = actorContext.getDataManager(GroupsDataManager.class);\n    StochasticsDataManager stochasticsDataManager = actorContext.getDataManager(StochasticsDataManager.class);\n    randomGenerator = stochasticsDataManager.getRandomGenerator();\n    peopleDataManager = actorContext.getDataManager(PeopleDataManager.class);\n    GlobalPropertiesDataManager globalPropertiesDataManager = actorContext\n            .getDataManager(GlobalPropertiesDataManager.class);\n    regionsDataManager = actorContext.getDataManager(RegionsDataManager.class);\n\n    int populationSize = globalPropertiesDataManager.getGlobalPropertyValue(GlobalProperty.POPULATION_SIZE);\n    susceptibleProbability = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.SUSCEPTIBLE_POPULATION_PROPORTION);\n    childPopulationProportion = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.CHILD_POPULATION_PROPORTION);\n    seniorPopulationProportion = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.SENIOR_POPULATION_PROPORTION);\n    averageHomeSize = globalPropertiesDataManager.getGlobalPropertyValue(GlobalProperty.AVERAGE_HOME_SIZE);\n    averageSchoolSize = globalPropertiesDataManager.getGlobalPropertyValue(GlobalProperty.AVERAGE_SCHOOL_SIZE);\n    averageWorkSize = globalPropertiesDataManager.getGlobalPropertyValue(GlobalProperty.AVERAGE_WORK_SIZE);\n\n    Set<RegionId> regionIds = regionsDataManager.getRegionIds();\n    int regionSize = populationSize / regionIds.size();\n    int leftoverPeople = populationSize % regionIds.size();\n\n    for (RegionId regionId : regionIds) {\n        int regionPopulation = regionSize;\n        if (leftoverPeople > 0) {\n            leftoverPeople--;\n            regionPopulation++;\n        }\n        initializeRegionPopulation(regionId, regionPopulation);\n    }\n}\n\n\nInitializing the region population, Code Block 10.7, first establishes the number of home groups, school groups and work groups by determining the number of children, working adults and seniors that are present based on various fixed global property values. The people are added with randomly determined ages and disease immunity.\n\n\nCode Block 10.7: The population for a region is initialized with each person being assigned an age, an immunity status and a region.\nprivate void initializeRegionPopulation(RegionId regionId, int populationSize) {\n\n    double n = populationSize;\n    int homeCount = (int) (n / averageHomeSize) + 1;\n    int childCount = (int) (n * childPopulationProportion);\n    int adultCount = populationSize - childCount;\n    homeCount = FastMath.min(homeCount, adultCount);\n    int seniorCount = (int) (n * seniorPopulationProportion);\n    seniorCount = FastMath.min(seniorCount, adultCount);\n    int workingAdultCount = adultCount - seniorCount;\n    int workCount = (int) ((double) workingAdultCount / averageWorkSize) + 1;\n    int schoolCount = (int) ((double) childCount / averageSchoolSize) + 1;\n\n    // create the population\n    for (int i = 0; i < populationSize; i++) {\n        int age;\n        if (i < seniorCount) {\n            age = randomGenerator.nextInt(25) + 65;\n        } else if (i < adultCount) {\n            age = randomGenerator.nextInt(18) + (65 - 18);\n        } else {\n            age = randomGenerator.nextInt(18);\n        }\n        PersonPropertyValueInitialization ageInitialization = new PersonPropertyValueInitialization(\n                PersonProperty.AGE, age);\n\n        DiseaseState diseaseState = DiseaseState.IMMUNE;\n        if (randomGenerator.nextDouble() < susceptibleProbability) {\n            diseaseState = DiseaseState.SUSCEPTIBLE;\n        }\n\n        PersonPropertyValueInitialization diseaseInitialization = new PersonPropertyValueInitialization(\n                PersonProperty.DISEASE_STATE, diseaseState);\n        PersonConstructionData personConstructionData = PersonConstructionData.builder()//\n                .add(ageInitialization)//\n                .add(diseaseInitialization)//\n                .add(regionId)//\n                .build();\n        peopleDataManager.addPerson(personConstructionData);\n    }\n\n\nIn Code Block 10.8, the manager continues by creating the work, home and school groups. It then organizes the people by age group in Code Block 10.9. Finally, it places the people into the appropriate groups in Code Block 10.10.\n\n\nCode Block 10.8: The home, work and school groups are added to the groups data manager.\n// create the home groups\nList<GroupId> homeGroupIds = new ArrayList<>();\nfor (int i = 0; i < homeCount; i++) {\n    GroupConstructionInfo groupConstructionInfo = GroupConstructionInfo.builder().setGroupTypeId(GroupType.HOME)\n            .build();\n    GroupId groupId = groupsDataManager.addGroup(groupConstructionInfo);\n    homeGroupIds.add(groupId);\n}\n\n// create the work groups\nList<GroupId> workGroupIds = new ArrayList<>();\nfor (int i = 0; i < workCount; i++) {\n    GroupConstructionInfo groupConstructionInfo = GroupConstructionInfo.builder().setGroupTypeId(GroupType.WORK)\n            .build();\n    GroupId groupId = groupsDataManager.addGroup(groupConstructionInfo);\n    workGroupIds.add(groupId);\n}\n\n// create the school groups\nList<GroupId> schoolGroupIds = new ArrayList<>();\nfor (int i = 0; i < schoolCount; i++) {\n    GroupConstructionInfo groupConstructionInfo = GroupConstructionInfo.builder()\n            .setGroupTypeId(GroupType.SCHOOL).build();\n    GroupId groupId = groupsDataManager.addGroup(groupConstructionInfo);\n    schoolGroupIds.add(groupId);\n}\n\n\n\n\nCode Block 10.9: The people are separated into age related lists.\nList<PersonId> peopleInRegion = regionsDataManager.getPeopleInRegion(regionId);\nList<PersonId> adults = new ArrayList<>();\nList<PersonId> children = new ArrayList<>();\nList<PersonId> workingAdults = new ArrayList<>();\nfor (PersonId personId : peopleInRegion) {\n    int age = personPropertiesDataManager.getPersonPropertyValue(personId, PersonProperty.AGE);\n    if (age < 18) {\n        children.add(personId);\n    } else {\n        adults.add(personId);\n        if (age < 65) {\n            workingAdults.add(personId);\n        }\n    }\n}\n\n\n\n\nCode Block 10.10: People are assigned to homes, work places and schools.\nRandom random = new Random(randomGenerator.nextLong());\n/*\n         * Randomize the adults and assign them to the home groups such that there is at\n         * least one adult in each home\n         */\nCollections.shuffle(adults, random);\n// put one adult in each home\nfor (int i = 0; i < homeGroupIds.size(); i++) {\n    PersonId personId = adults.get(i);\n    GroupId groupId = homeGroupIds.get(i);\n    groupsDataManager.addPersonToGroup(personId, groupId);\n}\n\n// assign the remaining adults at random to homes\nfor (int i = homeGroupIds.size(); i < adults.size(); i++) {\n    PersonId personId = adults.get(i);\n    GroupId groupId = homeGroupIds.get(randomGenerator.nextInt(homeGroupIds.size()));\n    groupsDataManager.addPersonToGroup(personId, groupId);\n}\n\n// assign working age adults to work groups\nfor (int i = 0; i < workingAdults.size(); i++) {\n    PersonId personId = workingAdults.get(i);\n    GroupId groupId = workGroupIds.get(randomGenerator.nextInt(workGroupIds.size()));\n    groupsDataManager.addPersonToGroup(personId, groupId);\n}\n\n// assign children to school groups\nfor (int i = 0; i < children.size(); i++) {\n    PersonId personId = children.get(i);\n    GroupId groupId = schoolGroupIds.get(randomGenerator.nextInt(schoolGroupIds.size()));\n    groupsDataManager.addPersonToGroup(personId, groupId);\n}\n\n// assign children to home groups\nfor (int i = 0; i < children.size(); i++) {\n    PersonId personId = children.get(i);\n    GroupId groupId = homeGroupIds.get(randomGenerator.nextInt(homeGroupIds.size()));\n    groupsDataManager.addPersonToGroup(personId, groupId);\n}\n    }\n\n\n\n10.10.1 Telework manager\nThe TeleworkManager actor, in Code Block 10.11, schedules a weekly review of school disease mitigation strategies. Note that the scheduling is through a passive plan, which indicates to the simulation that this plan should only be executed if there are active plans still remaining. Passive plans are generally used when there is a continuing task that is not driven directly by events. When active plans cease and only passive plans remain, the simulation halts since the passive plans are not reason enough to continue time flow.\n\n\nCode Block 10.11: The telework manager initializes by scheduling a telework status review for seven days from the start of the simulation.\npublic void init(ActorContext actorContext) {\n    this.actorContext = actorContext;\n    scheduleNextReview();\n}\n\nprivate void scheduleNextReview() {\n    double planTime = actorContext.getTime() + reviewInterval;\n    Plan<ActorContext> plan = Plan.builder(ActorContext.class)//\n            .setCallbackConsumer(this::reviewTeleworkStatus)//\n            .setActive(false)//\n            .setTime(planTime)//\n            .build();\n\n    actorContext.addPlan(plan);\n}\n\n\nThe review process (Code Block 10.12) continues until a disease threshold has been reached. At that point, the telework manager randomly determines which work groups will be in telework mode. Note that there is no returning from this mode and there is no further evolution of the telework mode even after the disease wanes.\n\n\nCode Block 10.12: The telework manager schedules a review every seven days until a threshold of infections is reached. Once the threshold is achieved, work places are randomly selected to use telework until the end of the simulation.\nprivate void reviewTeleworkStatus(ActorContext actorContext) {\n    StochasticsDataManager stochasticsDataManager = actorContext.getDataManager(StochasticsDataManager.class);\n    RandomGenerator randomGenerator = stochasticsDataManager.getRandomGenerator();\n    PeopleDataManager peopleDataManager = actorContext.getDataManager(PeopleDataManager.class);\n    PersonPropertiesDataManager personPropertiesDataManager = actorContext\n            .getDataManager(PersonPropertiesDataManager.class);\n    GroupsDataManager groupsDataManager = actorContext.getDataManager(GroupsDataManager.class);\n    GlobalPropertiesDataManager globalPropertiesDataManager = actorContext\n            .getDataManager(GlobalPropertiesDataManager.class);\n    double threshold = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.TELEWORK_INFECTION_THRESHOLD);\n    double teleworkProbability = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.TELEWORK_PROBABILTY);\n\n    int infectiousCount = personPropertiesDataManager.getPersonCountForPropertyValue(PersonProperty.DISEASE_STATE,\n            DiseaseState.INFECTIOUS);\n    int populationCount = peopleDataManager.getPopulationCount();\n\n    double infectiousFraction = infectiousCount;\n    infectiousFraction /= populationCount;\n\n    if (infectiousFraction >= threshold) {\n        List<GroupId> workGroupIds = groupsDataManager.getGroupsForGroupType(GroupType.WORK);\n        for (GroupId groupId : workGroupIds) {\n            if (randomGenerator.nextDouble() < teleworkProbability) {\n                groupsDataManager.setGroupPropertyValue(groupId, GroupProperty.TELEWORK, true);\n            }\n        }\n    } else {\n        scheduleNextReview();\n    }\n}\n\n\n\n\n10.10.2 School manager\nThe SchoolManager actor (Code Block 10.13) initializes by establishing various values derived from fixed global properties and then scheduling a weekly review of all schools.\n\n\nCode Block 10.13: The school manager initializes by establishing some property constants and planning school status review for seven days after the simulation starts.\npublic void init(ActorContext actorContext) {\n    this.actorContext = actorContext;\n    personPropertiesDataManager = actorContext.getDataManager(PersonPropertiesDataManager.class);\n    groupsDataManager = actorContext.getDataManager(GroupsDataManager.class);\n    GlobalPropertiesDataManager globalPropertiesDataManager = actorContext\n            .getDataManager(GlobalPropertiesDataManager.class);\n    cohortThreshold = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.SCHOOL_COHORT_INFECTION_THRESHOLD);\n    closureThreshold = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.SCHOOL_CLOSURE_INFECTION_THRESHOLD);\n    planNextReview();\n}\n\nprivate void planNextReview() {\n    double planTime = actorContext.getTime() + reviewInterval;\n    Plan<ActorContext> plan = Plan.builder(ActorContext.class)//\n            .setCallbackConsumer(this::reviewSchools)//\n            .setActive(false)//\n            .setTime(planTime)//\n            .build();\n    actorContext.addPlan(plan);\n}\n\nprivate void reviewSchools(ActorContext actorContext) {\n    List<GroupId> schoolGroupIds = groupsDataManager.getGroupsForGroupType(GroupType.SCHOOL);\n    for (GroupId groupId : schoolGroupIds) {\n        reviewSchool(groupId);\n    }\n    planNextReview();\n}\n\n\nThe review of each school group is shown in Code Block 10.14. The fraction of the school’s students who are infectious is calculated. Depending on the current state of the group (OPEN, COHORT, CLOSED) the group may move to the next state. If the group moves from OPEN to COHORT (Code Block 10.15), a new group is formed and half of the students are moved into the new group. Both groups are then marked as COHORT groups. If the group moves from COHORT to CLOSED (Code Block 10.16), all students are removed from the group.\n\n\nCode Block 10.14: Each school is reviewed on a weekly basis. As the fraction of students who are infected increases, the school transitions from OPEN to COHORT to CLOSED.\nprivate void reviewSchool(GroupId groupId) {\n\n    int infectiousCount = 0;\n    List<PersonId> peopleForGroup = groupsDataManager.getPeopleForGroup(groupId);\n    for (PersonId personId : peopleForGroup) {\n        DiseaseState diseaseState = personPropertiesDataManager.getPersonPropertyValue(personId,\n                PersonProperty.DISEASE_STATE);\n        if (diseaseState == DiseaseState.INFECTIOUS) {\n            infectiousCount++;\n        }\n    }\n\n    double infectiousFraction = infectiousCount;\n    if (!peopleForGroup.isEmpty()) {\n        infectiousFraction /= peopleForGroup.size();\n    }\n\n    SchoolStatus schoolStatus = groupsDataManager.getGroupPropertyValue(groupId, GroupProperty.SCHOOL_STATUS);\n\n    switch (schoolStatus) {\n    case OPEN:\n        if (infectiousFraction >= cohortThreshold) {\n            splitSchoolIntoCohorts(groupId);\n        }\n        break;\n    case COHORT:\n        if (infectiousFraction >= closureThreshold) {\n            closeSchool(groupId);\n        }\n        break;\n    case CLOSED:\n        // do nothing\n        break;\n    default:\n        throw new RuntimeException(\"unhandled case \" + schoolStatus);\n    }\n}\n\n\n\n\nCode Block 10.15: When a school moves to COHORT status, a new group is added to the simulation and half of the students move to this new group.\nprivate void splitSchoolIntoCohorts(GroupId groupId) {\n    GroupConstructionInfo groupConstructionInfo = GroupConstructionInfo.builder().setGroupTypeId(GroupType.SCHOOL)\n            .build();\n    GroupId newGroupId = groupsDataManager.addGroup(groupConstructionInfo);\n\n    List<PersonId> peopleForGroup = groupsDataManager.getPeopleForGroup(groupId);\n    for (int i = 0; i < peopleForGroup.size(); i++) {\n        if (i % 2 == 0) {\n            PersonId personId = peopleForGroup.get(i);\n            groupsDataManager.removePersonFromGroup(personId, groupId);\n            groupsDataManager.addPersonToGroup(personId, newGroupId);\n        }\n    }\n\n    groupsDataManager.setGroupPropertyValue(newGroupId, GroupProperty.SCHOOL_STATUS, SchoolStatus.COHORT);\n    groupsDataManager.setGroupPropertyValue(groupId, GroupProperty.SCHOOL_STATUS, SchoolStatus.COHORT);\n\n}\n\n\n\n\nCode Block 10.16: When a school is closed, all the students are removed from the school group so that infection can no longer spread via school-based contact.\nprivate void closeSchool(GroupId groupId) {\n    groupsDataManager.setGroupPropertyValue(groupId, GroupProperty.SCHOOL_STATUS, SchoolStatus.CLOSED);\n    List<PersonId> people = groupsDataManager.getPeopleForGroup(groupId);\n    for (PersonId personId : people) {\n        groupsDataManager.removePersonFromGroup(personId, groupId);\n    }\n}\n\n\n\n\n10.10.3 Infection Manager\nThe InfectionManager actor, in Code Block 10.17, first determines various values from the fixed global properties that will be used to manage infections. The most important calculation is to determine the length of time between infectious contacts as a function of the global R0 value and the expected number of days a person will be infectious. It then selects a small set of adults to infect during first day of the simulation. Infecting a person (Code Block 10.18) first requires the manager to determine the number of days of the infection for the particular person and then schedule infectious contact times for that person. At the end of the infectious contacts the manager schedules the transition of the person from infectious to recovered.\n\n\nCode Block 10.17: The infection manager initializes by infecting the initially infected people in the first day.\npublic void init(ActorContext actorContext) {\n    this.actorContext = actorContext;\n\n    StochasticsDataManager stochasticsDataManager = actorContext.getDataManager(StochasticsDataManager.class);\n    randomGenerator = stochasticsDataManager.getRandomGenerator();\n    Random random = new Random(randomGenerator.nextLong());\n\n    groupsDataManager = actorContext.getDataManager(GroupsDataManager.class);\n    GlobalPropertiesDataManager globalPropertiesDataManager = actorContext\n            .getDataManager(GlobalPropertiesDataManager.class);\n    personPropertiesDataManager = actorContext.getDataManager(PersonPropertiesDataManager.class);\n    List<PersonId> susceptiblePeople = personPropertiesDataManager\n            .getPeopleWithPropertyValue(PersonProperty.DISEASE_STATE, DiseaseState.SUSCEPTIBLE);\n    List<PersonId> susceptibleAdults = new ArrayList<>();\n    for (PersonId personId : susceptiblePeople) {\n        int age = personPropertiesDataManager.getPersonPropertyValue(personId, PersonProperty.AGE);\n        if (age > 18) {\n            susceptibleAdults.add(personId);\n        }\n    }\n\n    Collections.shuffle(susceptibleAdults, random);\n\n    minInfectiousPeriod = globalPropertiesDataManager.getGlobalPropertyValue(GlobalProperty.MIN_INFECTIOUS_PERIOD);\n    maxInfectiousPeriod = globalPropertiesDataManager.getGlobalPropertyValue(GlobalProperty.MAX_INFECTIOUS_PERIOD);\n    double r0 = globalPropertiesDataManager.getGlobalPropertyValue(GlobalProperty.R0);\n    infectionInterval = (double) (minInfectiousPeriod + maxInfectiousPeriod) / (2 * r0);\n\n    int initialInfections = globalPropertiesDataManager.getGlobalPropertyValue(GlobalProperty.INITIAL_INFECTIONS);\n    initialInfections = FastMath.min(initialInfections, susceptibleAdults.size());\n\n    for (int i = 0; i < initialInfections; i++) {\n        PersonId personId = susceptibleAdults.get(i);\n        double planTime = randomGenerator.nextDouble() * 0.5 + 0.25;\n        actorContext.addPlan((c) -> infectPerson(personId), planTime);\n    }\n}\n\n\n\n\nCode Block 10.18: When a person is infected, the number of possible infectious contacts is determined and planned. After the last infectious contact, the person is scheduled to become recovered.\nprivate void infectPerson(PersonId personId) {\n    personPropertiesDataManager.setPersonPropertyValue(personId, PersonProperty.DISEASE_STATE,\n            DiseaseState.INFECTIOUS);\n    int infectiousDays = randomGenerator.nextInt(maxInfectiousPeriod - minInfectiousPeriod) + minInfectiousPeriod;\n    int infectionCount = (int) FastMath.round(((double) infectiousDays / infectionInterval));\n    double planTime = actorContext.getTime();\n    for (int j = 0; j < infectionCount; j++) {\n        planTime += infectionInterval;\n        actorContext.addPlan((c) -> infectContact(personId), planTime);\n    }\n    actorContext.addPlan((c) -> endInfectiousness(personId), planTime);\n}\n\n\nAn infectious contact , Code Block 10.19, first selects a group at random from the person’s groups. A person to infect is selected from the group, excluding the person who is infecting. If such a person can be found and that person is susceptible then, barring mitigation, the susceptible person becomes infected and is immediately infectious. Cohort schools are mitigated by 50% and closed schools are 100% mitigated. Telework groups are mitigated by 50%.\n\n\nCode Block 10.19: The infection manager attempts to infect a susceptible person found in a randomly selected group associated with the currently infected person.\nprivate void infectContact(PersonId personId) {\n    List<GroupId> groupsForPerson = groupsDataManager.getGroupsForPerson(personId);\n    GroupId groupId = groupsForPerson.get(randomGenerator.nextInt(groupsForPerson.size()));\n\n    // work groups doing telework have a 50% contact mitigation\n    GroupTypeId groupTypeId = groupsDataManager.getGroupType(groupId);\n    if (groupTypeId.equals(GroupType.WORK)) {\n        boolean teleworkGroup = groupsDataManager.getGroupPropertyValue(groupId, GroupProperty.TELEWORK);\n        if (teleworkGroup) {\n            if (randomGenerator.nextBoolean()) {\n                return;\n            }\n        }\n    }\n\n    // school groups in COHORT mode have a 50% contact mitigation\n    // school groups in CLOSED mode have a 100% contact mitigation\n    if (groupTypeId.equals(GroupType.SCHOOL)) {\n        SchoolStatus schoolStatus = groupsDataManager.getGroupPropertyValue(groupId, GroupProperty.SCHOOL_STATUS);\n        switch (schoolStatus) {\n        case COHORT:\n            if (randomGenerator.nextBoolean()) {\n                return;\n            }\n            break;\n        case CLOSED:\n            return;\n        default:\n            // no mitigation\n            break;\n        }\n    }\n\n    GroupSampler groupSampler = GroupSampler.builder().setExcludedPersonId(personId).build();\n    Optional<PersonId> optional = groupsDataManager.sampleGroup(groupId, groupSampler);\n    if (optional.isPresent()) {\n        PersonId contactedPerson = optional.get();\n        DiseaseState diseaseState = personPropertiesDataManager.getPersonPropertyValue(contactedPerson,\n                PersonProperty.DISEASE_STATE);\n        if (diseaseState == DiseaseState.SUSCEPTIBLE) {\n            int infectedCount = personPropertiesDataManager.getPersonPropertyValue(personId,\n                    PersonProperty.INFECTED_COUNT);\n            infectedCount++;\n            personPropertiesDataManager.setPersonPropertyValue(personId, PersonProperty.INFECTED_COUNT,\n                    infectedCount);\n            infectPerson(contactedPerson);\n        }\n    }\n}\n\n\n\n\n10.10.4 Inspecting the output\n\n\n10.10.5 Person Property Report\nThe 36 scenarios result in a large amount of output in the person property report. It is effectively a trace log of the initial state and changes to each person.\n\n\n10.10.6 Group Population Report\nThe group population report shows the distribution of people at the end of the simulation. Since there is no stochastics dimension, each scenario has an identical distribution of people into homes. The report shows all the expected patterns as a response to initial policies. For example, higher school closure infection thresholds drive the ending school populations to less than 1/3 their initial values.\n\n\n10.10.7 Disease State Report\nThe disease state report shows the ending counts for each disease state. By analyzing the number of people recovered over the 36 scenarios, we observe that the disease threshold for triggering work places into a telework status is significant. If that threshold is set to 10%, the working population does not telework and the number of recovered is significantly higher that at the lower levels. School cohort and closure policies exhibit a similar pattern.\n\n\n10.10.8 Contagion Report\nThe contagion report shows then number of people infected by each infectious person as counts. The report shows that early decisions to close schools and institute telework policies can significantly reduce the spread of the disease."
  },
  {
    "objectID": "ch11-ResourcesPlugin.html#plugin-data-initialization",
    "href": "ch11-ResourcesPlugin.html#plugin-data-initialization",
    "title": "11  Resources Plugin",
    "section": "11.1 Plugin Data Initialization",
    "text": "11.1 Plugin Data Initialization\nThe plugin is initialized using a ResourcesPluginData object that:\n\nDefines resource ids\nDefines resource properties\nCollects resource property values\nSets initial resource amounts for regions\nSets initial resource amounts for people"
  },
  {
    "objectID": "ch11-ResourcesPlugin.html#plugin-behavior",
    "href": "ch11-ResourcesPlugin.html#plugin-behavior",
    "title": "11  Resources Plugin",
    "section": "11.2 Plugin Behavior",
    "text": "11.2 Plugin Behavior\nThe plugin adds a single data manager to the simulation as an instance of the ResourcesDataManager that is initialized with the ResourcesPluginData."
  },
  {
    "objectID": "ch11-ResourcesPlugin.html#data-manager",
    "href": "ch11-ResourcesPlugin.html#data-manager",
    "title": "11  Resources Plugin",
    "section": "11.3 Data Manager",
    "text": "11.3 Data Manager\nThe data manager manages person and region inventories of resources as well as any properties associated with resources.  The data manager provides public methods that:\n\nAdd a new resource id, thus defining a new resource type\nDefine a resource property\nAdd resource amounts to regions\nRemove resource amounts from regions\nTransfer resource amounts between regions\nTransfer resource amounts between regions and people\nRemove resource amounts from people\nAnswer various questions about:\n\nPeople who have or do not have a particular resource\nResource levels for people and regions\nProperty values, definitions, resource id values, etc.\n\n\nThe data manager also produces observable events:\n\nPersonResourceUpdateEvent – when a person has a change in a resource level\nRegionResourceUpdateEvent – when a region has a change in a resource level\nResourceIdAdditionEvent – when a new resource id is added\nResourcePropertyDefinitionEvent – when a new resource property definition is added\nResourcePropertyUpdateEvent – when a resource property value is assigned"
  },
  {
    "objectID": "ch11-ResourcesPlugin.html#example-code-lesson-18",
    "href": "ch11-ResourcesPlugin.html#example-code-lesson-18",
    "title": "11  Resources Plugin",
    "section": "11.4 Example Code (Lesson 18)",
    "text": "11.4 Example Code (Lesson 18)\nExample_18.java shows the use of the resources plugin. In it we will examine:\n\nThe initialization of the resource properties plugin\nThe flow of resources between regions and people\nThe observation of resource events\n\nThe example includes seven plugins:\n\nResources plugin – (GCM core plugin) used to manage resources\nPeople plugin – (GCM core plugin) used to manage people\nPerson properties plugin– (GCM core plugin) used to decorate properties onto people\nGlobal properties plugin– (GCM core plugin) used to store policies and initial conditions affecting resource use\nStochastics plugin – (GCM core plugin) used to generate random numbers used in various decisions\nRegions Plugin– (GCM core plugin) used for resource flow\nModel plugin – (local plugin) used to introduce three actors that will:\n\nLoad the population\nDistribute resources to regions\nManage the treatment of disease utilizing resources"
  },
  {
    "objectID": "ch11-ResourcesPlugin.html#model",
    "href": "ch11-ResourcesPlugin.html#model",
    "title": "11  Resources Plugin",
    "section": "11.5 Model",
    "text": "11.5 Model\nThe example’s model represents a disease that is treatable through antiviral medication and hospitalization. People at the start of the simulation are either immune or susceptible and all susceptible people are exposed and infected at random times over a given period. There is no transmission modeling. Initial treatment is with a single dose of an antiviral drug, if it is available. If the antiviral drug is not available or the drug is not effective, the person is hospitalized. If there are no hospital beds are available, the person dies. After a course of treatment in the hospital, the person is either immune or dead. Previous treatment with the antiviral alters the outcome probabilities of the hospital stay. Upon the person’s release from the hospital, the hospital bed is returned to the person’s region. Questionnaires are sent to people who have been successfully treated."
  },
  {
    "objectID": "ch11-ResourcesPlugin.html#model-execution",
    "href": "ch11-ResourcesPlugin.html#model-execution",
    "title": "11  Resources Plugin",
    "section": "11.6 Model Execution",
    "text": "11.6 Model Execution\nThe example’s execution is shown in Code Block 11.1 and Code Block 11.2.\n\n\nCode Block 11.1: Executing example 18 with an output directory.\npublic static void main(String[] args) throws IOException {\n    if (args.length == 0) {\n        throw new RuntimeException(\"One output directory argument is required\");\n    }\n    Path outputDirectory = Paths.get(args[0]);\n    if (!Files.exists(outputDirectory)) {\n        Files.createDirectory(outputDirectory);\n    } else {\n        if (!Files.isDirectory(outputDirectory)) {\n            throw new IOException(\"Provided path is not a directory\");\n        }\n    }\n\n    new Example_18(outputDirectory).execute();\n}\n\n\n\n\nCode Block 11.2: The various plugins are gathered from their initial data, dimensions are added and the experiment is executed over 864 scenarios using 8 threads.\nprivate void execute() {\n\n    ExperimentParameterData experimentParameterData = ExperimentParameterData.builder()//\n            .setThreadCount(8)//\n            .build();\n\n    Experiment.builder()\n\n            .addPlugin(getResourcesPlugin())//\n            .addPlugin(getGlobalPropertiesPlugin())//\n            .addPlugin(getPersonPropertiesPlugin())//\n            .addPlugin(getRegionsPlugin())//\n            .addPlugin(getPeoplePlugin())//\n            .addPlugin(getStochasticsPlugin())//\n            .addPlugin(ModelPlugin.getModelPlugin())//\n\n            .addDimension(getMaximumSymptomOnsetTimeDimension())//\n            .addDimension(getSusceptiblePopulationProportionDimension())//\n            .addDimension(getAntiviralCoverageTimeDimension())//\n            .addDimension(getAntiviralSuccessRateDimension())//\n            .addDimension(getHospitalSuccessDimension())//\n            .addDimension(getHospitalBedsPerPersonDimension())//\n            .addDimension(getAntiviralDosesPerPersonDimension())//\n            .addDimension(getHospitalStayDurationDimension())//\n\n            .addExperimentContextConsumer(getNIOReportItemHandler())//\n            .setExperimentParameterData(experimentParameterData)//\n            .build()//\n            .execute();//\n}\n\n\nThe first action is to add the resources plugin (Code Block 11.3, Code Block 11.4). Only the resource id values contained in the Resource enumeration are added to the plugin’s data. Region and person initial resource levels can also be added, but we will instead initialize them via an actor in the model plugin.\n\n\nCode Block 11.3: Resource ids are implemented as an enumeration.\npublic enum Resource implements ResourceId {\n    ANTI_VIRAL_MED, HOSPITAL_BED;\n}\n\n\n\n\nCode Block 11.4: The resource plugin is initialized with defining the two resource ids at time zero with time tracking turned on. The person resource report is set to report at the end of the simulation.\nprivate Plugin getResourcesPlugin() {\n    ResourcesPluginData.Builder builder = ResourcesPluginData.builder();\n    for (ResourceId resourceId : Resource.values()) {\n        builder.addResource(resourceId, 0.0, true);\n    }\n    ResourcesPluginData resourcesPluginData = builder.build();\n\n    PersonResourceReportPluginData personResourceReportPluginData = PersonResourceReportPluginData//\n            .builder()//\n            .setReportLabel(ModelReportLabel.PERSON_RESOURCE_REPORT)//\n            .setReportPeriod(ReportPeriod.END_OF_SIMULATION)//\n            .build();\n\n    return ResourcesPlugin.builder()//\n            .setResourcesPluginData(resourcesPluginData)//\n            .setPersonResourceReportPluginData(personResourceReportPluginData)//\n            .getResourcesPlugin();//\n}\n\n\nThe next action is to load the global properties plugin (Code Block 11.5).  All of the global properties are marked as immutable since they will not change over the course of the simulation.  Further, most of the properties will participate in the dimensions of the experiment, so we can set the default values to zero.\n\nSUSCEPTIBLE_POPULATION_PROPORTION – The fraction of the population that is susceptible\nMAXIMUM_SYMPTOM_ONSET_TIME – The last time where any person will have onset of symptoms\nANTIVIRAL_COVERAGE_TIME – The amount of time for the antiviral to be effective\nANTIVIRAL_SUCCESS_RATE – The probability that the antiviral will be effective\nHOSPITAL_SUCCESS_WITH_ANTIVIRAL – The probability that hospital treatment will be effective for people who previously had antiviral treatment\nHOSPITAL_SUCCESS_WITHOUT_ANTIVIRAL – The probability that hospital treatment will be effective for people who previously had no antiviral treatment\nHOSPITAL_STAY_DURATION_MIN –  The minimum duration of a hospital stay\nHOSPITAL_STAY_DURATION_MAX – The maximum duration of a hospital stay\nPOPULATION_SIZE – The number of people across all regions.  Regions will not be uniformly populated.\nHOSPITAL_BEDS_PER_PERSON – The number of hospital beds per person on average stored in the regions.\nANTIVIRAL_DOSES_PER_PERSON – The number of antiviral doses per person on average stored in the regions.\n\n\n\nCode Block 11.5: The global properties plugin is initialized with several properties.\nprivate Plugin getGlobalPropertiesPlugin() {\n    GlobalPropertiesPluginData.Builder builder = GlobalPropertiesPluginData.builder();//\n\n    PropertyDefinition propertyDefinition = PropertyDefinition.builder()//\n            .setType(Double.class)//\n            .setDefaultValue(0.0)//\n            .setPropertyValueMutability(false)//\n            .build();\n\n    builder.defineGlobalProperty(GlobalProperty.SUSCEPTIBLE_POPULATION_PROPORTION, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.MAXIMUM_SYMPTOM_ONSET_TIME, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.ANTIVIRAL_COVERAGE_TIME, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.ANTIVIRAL_SUCCESS_RATE, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.HOSPITAL_SUCCESS_WITH_ANTIVIRAL, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.HOSPITAL_SUCCESS_WITHOUT_ANTIVIRAL, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.HOSPITAL_BEDS_PER_PERSON, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.ANTIVIRAL_DOSES_PER_PERSON, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.HOSPITAL_STAY_DURATION_MIN, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.HOSPITAL_STAY_DURATION_MAX, propertyDefinition, 0);\n\n    propertyDefinition = PropertyDefinition.builder()//\n            .setType(Integer.class)//\n            .setDefaultValue(10000)//\n            .setPropertyValueMutability(false)//\n            .build();\n\n    builder.defineGlobalProperty(GlobalProperty.POPULATION_SIZE, propertyDefinition, 0);\n\n    GlobalPropertiesPluginData globalPropertiesPluginData = builder.build();\n\n    return GlobalPropertiesPlugin.builder().setGlobalPropertiesPluginData(globalPropertiesPluginData)\n            .getGlobalPropertiesPlugin();\n}\n\n\nThe person properties plugin is loaded (Code Block 11.6).  All person properties are Boolean values and defaulted to false. \n\nIMMUNE – The person is immune\nINFECTED – The person is infected\nTREATED_WITH_ANTIVIRAL – The person received antiviral treatment\nHOSPITALIZED – The person received hospital treatment\nDEAD_IN_HOSPITAL – The person dies in the hospital\nDEAD_IN_HOME – The person dies in the home\nRECEIVED_QUESTIONNAIRE – An infected person who successfully completes treatment receives a questionnaire\n\n\n\nCode Block 11.6: The person properties plugin is initialized with several properties.\nprivate Plugin getPersonPropertiesPlugin() {\n\n    PersonPropertiesPluginData.Builder builder = PersonPropertiesPluginData.builder();\n\n    PropertyDefinition propertyDefinition = PropertyDefinition.builder()//\n            .setType(Boolean.class)//\n            .setDefaultValue(false)//\n            .build();\n\n    builder.definePersonProperty(PersonProperty.IMMUNE, propertyDefinition, 0, false);//\n    builder.definePersonProperty(PersonProperty.INFECTED, propertyDefinition, 0, false);//\n    builder.definePersonProperty(PersonProperty.HOSPITALIZED, propertyDefinition, 0, false);//\n    builder.definePersonProperty(PersonProperty.TREATED_WITH_ANTIVIRAL, propertyDefinition, 0, false);//\n    builder.definePersonProperty(PersonProperty.DEAD_IN_HOME, propertyDefinition, 0, false);//\n    builder.definePersonProperty(PersonProperty.DEAD_IN_HOSPITAL, propertyDefinition, 0, false);//\n\n    propertyDefinition = PropertyDefinition.builder()//\n            .setType(Boolean.class)//\n            .setDefaultValue(false)//\n            .build();\n    builder.definePersonProperty(PersonProperty.RECEIVED_QUESTIONNAIRE, propertyDefinition, 0, true);//\n\n    PersonPropertiesPluginData personPropertiesPluginData = builder.build();\n\n    return PersonPropertiesPlugin.builder().setPersonPropertiesPluginData(personPropertiesPluginData)\n            .getPersonPropertyPlugin();\n}\n\n\nThe are four reports:\n\nPersonResourceReport – Shows resource allocations by day and region.  Resources are possessed by a person during the course of treatment.\nTreatmentReport – Shows a summary of all person property value combinations at the end of the simulation\nDeathReport – Shows absolute and per capita death rate per region\nQuestionnaireReport – Shows statistics on the distribution of questionnaires\n\nThe stochastic plugin is initialized with a random seed and all simulations will start in the same stochastic state.  The Regions plugin has five regions and the people plugin is loaded in an empty state.  People are added by an actor in the model plugin.\nThe model plugin adds three actors\n\nPopulationLoader – Adds people to the simulation and initializes immunity\nResourceLoader – Initializes resources for regions. People have no allocated resources.\nTreatmentManager – Moves people through treatment states"
  },
  {
    "objectID": "ch11-ResourcesPlugin.html#experiment-dimensions",
    "href": "ch11-ResourcesPlugin.html#experiment-dimensions",
    "title": "11  Resources Plugin",
    "section": "11.7 Experiment dimensions",
    "text": "11.7 Experiment dimensions\nEight dimensions are added to the experiment that define alternate values for ten of the eleven global properties resulting in 864 scenarios. Only population size is fixed and is set to 10,000.  The values are:\n\nMax Symptom onset – 60 and 120 days\nSusceptibility – 25, 50 and 75 percent\nAntiviral treatment duration – 10 and 15 days\nAntiviral treatment success – 50 and 80 percent\nHospital success rate with and without antivirals\n\n75 and 50 percent\n50 and 30 percent\n\nHospital beds per capita – 1, 3 and 5 per thousand\nAntiviral doses per capita – 0.1, 0.2 and 0.5\nHospital stay\n\n2 to 5 days\n5 to 10 days"
  },
  {
    "objectID": "ch11-ResourcesPlugin.html#the-actors",
    "href": "ch11-ResourcesPlugin.html#the-actors",
    "title": "11  Resources Plugin",
    "section": "11.8 The actors",
    "text": "11.8 The actors\nWe will finish this chapter by reviewing the three actors of the model plugin and then examine the output.\n\n11.8.1 Population Loader\nThe PopulationLoader actor, in Code Block 11.7, adds people to the simulation based on the number in the POPULATION_SIZE global property.  Each person is assigned a random region and the person property, IMMUNE, is randomly assigned based on the SUSCEPTIBLE_POPULATION_PROPORTION global property. The selection of regions, although random, is designed to ensure that regions have different population sizes so that each region may have unique output statistics.\n\n\nCode Block 11.7: The population loader initializes the population by assigning to each person a randomly selected region id and immunity status.\npublic void init(ActorContext actorContext) {\n\n    StochasticsDataManager stochasticsDataManager = actorContext.getDataManager(StochasticsDataManager.class);\n    randomGenerator = stochasticsDataManager.getRandomGenerator();\n    PeopleDataManager peopleDataManager = actorContext.getDataManager(PeopleDataManager.class);\n    GlobalPropertiesDataManager globalPropertiesDataManager = actorContext\n            .getDataManager(GlobalPropertiesDataManager.class);\n    regionsDataManager = actorContext.getDataManager(RegionsDataManager.class);\n\n    int populationSize = globalPropertiesDataManager.getGlobalPropertyValue(GlobalProperty.POPULATION_SIZE);\n    double susceptibleProbability = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.SUSCEPTIBLE_POPULATION_PROPORTION);\n    double immuneProbabilty = 1 - susceptibleProbability;\n\n    /*\n         * Derive mapping from region to probability that a person will be assigned to\n         * that region that will likely not put the same number of people in each\n         * region.\n         */\n    buildUnbalancedRegions();\n\n    /*\n         * Add each person to the simulation. Determine their region id and the immune\n         * state. The other person properties will have default values.\n         */\n    for (int i = 0; i < populationSize; i++) {\n        RegionId regionId = getRandomRegionId();\n        boolean immune = randomGenerator.nextDouble() < immuneProbabilty;\n        PersonPropertyValueInitialization personPropertyInitialization = new PersonPropertyValueInitialization(\n                PersonProperty.IMMUNE, immune);\n        PersonConstructionData personConstructionData = PersonConstructionData.builder()//\n                .add(personPropertyInitialization)//\n                .add(regionId)//\n                .build();\n        peopleDataManager.addPerson(personConstructionData);\n    }\n}\n\n\n\n\n11.8.2 Resource Loader\nThe ResourceLoader actor, in Code Block 11.8, determines the number of antiviral doses and hospital beds for each region.  Note that each region receives the same amounts, but that the regions will have very different population sizes.\n\n\nCode Block 11.8: The resource loader initializes the anti-viral medication doses and hospital beds for each region.\npublic void init(ActorContext actorContext) {\n\n    RegionsDataManager regionsDataManager = actorContext.getDataManager(RegionsDataManager.class);\n    ResourcesDataManager resourcesDataManager = actorContext.getDataManager(ResourcesDataManager.class);\n    GlobalPropertiesDataManager globalPropertiesDataManager = actorContext\n            .getDataManager(GlobalPropertiesDataManager.class);\n    int populationSize = globalPropertiesDataManager.getGlobalPropertyValue(GlobalProperty.POPULATION_SIZE);\n    Set<RegionId> regionIds = regionsDataManager.getRegionIds();\n\n    double dosesPerPerson = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.ANTIVIRAL_DOSES_PER_PERSON);\n\n    double totalDoses = dosesPerPerson * populationSize;\n    int doseCount = (int) totalDoses;\n    int doseCountPerRegion = doseCount / regionIds.size();\n\n    double bedsPerPerson = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.HOSPITAL_BEDS_PER_PERSON);\n\n    double totalBeds = bedsPerPerson * populationSize;\n    int bedCount = (int) totalBeds;\n    int bedCountPerRegion = bedCount / regionIds.size();\n\n    for (RegionId regionId : regionIds) {\n        resourcesDataManager.addResourceToRegion(Resource.ANTI_VIRAL_MED, regionId, doseCountPerRegion);\n        resourcesDataManager.addResourceToRegion(Resource.HOSPITAL_BED, regionId, bedCountPerRegion);\n    }\n}\n\n\n\n\n11.8.3 Treatment Manager\nThe TreatmentManager actor, in Code Block 11.9, initializes by first deriving several values from the global properties plugin that will be useful as it manages people. It then gets from the person properties manager a list of all people who are not currently immune and marks them as infected.  It further determines for each person when they will become symptomatic and schedules the allocation of the antiviral resource.  \n\n\nCode Block 11.9: The treatment manager establishes various constants and infects all non-immune people, scheduling them for anti-viral treatment.\npublic void init(ActorContext actorContext) {\n    this.actorContext = actorContext;\n    regionsDataManager = actorContext.getDataManager(RegionsDataManager.class);\n    resourcesDataManager = actorContext.getDataManager(ResourcesDataManager.class);\n    StochasticsDataManager stochasticsDataManager = actorContext.getDataManager(StochasticsDataManager.class);\n    randomGenerator = stochasticsDataManager.getRandomGenerator();\n    personPropertiesDataManager = actorContext.getDataManager(PersonPropertiesDataManager.class);\n    GlobalPropertiesDataManager globalPropertiesDataManager = actorContext\n            .getDataManager(GlobalPropertiesDataManager.class);\n\n    double maximumSymptomOnsetTime = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.MAXIMUM_SYMPTOM_ONSET_TIME);\n    antiviralCoverageTime = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.ANTIVIRAL_COVERAGE_TIME);\n    antiviralSuccessRate = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.ANTIVIRAL_SUCCESS_RATE);\n    hospitalSuccessWithAntiviral = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.HOSPITAL_SUCCESS_WITH_ANTIVIRAL);\n    hospitalSuccessWithoutAntiviral = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.HOSPITAL_SUCCESS_WITHOUT_ANTIVIRAL);\n    hospitalStayDurationMin = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.HOSPITAL_STAY_DURATION_MIN);\n    hospitalStayDurationMax = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.HOSPITAL_STAY_DURATION_MAX);\n\n    List<PersonId> susceptiblePeople = personPropertiesDataManager.getPeopleWithPropertyValue(PersonProperty.IMMUNE,\n            false);\n    for (PersonId personId : susceptiblePeople) {\n        double symptomOnsetTime = randomGenerator.nextDouble() * maximumSymptomOnsetTime;\n        personPropertiesDataManager.setPersonPropertyValue(personId, PersonProperty.INFECTED, true);\n\n        actorContext.addPlan((c) -> treatWithAntiviral(personId), symptomOnsetTime);\n    }\n}\n\n\nWhen a person becomes symptomatic (Code Block 11.10), the treatment manager attempts to find a single dose of the antiviral medication for them.   The dose must come from the region associated with the person.  If the dose is available, the person is treated and a review of the effectiveness of the treatment is scheduled.  If no dose is available, the person is immediately sent to hospital treatment. \n\n\nCode Block 11.10: The treatment manager attempts to treat an infected person with anti-viral medication, if it is available. If no dose is available, the person is immediately hospitalized.\nprivate void treatWithAntiviral(PersonId personId) {\n\n    RegionId regionId = regionsDataManager.getPersonRegion(personId);\n\n    long regionResourceLevel = resourcesDataManager.getRegionResourceLevel(regionId, Resource.ANTI_VIRAL_MED);\n\n    if (regionResourceLevel > 0) {\n        resourcesDataManager.transferResourceToPersonFromRegion(Resource.ANTI_VIRAL_MED, personId, 1L);\n\n        personPropertiesDataManager.setPersonPropertyValue(personId, PersonProperty.TREATED_WITH_ANTIVIRAL, true);\n\n        actorContext.addPlan((c) -> assessAntiviralTreatment(personId),\n                actorContext.getTime() + antiviralCoverageTime);\n    } else {\n        hospitalizePerson(personId);\n    }\n}\n\n\nTo assess the effectiveness of the antiviral treatment (Code Block 11.11), the treatment manager randomly makes a determination based on the global property settings.  If the treatment is successful, then the person is marked as immune. Otherwise, the person is immediately sent to hospital treatment.\n\n\nCode Block 11.11: The treatment manager assesses the success of the anti-viral treatment of a person and expends the medication. If the treatment was unsuccessful the person is immediately hospitalized.\nprivate void assessAntiviralTreatment(PersonId personId) {\n\n    resourcesDataManager.removeResourceFromPerson(Resource.ANTI_VIRAL_MED, personId, 1L);\n    if (randomGenerator.nextDouble() < antiviralSuccessRate) {\n        personPropertiesDataManager.setPersonPropertyValue(personId, PersonProperty.IMMUNE, true);\n    } else {\n        hospitalizePerson(personId);\n    }\n}\n\n\nHospitalization starts (Code Block 11.12) by finding an available hospital bed for the person from the person’s current region.  If one is available, it is assigned to the person and a review of the effectiveness of the hospital treatment is scheduled for a random time based on the min and max hospital treatment durations.  If no hospital bed is available, then the person dies.\n\n\nCode Block 11.12: The treatment manager attempts to find a hospital bed for a person who has not been treated or for whom treatment failed. If no hospital bed is available, the person is set to die in their home.\nprivate void hospitalizePerson(PersonId personId) {\n    RegionId regionId = regionsDataManager.getPersonRegion(personId);\n\n    long availableHospitalBeds = resourcesDataManager.getRegionResourceLevel(regionId, Resource.HOSPITAL_BED);\n\n    if (availableHospitalBeds > 0) {\n        resourcesDataManager.transferResourceToPersonFromRegion(Resource.HOSPITAL_BED, personId, 1L);\n\n        personPropertiesDataManager.setPersonPropertyValue(personId, PersonProperty.HOSPITALIZED, true);\n\n        double hospitalizationDuration = (hospitalStayDurationMax - hospitalStayDurationMin)\n                * randomGenerator.nextDouble() + hospitalStayDurationMin;\n\n        actorContext.addPlan((c) -> assessHospitalization(personId),\n                actorContext.getTime() + hospitalizationDuration);\n    } else {\n        personPropertiesDataManager.setPersonPropertyValue(personId, PersonProperty.DEAD_IN_HOME, true);\n    }\n}\n\n\nReviewing the effectiveness of the hospital treatment is shown in Code Block 11.13.  The outcome depends the previous treatment of the person with the antiviral medication.  If the treatment is successful, then the person is marked immune.  Otherwise, the person dies. The hospital bed resource is returned to the person’s region either way.\n\n\nCode Block 11.13: The treatment manager determines whether the hospitalization was a success taking into account whether the person received an antiviral treatment before entering the hospital. If the treatment was successful then the person is marked as immune. Otherwise, the person is marked as a hospital death.\nprivate void assessHospitalization(PersonId personId) {\n\n    boolean treatedWithAntiViral = personPropertiesDataManager.getPersonPropertyValue(personId,\n            PersonProperty.TREATED_WITH_ANTIVIRAL);\n    double probabilityOfSuccess;\n    if (treatedWithAntiViral) {\n        probabilityOfSuccess = hospitalSuccessWithAntiviral;\n    } else {\n        probabilityOfSuccess = hospitalSuccessWithoutAntiviral;\n    }\n    if (randomGenerator.nextDouble() < probabilityOfSuccess) {\n        personPropertiesDataManager.setPersonPropertyValue(personId, PersonProperty.IMMUNE, true);\n    } else {\n        personPropertiesDataManager.setPersonPropertyValue(personId, PersonProperty.DEAD_IN_HOSPITAL, true);\n    }\n    resourcesDataManager.transferResourceFromPersonToRegion(Resource.HOSPITAL_BED, personId, 1L);\n}\n\n\n\n\n11.8.4 Questionnaire Manager\nThe QuestionnaireManager actor, in Code Block 11.14, initializes by subscribing to changes to the number of antivirals or hospital beds possessed by people.\n\n\nCode Block 11.14: The questionnaire distributor initializes by subscribing to anti-viral and hospital bed person resource updates.\npublic void init(ActorContext actorContext) {\n    ResourcesDataManager resourcesDataManager = actorContext.getDataManager(ResourcesDataManager.class);\n    personPropertiesDataManager = actorContext.getDataManager(PersonPropertiesDataManager.class);\n\n    EventFilter<PersonResourceUpdateEvent> eventFilter = resourcesDataManager\n            .getEventFilterForPersonResourceUpdateEvent(Resource.ANTI_VIRAL_MED);\n    actorContext.subscribe(eventFilter, this::handleAntiViralDistribution);\n\n    eventFilter = resourcesDataManager.getEventFilterForPersonResourceUpdateEvent(Resource.HOSPITAL_BED);\n    actorContext.subscribe(eventFilter, this::handleHospitalBedDistribution);\n\n}\n\n\nUpon observing a change in the number of antivirals assigned to a person (Code Block 11.15), the questionnaire manager distributes the questionnaire to the person if that person has just ended antiviral treatment (their level is now zero) but has not been hospitalized.\n\n\nCode Block 11.15: The questionnaire distributor distributes a questionnaire to each person who ends their anti-viral treatment and is not also hospitalized.\nprivate void handleAntiViralDistribution(ActorContext actorContext,\n        PersonResourceUpdateEvent personResourceUpdateEvent) {\n    PersonId personId = personResourceUpdateEvent.personId();\n    boolean hasAntiviral = personResourceUpdateEvent.currentResourceLevel() > 0;\n    if (!hasAntiviral) {\n        boolean hospitalized = personPropertiesDataManager.getPersonPropertyValue(personId,\n                PersonProperty.HOSPITALIZED);\n        if (!hospitalized) {\n            distributeQuestionaire(personId);\n        }\n    }\n}\n\n\nFor those who receive treatment at a hospital (Code Block 11.16), questionnaire manager distributes the questionnaire to the them when their hospital bed is returned and they have not died.\n\n\nCode Block 11.16: The questionnaire distributor distributes a questionnaire to each person that leaves the hospital.\nprivate void handleHospitalBedDistribution(ActorContext actorContext,\n        PersonResourceUpdateEvent personResourceUpdateEvent) {\n    PersonId personId = personResourceUpdateEvent.personId();\n    boolean hasBed = personResourceUpdateEvent.currentResourceLevel() > 0;\n    boolean dead = personIsDead(personId);\n    if (!hasBed && !dead) {\n        distributeQuestionaire(personId);\n    }\n}"
  },
  {
    "objectID": "ch11-ResourcesPlugin.html#inspecting-the-output",
    "href": "ch11-ResourcesPlugin.html#inspecting-the-output",
    "title": "11  Resources Plugin",
    "section": "11.9 Inspecting the output",
    "text": "11.9 Inspecting the output\n\n11.9.1 person resource report\nThe 864 scenarios result in a large amount of output in the person resource report.  The example code has this report set to only record the end state of the simulation, where all resources have either been expended or returned back to the regions.  Running the report in daily mode will produce over 900,000 data rows, but will show a more useful result. \n\n\n11.9.2 treatment report\nThe treatment report shows for each scenario the number or people matching any particular set of person property values at the end of the simulation.  Since there are six person properties and they are all Boolean valued, there are potentially 64 possible tuples.  However, some tuples are impossible since a person cannot be both immune and dead, etc.  The result is 6,240 rows of data for the 864 scenarios.\n\n\n11.9.3 death report\nThe death report summarizes the treatment report and calculates per capita death rates for each region.  Due to the uneven distribution of resources between the regions based on their populations, the per capita deaths vary between 0.25 and 75 percent.  The trends in the data match expectations with deaths being driven by earlier onset of symptoms, longer hospital stays, and lower effectiveness of both treatment capabilities.\n\n\n11.9.4 questionnaire report\nThe questionnaire report shows the proportion of infected people that received the questionnaire. It also shows the mean and standard deviation of the delivery times of those questionnaires."
  },
  {
    "objectID": "ch12-MaterialsPlugin.html#plugin-data-initialization",
    "href": "ch12-MaterialsPlugin.html#plugin-data-initialization",
    "title": "12  Materials Plugin",
    "section": "12.1 Plugin Data Initialization",
    "text": "12.1 Plugin Data Initialization\nThe plugin is initialized using a MaterialsPluginData object that:\n\nContains material producer ids\nDefines materials producer properties\nSets materials producer property values\nSets materials producer initial resource levels\nInitializes stage and batches in initial inventory\nDefines batch property properties\nSets initial batch property values"
  },
  {
    "objectID": "ch12-MaterialsPlugin.html#plugin-behavior",
    "href": "ch12-MaterialsPlugin.html#plugin-behavior",
    "title": "12  Materials Plugin",
    "section": "12.2 Plugin Behavior",
    "text": "12.2 Plugin Behavior\nThe plugin adds a single data manager to the simulation as an instance of the MaterialsDataManager that is initialized with the MaterialsPluginData."
  },
  {
    "objectID": "ch12-MaterialsPlugin.html#data-manager",
    "href": "ch12-MaterialsPlugin.html#data-manager",
    "title": "12  Materials Plugin",
    "section": "12.3 Data Manager",
    "text": "12.3 Data Manager\nThe data manager manages the batch and stage inventories of the materials producers as well as managing the relevant property values and material transformations to resources. The data manager provides public methods that:\n\nDefined a new material type\nAdd and remove batches\nAdd and remove stages\nMove batches to and from stages\nExchange materials between batches\nOffer stages for distribution to other materials producers\nMove stages between producers\nAdd materials producers\nDefine various properties for producers and batches\nSet various property values\nTransform stages into new batches\nTransform stages into resources\nDistribute resources to regions\nProvide a wide range of materials related queries\n\nDetails per batch and stage\nInventories by producer/material type\nOffered stages that can be transferred\n\n\nThe data manager also produces observable events:\n\nBatchAdditionEvent – when a batch is created\nBatchAmountUpdateEvent – when material is exchanged between batches\nBatchImminentRemovalEvent – when a batch is about to be removed from the simulation\nBatchPropertyDefinitionEvent – when a new material property is defined\nBatchPropertyUpdateEvent – when a batch property value is updated\nMaterialIdAdditionEvent. – when a new material type is added\nMaterialsProducerAdditionEvent – when a new materials producer is added\nMaterialsProducerPropertyDefinitionEvent – when a new materials producer property is defined\nMaterialsProducerPropertyUpdateEvent – when a material producer property value is updated\nMaterialsProducerResourceUpdateEvent – when a resource amount is added to a materials producer\nStageAdditionEvent – when a stage is created\nStageImminentRemovalEvent – when a stage is about to be removed from the simulation\nStageMaterialsProducerUpdateEvent – when a stage is exchanged between materials producers\nStageMembershipAdditionEvent – when a batch is added to a stage\nStageMembershipRemovalEvent – when a batch is removed from a stage\nStageOfferUpdateEvent – when a stage’s offer state is updated"
  },
  {
    "objectID": "ch12-MaterialsPlugin.html#example-code-lesson-19",
    "href": "ch12-MaterialsPlugin.html#example-code-lesson-19",
    "title": "12  Materials Plugin",
    "section": "12.4 Example Code (Lesson 19)",
    "text": "12.4 Example Code (Lesson 19)\nExample_19.java shows the use of the materials plugin. In it we will examine:\n\nThe initialization of the materials plugin\nThe flow of materials and resources between regions and materials producers\nThe observation of materials events\n\nThe example includes nine plugins:\n\nMaterials plugin – (GCM core plugin) used to manage materials\nResources plugin – (GCM core plugin) used to manage resources\nPeople plugin – (GCM core plugin) used to manage people\nGroups plugin – (GCM core plugin) used for spreading infections to people via their homes, schools and work places\nPerson properties plugin– (GCM core plugin) used to decorate properties onto people\nGlobal properties plugin– (GCM core plugin) used to store policies and initial conditions\nStochastics plugin – (GCM core plugin) used to generate random numbers used in various decisions\nRegions Plugin– (GCM core plugin) used for resource flow\nModel plugin – (local plugin) used to introduce five actors that will:\n\nLoad the population\nManage infectious contacts\nManage vaccinations\nProduce antigen used in vaccine production\nProduce vaccines"
  },
  {
    "objectID": "ch12-MaterialsPlugin.html#model",
    "href": "ch12-MaterialsPlugin.html#model",
    "title": "12  Materials Plugin",
    "section": "12.5 Model",
    "text": "12.5 Model\nThe example’s model represents a disease that is preventable through vaccination. People at the start of the simulation are either immune or susceptible and some of the susceptible adults are infected. The disease is transmitted via home, work, and school environments. Vaccination is the only disease mitigation strategy and vaccinated people do not infect others nor can be infected. Vaccine production is started once a threshold of infections is reached and continues until adequate vaccine has been produced to cover the entire population. Vaccines are modeled as a resource and are produced using several materials by two actors. The first of these actors produces antigen materials that are used in the production of the vaccine by the second actor."
  },
  {
    "objectID": "ch12-MaterialsPlugin.html#model-execution",
    "href": "ch12-MaterialsPlugin.html#model-execution",
    "title": "12  Materials Plugin",
    "section": "12.6 Model Execution",
    "text": "12.6 Model Execution\nThe example’s execution is shown in Code Block 12.1\n\n\nCode Block 12.1: The various plugins are gathered from their initial data, dimensions are added and the experiment is executed over 81 scenarios using 8 threads.\n    private void execute() {\n\n        ExperimentParameterData experimentParameterData = ExperimentParameterData.builder()//\n                .setThreadCount(8)//\n                .build();\n\n        Experiment.builder()//\n                .addPlugin(getMaterialsPlugin())//\n                .addPlugin(getResourcesPlugin())//\n                .addPlugin(getGlobalPropertiesPlugin())//\n                .addPlugin(getPersonPropertiesPlugin())//\n                .addPlugin(getStochasticsPlugin())//\n                .addPlugin(getRegionsPlugin())//\n                .addPlugin(getPeoplePlugin())//\n                .addPlugin(getGroupsPlugin())//\n                .addPlugin(ModelPlugin.getModelPlugin())//\n\n                .addDimension(getInfectionThresholdDimension())//\n                .addDimension(getCommunityContactRateDimension())//\n                .addDimension(getIntialInfectionsDimension())//\n                .addDimension(getR0Dimension())//\n\n                .addExperimentContextConsumer(getNIOReportItemHandler())//\n                .setExperimentParameterData(experimentParameterData).build()//\n                .execute();//\n\n    }\n\n\nThe first action is to add the materials plugin (Code Block 12.2, Code Block 12.3, Code Block 12.4). Only the material producer id values contained in the MaterialsProducer enumeration and the material ids contained in the Material enumeration are added to the plugin’s data.\n\n\nCode Block 12.2: The materials plugin establishes the materials producer ids and the material types.\nprivate Plugin getMaterialsPlugin() {\n    final MaterialsPluginData.Builder builder = MaterialsPluginData.builder();\n    for (final MaterialsProducer materialsProducer : MaterialsProducer.values()) {\n        builder.addMaterialsProducerId(materialsProducer);\n    }\n    for (final Material material : Material.values()) {\n        builder.addMaterial(material);\n    }\n    final MaterialsPluginData materialsPluginData = builder.build();\n    return MaterialsPlugin.builder().setMaterialsPluginData(materialsPluginData).getMaterialsPlugin();\n}\n\n\n\n\nCode Block 12.3: The ids of the materials producers are implemented via an enumeration.\npublic enum MaterialsProducer implements MaterialsProducerId {\n\n    VACCINE_PRODUCER, //\n    ANTIGEN_PRODUCER;\n\n}\n\n\n\n\nCode Block 12.4: The material ids are implemented via an enumeration.\npublic enum Material implements MaterialId {\n\n    VIRUS, //\n    GROWTH_MEDIUM, //\n    ANTIGEN, //\n    ADJUVANT, //\n    PRESERVATIVE, //\n    STABILIZER;//\n}\n\n\nThe next action is to add the resources plugin (Code Block 12.5, Code Block 12.6). Only the resource id values contained in the Resource enumeration are added to the plugin’s data. Region and person resource levels are initialized to zero.\n\n\nCode Block 12.5: The resources plugin is created with the single VACCINE resource id.\nprivate Plugin getResourcesPlugin() {\n    final ResourcesPluginData.Builder builder = ResourcesPluginData.builder();\n    for (final ResourceId resourcId : Resource.values()) {\n        builder.addResource(resourcId, 0.0, true);\n    }\n    final ResourcesPluginData resourcesPluginData = builder.build();\n    return ResourcesPlugin.builder().setResourcesPluginData(resourcesPluginData).getResourcesPlugin();\n}\n\n\n\n\nCode Block 12.6: The resource ids are implemented via an enumeration.\npublic enum Resource implements ResourceId {\n    VACCINE;\n}\n\n\nThe next action is to load the global properties plugin (Code Block 12.7). All of the global properties are marked as immutable since they will not change over the course of the simulation.\n\nSUSCEPTIBLE_POPULATION_PROPORTION – The fraction of the population that is susceptible\nINITIAL_INFECTIONS – The number of adults initially infected\nMIN_INFECTIOUS_PERIOD – The minimum number of days a person is infectious\nMAX_INFECTIOUS_PERIOD – The maximum number of days a person is infectious\nPOPULATION_SIZE – The initial size of the population\nCHILD_POPULATION_PROPORTION – The fraction of the population between the ages of 0 and 18, inclusive\nSENIOR_POPULATION_PROPORTION – The fraction of the population 65 and older\nR0 – The expected number of people a single person will infect if all contacts are susceptible and transmission success is 100%\nAVERAGE_HOME_SIZE – The average number of people per household\nAVERAGE_SCHOOL_SIZE – The average number of students in a school\nAVERAGE_WORK_SIZE – The average number of people per work place\nCOMMUNITY_CONTACT_RATE – The proportion of contacts that will be randomly chosen from the entire population\nMANUFACTURE_VACCINE – Boolean that triggers vaccine manufacture\nINFECTION_THRESHOLD – The fraction of the population that are infected in order to start vaccine manufacture\n\n\n\nCode Block 12.7: The global properties plugin is initialized with several properties.\nprivate Plugin getGlobalPropertiesPlugin() {\n    final GlobalPropertiesPluginData.Builder builder = GlobalPropertiesPluginData.builder();//\n\n    PropertyDefinition propertyDefinition = PropertyDefinition.builder()//\n            .setType(Double.class)//\n            .setPropertyValueMutability(false)//\n            .setDefaultValue(0.0)//\n            .build();\n\n    builder.defineGlobalProperty(GlobalProperty.SUSCEPTIBLE_POPULATION_PROPORTION, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.AVERAGE_HOME_SIZE, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.AVERAGE_SCHOOL_SIZE, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.AVERAGE_WORK_SIZE, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.CHILD_POPULATION_PROPORTION, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.SENIOR_POPULATION_PROPORTION, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.R0, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.COMMUNITY_CONTACT_RATE, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.INFECTION_THRESHOLD, propertyDefinition, 0);\n\n    propertyDefinition = PropertyDefinition.builder()//\n            .setType(Integer.class)//\n            .setPropertyValueMutability(false)//\n            .build();\n    builder.defineGlobalProperty(GlobalProperty.INITIAL_INFECTIONS, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.MIN_INFECTIOUS_PERIOD, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.MAX_INFECTIOUS_PERIOD, propertyDefinition, 0);\n    builder.defineGlobalProperty(GlobalProperty.POPULATION_SIZE, propertyDefinition, 0);\n\n    propertyDefinition = PropertyDefinition.builder()//\n            .setType(Boolean.class)//\n            .setDefaultValue(false)//\n            .setPropertyValueMutability(true)//\n            .build();\n    builder.defineGlobalProperty(GlobalProperty.MANUFACTURE_VACCINE, propertyDefinition, 0);\n\n    builder.setGlobalPropertyValue(GlobalProperty.POPULATION_SIZE, 10_000, 0);\n    builder.setGlobalPropertyValue(GlobalProperty.SUSCEPTIBLE_POPULATION_PROPORTION, 1.0, 0);\n    builder.setGlobalPropertyValue(GlobalProperty.INITIAL_INFECTIONS, 1, 0);\n    builder.setGlobalPropertyValue(GlobalProperty.MIN_INFECTIOUS_PERIOD, 7, 0);\n    builder.setGlobalPropertyValue(GlobalProperty.MAX_INFECTIOUS_PERIOD, 14, 0);\n    builder.setGlobalPropertyValue(GlobalProperty.R0, 2.0, 0);\n    builder.setGlobalPropertyValue(GlobalProperty.CHILD_POPULATION_PROPORTION, 0.235, 0);\n    builder.setGlobalPropertyValue(GlobalProperty.SENIOR_POPULATION_PROPORTION, 0.169, 0);\n    builder.setGlobalPropertyValue(GlobalProperty.AVERAGE_HOME_SIZE, 2.5, 0);\n    builder.setGlobalPropertyValue(GlobalProperty.AVERAGE_SCHOOL_SIZE, 250.0, 0);\n    builder.setGlobalPropertyValue(GlobalProperty.AVERAGE_WORK_SIZE, 30.0, 0);\n    builder.setGlobalPropertyValue(GlobalProperty.INFECTION_THRESHOLD, 0.0, 0);\n    builder.setGlobalPropertyValue(GlobalProperty.COMMUNITY_CONTACT_RATE, 0.0, 0);\n\n    final GlobalPropertiesPluginData globalPropertiesPluginData = builder.build();\n\n    return GlobalPropertiesPlugin.builder().setGlobalPropertiesPluginData(globalPropertiesPluginData)\n            .getGlobalPropertiesPlugin();\n\n}\n\n\nThe person properties plugin is loaded (Code Block 12.8).\n\nAGE – The integer age of a person\nVACCINATED – Boolean vaccination status\nVACCINE_SCHEDULED – Boolean indicating whether a vaccination is scheduled for a person\nDISEASE_STATE – IMMUNE, SUSCEPTIBLE, INFECTIOUS or RECOVERED\n\n\n\nCode Block 12.8: The person properties plugin includes person property definitions and the data for the person property report.\nprivate Plugin getPersonPropertiesPlugin() {\n\n    final PersonPropertiesPluginData.Builder builder = PersonPropertiesPluginData.builder();\n\n    PropertyDefinition propertyDefinition = PropertyDefinition.builder()//\n            .setType(Boolean.class)//\n            .setDefaultValue(false)//\n            .build();\n\n    builder.definePersonProperty(PersonProperty.VACCINATED, propertyDefinition, 0, false);//\n    builder.definePersonProperty(PersonProperty.VACCINE_SCHEDULED, propertyDefinition, 0, false);//\n\n    propertyDefinition = PropertyDefinition.builder()//\n            .setType(Integer.class)//\n            .build();//\n    builder.definePersonProperty(PersonProperty.AGE, propertyDefinition, 0, false);//\n\n    propertyDefinition = PropertyDefinition.builder()//\n            .setType(DiseaseState.class)//\n            .setDefaultValue(DiseaseState.SUSCEPTIBLE)//\n            .build();\n\n    builder.definePersonProperty(PersonProperty.DISEASE_STATE, propertyDefinition, 0, false);//\n\n    final PersonPropertiesPluginData personPropertiesPluginData = builder.build();\n\n    PersonPropertyReportPluginData personPropertyReportPluginData = //\n            PersonPropertyReportPluginData.builder()//\n                    .setReportLabel(ModelReportLabel.PERSON_PROPERTY_REPORT)//\n                    .setReportPeriod(ReportPeriod.DAILY)//\n                    .includePersonProperty(PersonProperty.VACCINATED)//\n                    .includePersonProperty(PersonProperty.VACCINE_SCHEDULED)//\n                    .build();\n\n    return PersonPropertiesPlugin.builder()//\n            .setPersonPropertiesPluginData(personPropertiesPluginData)//\n            .setPersonPropertyReportPluginData(personPropertyReportPluginData)//\n            .getPersonPropertyPlugin();\n\n}\n\n\nThere are four reports:\n\nDiseaseStateReport – Shows the number of people in each of the disease states at the end of each simulation\nPersonPropertyReport – Shows an hourly summary the number of people having various person property values\nVaccineReport – Shows a daily summary of the number of people who have been scheduled for or have received vaccination\nVaccineProductionReport – Shows a daily summary of the internal inventory of the antigen and vaccine producers\n\nThe stochastic plugin is initialized with a random seed and all simulations will start in the same stochastic state. The Regions plugin has one region and the people plugin is loaded in an empty state. People are added by an actor in the model plugin. The groups plugin is initialized with the three group types: HOME, SCHOOL, and WORK.\nThe model plugin adds three actors:\n\nPopulationLoader – Adds people to the simulation and initializes immunity\nContactManager – Manages person to person transmission of the disease\nVaccinator – Distributes vaccine to people"
  },
  {
    "objectID": "ch12-MaterialsPlugin.html#experiment-dimensions",
    "href": "ch12-MaterialsPlugin.html#experiment-dimensions",
    "title": "12  Materials Plugin",
    "section": "12.7 Experiment dimensions",
    "text": "12.7 Experiment dimensions\nFour dimensions are added to the experiment that define alternate values for some of the global properties resulting in 81 scenarios. The dimension values are:\n\nINFECTION_THRESHOLD – 0.01, 0.02, 0.05\nCOMMUNITY_CONTACT_RATE – 0.0, 0.01, 0.05\nINITIAL_INFECTIONS – 1, 10, 100\nR0 – 2.0, 2.5, 3.0\n\nThe fixed values are:\n\nPOPULATION_SIZE – 10,000\nSUSCEPTIBLE_POPULATION_PROPORTION - 100%\nMIN_INFECTIOUS_PERIOD – 7 days\nMAX_INFECTIOUS_PERIOD – 14 days\nCHILD_POPULATION_PROPORTION – 0.235\nSENIOR_POPULATION_PROPORTION – 0.169\nAVERAGE_HOME_SIZE – 2.5\nAVERAGE_SCHOOL_SIZE – 250.0\nAVERAGE_WORK_SIZE – 30.0\nMANUFACTURE_VACCINE – false"
  },
  {
    "objectID": "ch12-MaterialsPlugin.html#the-actors",
    "href": "ch12-MaterialsPlugin.html#the-actors",
    "title": "12  Materials Plugin",
    "section": "12.8 The actors",
    "text": "12.8 The actors\nWe will finish this chapter by reviewing the actors and then examine the output.\n\n12.8.1 Population Loader\nThe PopulationLoader actor adds people to the simulation based on the number in the POPULATION_SIZE global property. The people are evenly distributed among the regions and each region creates children, working age adults and seniors based on the relevant global variables. The people are assigned homes, schools and work places accordingly, with each home having at least one adult. All people start out as either IMMUNE or SUSCEPTIBLE to the disease based on the SUSCEPTIBLE_POPULATION_PROPORTION global property.\n\n\n12.8.2 Contact Manager\nThe ContactManager actor, Code Block 12.9, schedules infectious contacts between infected people and the susceptible population. On its initialization, it establishes various parameters from the global variables and schedules the initial infections over the first day of the simulation.\n\n\nCode Block 12.9: The contact manager initializes by infecting the initially infected people in the first day.\npublic void init(final ActorContext actorContext) {\n    this.actorContext = actorContext;\n\n    final StochasticsDataManager stochasticsDataManager = actorContext.getDataManager(StochasticsDataManager.class);\n    randomGenerator = stochasticsDataManager.getRandomGenerator();\n    final Random random = new Random(randomGenerator.nextLong());\n\n    peopleDataManager = actorContext.getDataManager(PeopleDataManager.class);\n\n    groupsDataManager = actorContext.getDataManager(GroupsDataManager.class);\n    final GlobalPropertiesDataManager globalPropertiesDataManager = actorContext\n            .getDataManager(GlobalPropertiesDataManager.class);\n    communityContactRate = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.COMMUNITY_CONTACT_RATE);\n\n    personPropertiesDataManager = actorContext.getDataManager(PersonPropertiesDataManager.class);\n    final List<PersonId> susceptiblePeople = personPropertiesDataManager\n            .getPeopleWithPropertyValue(PersonProperty.DISEASE_STATE, DiseaseState.SUSCEPTIBLE);\n    final List<PersonId> susceptibleAdults = new ArrayList<>();\n    for (final PersonId personId : susceptiblePeople) {\n        final int age = personPropertiesDataManager.getPersonPropertyValue(personId, PersonProperty.AGE);\n        if (age > 18) {\n            susceptibleAdults.add(personId);\n        }\n    }\n\n    Collections.shuffle(susceptibleAdults, random);\n\n    minInfectiousPeriod = globalPropertiesDataManager.getGlobalPropertyValue(GlobalProperty.MIN_INFECTIOUS_PERIOD);\n    maxInfectiousPeriod = globalPropertiesDataManager.getGlobalPropertyValue(GlobalProperty.MAX_INFECTIOUS_PERIOD);\n    final double r0 = globalPropertiesDataManager.getGlobalPropertyValue(GlobalProperty.R0);\n    infectionInterval = (minInfectiousPeriod + maxInfectiousPeriod) / (2 * r0);\n\n    int initialInfections = globalPropertiesDataManager.getGlobalPropertyValue(GlobalProperty.INITIAL_INFECTIONS);\n    initialInfections = FastMath.min(initialInfections, susceptibleAdults.size());\n\n    for (int i = 0; i < initialInfections; i++) {\n        final PersonId personId = susceptibleAdults.get(i);\n        final double planTime = (randomGenerator.nextDouble() * 0.5) + 0.25;\n        actorContext.addPlan((c) -> infectPerson(personId), planTime);\n    }\n}\n\n\nWhen a person is infected (Code Block 12.10), the contact manager determines the number of days that the person will be infectious and the number of potential infections that person will cause over those days. For each potential infectious contact, the manager schedules that contact at the relevant time. Finally, it schedules the transition of the person from infectious to recovered.\n\n\nCode Block 12.10: When a person is infected, the number of possible infectious contacts is determined and planned. After the last infectious contact, the person is scheduled to become recovered.\nprivate void infectPerson(final PersonId personId) {\n    personPropertiesDataManager.setPersonPropertyValue(personId, PersonProperty.DISEASE_STATE,\n            DiseaseState.INFECTIOUS);\n    final int infectiousDays = randomGenerator.nextInt(maxInfectiousPeriod - minInfectiousPeriod)\n            + minInfectiousPeriod;\n    final int infectionCount = (int) FastMath.round((infectiousDays / infectionInterval));\n\n    double planTime = actorContext.getTime();\n\n    for (int j = 0; j < infectionCount; j++) {\n        planTime += infectionInterval;\n        actorContext.addPlan((c) -> infectContact(personId), planTime);\n    }\n    actorContext.addPlan((c) -> endInfectiousness(personId), planTime);\n}\n\n\nFor each potential infectious contact, the manager (Code Block 12.11) first determines if the contact is in one of the person’s groups or is in the general community. If it is a community contact, a person is selected from the general population. If it is a group contact, one of the person’s groups is chosen at random and a person is selected from that group. The selected person must be susceptible and unvaccinated for the contact to transfer the infection. Thus, as more people are either infected or vaccinated, the number of people each infectious person infects decreases.\n\n\nCode Block 12.11: The contact manager attempts to make an infectious contact from an infected person to a randomly selected susceptible person who is not vaccinated from either the general public or from one of the infected person’s groups.\nprivate void infectContact(final PersonId personId) {\n\n    if (randomGenerator.nextDouble() < communityContactRate) {\n        final List<PersonId> people = peopleDataManager.getPeople();\n        people.remove(personId);\n        if (people.size() > 0) {\n            final PersonId contactedPerson = people.get(randomGenerator.nextInt(people.size()));\n            final DiseaseState diseaseState = personPropertiesDataManager.getPersonPropertyValue(contactedPerson,\n                    PersonProperty.DISEASE_STATE);\n            final boolean vaccinated = personPropertiesDataManager.getPersonPropertyValue(contactedPerson,\n                    PersonProperty.VACCINATED);\n            if ((diseaseState == DiseaseState.SUSCEPTIBLE) && !vaccinated) {\n                infectPerson(contactedPerson);\n            }\n        }\n    } else {\n        final List<GroupId> groupsForPerson = groupsDataManager.getGroupsForPerson(personId);\n        final GroupId groupId = groupsForPerson.get(randomGenerator.nextInt(groupsForPerson.size()));\n        final GroupSampler groupSampler = GroupSampler.builder().setExcludedPersonId(personId).build();\n        final Optional<PersonId> optional = groupsDataManager.sampleGroup(groupId, groupSampler);\n        if (optional.isPresent()) {\n            final PersonId contactedPerson = optional.get();\n            final DiseaseState diseaseState = personPropertiesDataManager.getPersonPropertyValue(contactedPerson,\n                    PersonProperty.DISEASE_STATE);\n            final boolean vaccinated = personPropertiesDataManager.getPersonPropertyValue(contactedPerson,\n                    PersonProperty.VACCINATED);\n            if ((diseaseState == DiseaseState.SUSCEPTIBLE) && !vaccinated) {\n                infectPerson(contactedPerson);\n            }\n        }\n    }\n}\n\n\n\n\n12.8.3 Vaccinator\nThe Vaccinator actor, in Code Block 12.12, creates the VaccineProducer and AntigenProducer actors and initializes various parameters and data structures that will help it distribute vaccines. It subscribes to changes in the disease state of people so that it can determine how many vaccines are needed. It subscribes to changes in the resource states of materials producers so that it can distribute vaccines from the VaccineProduer to the regions and then on to the people in those regions. The two producers will not start manufacturing materials until the Vaccinator determines that enough people have been infected. When the number of infected exceeds the required threshold the Vaccinator will set the MANUFACTURE_VACCINE global variable to true and the producers will begin material and resource production.\n\n\nCode Block 12.12: The vaccinator initializes by subscribing to changes in materials producer resource levels so that it can distribute vaccines to regions. It also subscribes to changes in person disease state to select people for vaccination.\npublic void init(final ActorContext actorContext) {\n    this.actorContext = actorContext;\n    actorContext.addActor(new VaccineProducer(MaterialsProducer.VACCINE_PRODUCER)::init);\n    actorContext.addActor(new AntigenProducer(MaterialsProducer.ANTIGEN_PRODUCER)::init);\n\n    globalPropertiesDataManager = actorContext.getDataManager(GlobalPropertiesDataManager.class);\n    peopleDataManager = actorContext.getDataManager(PeopleDataManager.class);\n    personPropertiesDataManager = actorContext.getDataManager(PersonPropertiesDataManager.class);\n    resourcesDataManager = actorContext.getDataManager(ResourcesDataManager.class);\n    regionsDataManager = actorContext.getDataManager(RegionsDataManager.class);\n    materialsDataManager = actorContext.getDataManager(MaterialsDataManager.class);\n    actorContext.subscribe(materialsDataManager.getEventFilterForMaterialsProducerResourceUpdateEvent(),\n            this::handleMaterialsProducerResourceUpdateEvent);\n\n    for (final RegionId regionId : regionsDataManager.getRegionIds()) {\n        vaccinationSchedules.put(regionId, new MutableDouble());\n        availableVaccines.put(regionId, new MutableLong());\n    }\n\n    actorContext.subscribe(\n            personPropertiesDataManager.getEventFilterForPersonPropertyUpdateEvent(PersonProperty.DISEASE_STATE),\n            this::handlePersonPropertyUpdateEvent);\n\n    final double infectionThreshold = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.INFECTION_THRESHOLD);\n    infectedPersonCount = personPropertiesDataManager\n            .getPeopleWithPropertyValue(PersonProperty.DISEASE_STATE, DiseaseState.INFECTIOUS).size();\n    infectionPersonCountThreshold = (int) (peopleDataManager.getPopulationCount() * infectionThreshold);\n    determineVaccineManufacutureStart();\n    scheduleVaccinations();\n}\n\n\nAs people become infected (Code Block 12.13, Code Block 12.14), the Vaccinator will determine if the vaccine manufacture needs to be started. Once the decision is made to start manufacture, the Vaccinator no longer needs to observe people becoming infectious, so it unsubscribes to changes in the disease states of people.\n\n\nCode Block 12.13: If a person become infectious, the vaccinator reviews whether to start vaccine manufacture.\nprivate void handlePersonPropertyUpdateEvent(final ActorContext actorContext,\n        final PersonPropertyUpdateEvent personPropertyUpdateEvent) {\n\n    final DiseaseState diseaseState = (DiseaseState) personPropertyUpdateEvent.getCurrentPropertyValue();\n    if (diseaseState == DiseaseState.INFECTIOUS) {\n        infectedPersonCount++;\n        determineVaccineManufacutureStart();\n    }\n}\n\n\n\n\nCode Block 12.14: If vaccine manufacture has not yet started and the number of infected people exceeds a threshold, then the vaccinator set the MANUFACTURE_VACCINE global property to true, signaling to the vaccine related materials producers to start.\nprivate void determineVaccineManufacutureStart() {\n    if (!manufactureStarted) {\n        if (infectedPersonCount >= infectionPersonCountThreshold) {\n            manufactureStarted = true;\n            globalPropertiesDataManager.setGlobalPropertyValue(GlobalProperty.MANUFACTURE_VACCINE, true);\n            actorContext.unsubscribe(personPropertiesDataManager\n                    .getEventFilterForPersonPropertyUpdateEvent(PersonProperty.DISEASE_STATE));\n        }\n    }\n}\n\n\nWhenever resources (vaccines in this case) are accumulated on a materials producer (Code Block 12.15), the Vaccinator must determine (Code Block 12.16) if the resource is a vaccine, whether the change to the resource level represents an addition of that resource to the inventory of the materials producer and whether any vaccine is needed. If the vaccine is available and needed, then the Vaccinator transfers the vaccines evenly amongst the regions and tries to schedule new vaccinations.\n\n\nCode Block 12.15: When a resource change occurs on a materials producer, the vaccinator determines if the change represents doses of vaccine and whether there is any remaining demand.\nprivate void handleMaterialsProducerResourceUpdateEvent(final ActorContext actorContext,\n        final MaterialsProducerResourceUpdateEvent materialsProducerResourceUpdateEvent) {\n    if (isCapturableResource(materialsProducerResourceUpdateEvent)) {\n\n        final MaterialsProducerId materialsProducerId = materialsProducerResourceUpdateEvent.materialsProducerId();\n\n        final long resourceLevel = materialsDataManager.getMaterialsProducerResourceLevel(materialsProducerId,\n                Resource.VACCINE);\n        final List<RegionId> regionIds = new ArrayList<>(regionsDataManager.getRegionIds());\n\n        final long resourceToTransfer = resourceLevel / regionIds.size();\n        long remainderResource = resourceLevel % regionIds.size();\n\n        for (final RegionId regionId : regionIds) {\n            final MutableLong availableVaccine = availableVaccines.get(regionId);\n            if (remainderResource > 0) {\n                materialsDataManager.transferResourceToRegion(materialsProducerId, Resource.VACCINE, regionId,\n                        resourceToTransfer + 1);\n                remainderResource--;\n                availableVaccine.increment(resourceToTransfer + 1);\n            } else {\n                materialsDataManager.transferResourceToRegion(materialsProducerId, Resource.VACCINE, regionId,\n                        resourceToTransfer);\n                availableVaccine.increment(resourceToTransfer);\n            }\n        }\n        scheduleVaccinations();\n    }\n}\n\n\n\n\nCode Block 12.16: When a materials producer updates its resource level, the vaccinator confirms that the resource is vaccine doses that have been added to the producer’s inventory and that there is current demand for the vaccine.\nprivate boolean isCapturableResource(\n        final MaterialsProducerResourceUpdateEvent materialsProducerResourceUpdateEvent) {\n    if (!materialsProducerResourceUpdateEvent.resourceId().equals(Resource.VACCINE)) {\n        return false;\n    }\n    final boolean isResourceAdditionToProducer = materialsProducerResourceUpdateEvent\n            .currentResourceLevel() > materialsProducerResourceUpdateEvent.previousResourceLevel();\n    if (!isResourceAdditionToProducer) {\n        return false;\n    }\n\n    long distributedVaccineCount = personPropertiesDataManager\n            .getPersonCountForPropertyValue(PersonProperty.VACCINATED, true);\n\n    for (final RegionId regionId : regionsDataManager.getRegionIds()) {\n        distributedVaccineCount += resourcesDataManager.getRegionResourceLevel(regionId, Resource.VACCINE);\n    }\n    if (distributedVaccineCount >= peopleDataManager.getPopulationCount()) {\n        return false;\n    }\n    return true;\n}\n\n\nOnce vaccine doses are available, the Vaccinator schedules vaccinations (Code Block 12.17) at a fixed rate of 100 per day. The vaccines doses are distributed evenly amongst the regions and people are scheduled for vaccination throughout the day(s) following the receipt of vaccines from the VaccineProducer. Finally, the Vaccinator determines if enough vaccine has been received and to vaccinate the entire population and thus the manufacture of resource and materials can be halted.\n\n\nCode Block 12.17: The vaccinator schedules vaccinations at initialization and whenever a materials producer produces resources. The vaccinator tries to distribute the available doses of vaccine with a standard delay time between scheduled vaccinations.\nprivate void scheduleVaccinations() {\n    final double delayTime = 1 / (double) vaccinationsPerRegionPerDay;\n\n    for (final RegionId regionId : vaccinationSchedules.keySet()) {\n        final MutableLong availableVaccine = availableVaccines.get(regionId);\n        final MutableDouble vaccineTime = vaccinationSchedules.get(regionId);\n        vaccineTime.increment(delayTime);\n        if (vaccineTime.getValue() < actorContext.getTime()) {\n            vaccineTime.setValue(actorContext.getTime());\n        }\n        final List<PersonId> peopleInRegion = regionsDataManager.getPeopleInRegion(regionId);\n        for (final PersonId personId : peopleInRegion) {\n            final boolean vaccine_scheduled = personPropertiesDataManager.getPersonPropertyValue(personId,\n                    PersonProperty.VACCINE_SCHEDULED);\n            if (availableVaccine.getValue() <= 0) {\n                break;\n            }\n            if (!vaccine_scheduled) {\n                availableVaccine.decrement();\n                personPropertiesDataManager.setPersonPropertyValue(personId, PersonProperty.VACCINE_SCHEDULED,\n                        true);\n                actorContext.addPlan((c) -> vaccinatePerson(personId), vaccineTime.getValue());\n                vaccineTime.increment(delayTime);\n            }\n        }\n    }\n    final int populationSize = peopleDataManager.getPopulationCount();\n    final int scheduledVaccinationCount = personPropertiesDataManager\n            .getPersonCountForPropertyValue(PersonProperty.VACCINE_SCHEDULED, true);\n    if (scheduledVaccinationCount >= populationSize) {\n        globalPropertiesDataManager.setGlobalPropertyValue(GlobalProperty.MANUFACTURE_VACCINE, false);\n    }\n}\n\n\nThe vaccination for each person (Code Block 12.18) sets the person’s VACCINATED property to true and transfers a single unit (dose) of vaccine from the person’s region to the person.\n\n\nCode Block 12.18: The vaccinator sets the person’s VACCINATED property to true and moves one unit of vaccine from the person’s region to the person.\nprivate void vaccinatePerson(final PersonId personId) {\n    personPropertiesDataManager.setPersonPropertyValue(personId, PersonProperty.VACCINATED, true);\n    resourcesDataManager.transferResourceToPersonFromRegion(Resource.VACCINE, personId, 1L);\n}\n\n\n\n\n12.8.4 Antigen Producer\nThe AntigenProducer creates the ANTIGEN material from the GROWTH_MEDIUM and VIRUS materials. The generated ANTIGEN material is placed on stages in batches of 25 units of antigen and the stages are offered up to other materials producers. The VaccineProducer will transfer these stages to itself and use the ANTIGEN material in its own production of vaccine. Various factors limit the production of antigen. The GROWTH_MEDIUM and VIRUS materials initialize to a zero inventory and are scheduled to be received at regular intervals depending on ongoing demands and ordering limits. The AntigenProducer has a maximum stage storage capacity of 60 stages and production must halt once that limit is reached. The VaccineProducer must remove the stages for manufacture to continue. Each batch requires 6 hours to create and 15 days to ferment. The AntigenProducer can only start one batch of fermentation at a time.\nThe AntigenProducer initializes (Code Block 12.19) by adding specifications for the two materials used in the production of antigen. GROWTH_MEDIUM is ordered in allotments of 35 units and there is a 7 day delay from the time of order to receipt. VIRUS is ordered in allotments of 100 units with a 21 day delay. Both resources are utilized at one unit per unit of ANTIGEN produced. The AntigenProducer subscribes to the transfer of stages away from itself (capture by the VaccineProduer) so that it can possibly resume manufacture. It also subscribes to changes in the MANUFACTURE_VACCINE global property which must be true for any manufacturing of antigen to continue.\n\n\nCode Block 12.19: The antigen producer initializes by subscribing to stage transfers from itself as well as changes to the manufacturing policy.\npublic void init(final ActorContext actorContext) {\n    this.actorContext = actorContext;\n    materialsDataManager = actorContext.getDataManager(MaterialsDataManager.class);\n    globalPropertiesDataManager = actorContext.getDataManager(GlobalPropertiesDataManager.class);\n    addMaterialRec(Material.GROWTH_MEDIUM, MaterialManufactureSpecification.builder()//\n            .setDeliveryAmount(35.0)//\n            .setDeliveryDelay(7.0)//\n            .setStageAmount(1.0));//\n\n    addMaterialRec(Material.VIRUS, MaterialManufactureSpecification.builder()//\n            .setDeliveryAmount(100.0)//\n            .setDeliveryDelay(21.0)//\n            .setStageAmount(1.0));//\n\n    // each time a stage is transferred\n    actorContext.subscribe(\n            materialsDataManager.getEventFilterForStageMaterialsProducerUpdateEvent_BySource(materialsProducerId),\n            (c, e) -> planFermentation());\n\n    // each time the manufacture policy is changed\n    actorContext.subscribe(globalPropertiesDataManager.getEventFilterForGlobalPropertyUpdateEvent(\n            GlobalProperty.MANUFACTURE_VACCINE), (c, e) -> planFermentation());\n\n    planFermentation();\n}\n\n\nThe planning of antigen batch creation and fermentation is triggered by several events:\n\nInitialization of the AntigenProducer\nTransfer of an offered stage to the VaccineProducer\nChange of the MANUFACTURE_VACCINE global property by the Vaccinator\nReceipt of ordered GROWTH_MEDIUM or VIRUS\nThe fermentation of a batch of ANTIGEN\n\nThe planning process (Code Block 12.20) starts by determining if manufacture has been halted by the Vaccinator. If manufacturing is allowed, then each of the required materials are analyzed and ordered as needed to build a full complement of offered stages. The process continues by constructing stages from the batches of GROWTH_MEDIUM and VIRUS that are held in inventory until there are either insufficient materials or no more capacity to store stages. The start of the fermentation process is determined and the end of each fermentation is scheduled.\n\n\nCode Block 12.20: Responding to events that may allow for additional manufacture of antigen stages, the antigen producer attempts to continue manufacturing.\nprivate void planFermentation() {\n\n    final Boolean continueManufature = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.MANUFACTURE_VACCINE);\n    if (!continueManufature) {\n        return;\n    }\n    orderMaterials();\n\n    while (!stagesAtCapacity() && hasSufficientMaterialsForNewStage()) {\n        final StageId stageId = materialsDataManager.addStage(materialsProducerId);\n        for (final MaterialId materialId : materialRecs.keySet()) {\n            final MaterialManufactureSpecification materialManufactureSpecification = materialRecs.get(materialId);\n            final BatchId newBatchId = materialsDataManager.addBatch(BatchConstructionInfo.builder()\n                    .setMaterialsProducerId(materialsProducerId).setMaterialId(materialId).build());\n            materialsDataManager.transferMaterialBetweenBatches(materialManufactureSpecification.getBatchId(),\n                    newBatchId, materialManufactureSpecification.getStageAmount());\n            materialsDataManager.moveBatchToStage(newBatchId, stageId);\n        }\n        final double batchAssemblyStartTime = FastMath.max(actorContext.getTime(), lastBatchAssemblyEndTime);\n        final double fermentationStartTime = batchAssemblyStartTime + batchAssemblyDuration;\n        lastBatchAssemblyEndTime = fermentationStartTime;\n        final double planTime = fermentationStartTime + fermentationTime;\n        actorContext.addPlan((c) -> endFermentationStage(stageId), planTime);\n    }\n}\n\n\nOnce fermentation is complete (Code Block 12.21) for a stage containing the GROWTH_MEDIUM and VIRUS, the stage is converted into a batch of 25 ANTIGEN units and staged. The new stage is offered for transfer to the VaccineProducer.\n\n\nCode Block 12.21: When an antigen containing stage is ready for release, the antigen producer converts the stage into a batch of antigen and re-stages this batch on an offered stage.\nprivate void endFermentationStage(final StageId stageId) {\n    final BatchId batch = materialsDataManager.convertStageToBatch(//\n            StageConversionInfo.builder()//\n                    .setAmount(antigenUnits)//\n                    .setMaterialId(Material.ANTIGEN)//\n                    .setStageId(stageId)//\n                    .build());//\n\n    final StageId antigenStage = materialsDataManager.addStage(materialsProducerId);\n    materialsDataManager.moveBatchToStage(batch, antigenStage);\n    materialsDataManager.setStageOfferState(antigenStage, true);\n    planFermentation();\n}\n\n\n\n\n12.8.5 Vaccine Producer\nThe VaccineProducer creates 50 VACCINE resource units from staged ANTIGEN, ADJUVANT, PRESERVATIVE and STABILIZER materials and stores those vaccines. The Vaccinator gathers the stored vaccines and distributes them to the regions and people. The ANTIGEN material is gathered from the offered stages of the AntigenProducer and the other materials are ordered and received in a similar manner to the AntigenProducer. Vaccine production is limited by various factors. The non-ANTIGEN materials initialize to a zero inventory and are scheduled to be received at regular intervals depending on ongoing demands and ordering limits. The ANTIGEN material must be received from the AntigenProducer. There is a maximum stage storage capacity of 15 stages and production must halt once that limit is reached. Staged batches require 2.4 hours to assemble and 2 days to produce vaccine doses.\nThe VaccineProducer initializes (Code Block 12.22) by constructing an empty batch of ANTIGEN that will act as the inventory for all ANTIGEN used in stage creation. It then initializes the ordering constraints for the remaining materials. It subscribes to changes in stage offer states that will be used to detect when the AntigenProducer is offering stages containing ANTIGEN. Finally, it subscribes to changes in the MANUFACTURE_VACCINE global property which must be true for any manufacturing of vaccine to continue.\nThe planning of vaccine preparation and creation is triggered by several events:\n\nInitialization of the VaccineProducer\nThe offering of a stage containing ANTIGEN from the AntigenProducer\nChange of the MANUFACTURE_VACCINE global property by the Vaccinator\nReceipt of ordered ADJUVANT, PRESERVATIVE or STABILIZER\nThe completion of stage conversion into vaccine doses\n\nThe planning process (Code Block 12.23) starts by determining if manufacture has been halted by the Vaccinator. If manufacturing is allowed, then each of the required materials are analyzed and ordered as needed to build a full complement of offered stages. The process continues by constructing stages from the batches of ANTIGEN, ADJUVANT, PRESERVATIVE and STABILIZER that are held in inventory until there are either insufficient materials or no more capacity to store stages. The start of the vaccine preparation process is determined and the end of each preparation is scheduled.\n\n\nCode Block 12.22: The vaccine producer initializes by subscribing to offered stages(from the antigen producer) and subscribing to the start of vaccine manufacture.\npublic void init(final ActorContext actorContext) {\n    this.actorContext = actorContext;\n    materialsDataManager = actorContext.getDataManager(MaterialsDataManager.class);\n    globalPropertiesDataManager = actorContext.getDataManager(GlobalPropertiesDataManager.class);\n\n    final BatchConstructionInfo batchConstructionInfo = //\n            BatchConstructionInfo.builder()//\n                    .setMaterialId(Material.ANTIGEN)//\n                    .setMaterialsProducerId(materialsProducerId)//\n                    .build();//\n    antigenBatchId = materialsDataManager.addBatch(batchConstructionInfo);\n\n    addMaterialRec(Material.ADJUVANT, MaterialManufactureSpecification.builder()//\n            .setDeliveryAmount(150.0)//\n            .setDeliveryDelay(3.0)//\n            .setStageAmount(2.7));//\n\n    addMaterialRec(Material.PRESERVATIVE, MaterialManufactureSpecification.builder()//\n            .setDeliveryAmount(1000.0)//\n            .setDeliveryDelay(14.0)//\n            .setStageAmount(3.0));//\n\n    addMaterialRec(Material.STABILIZER, MaterialManufactureSpecification.builder()//\n            .setDeliveryAmount(100.0)//\n            .setDeliveryDelay(14.0)//\n            .setStageAmount(1.0));//\n\n    actorContext.subscribe(materialsDataManager.getEventFilterForStageOfferUpdateEvent(),\n            this::handleStageOfferUpdateEvent);\n    actorContext.subscribe(globalPropertiesDataManager.getEventFilterForGlobalPropertyUpdateEvent(\n            GlobalProperty.MANUFACTURE_VACCINE), (c, e) -> planVaccinePrepartion());\n\n    planVaccinePrepartion();\n}\n\n\n\n\nCode Block 12.23: Responding to events that may allow for additional manufacture of vaccine doses, the vaccine producer attempts to continue manufacturing.\nprivate void planVaccinePrepartion() {\n    final Boolean continueManufature = globalPropertiesDataManager\n            .getGlobalPropertyValue(GlobalProperty.MANUFACTURE_VACCINE);\n    if (!continueManufature) {\n        return;\n    }\n    orderMaterials();\n\n    while (!stagesAtCapacity() && hasSufficientMaterialsForNewStage() && vaccineLevelBelowCapacity()) {\n        final StageId stageId = materialsDataManager.addStage(materialsProducerId);\n        for (final MaterialId materialId : materialRecs.keySet()) {\n            final MaterialManufactureSpecification materialManufactureSpecification = materialRecs.get(materialId);\n            final BatchId newBatchId = materialsDataManager.addBatch(BatchConstructionInfo.builder()\n                    .setMaterialsProducerId(materialsProducerId).setMaterialId(materialId).build());\n            materialsDataManager.transferMaterialBetweenBatches(materialManufactureSpecification.getBatchId(),\n                    newBatchId, materialManufactureSpecification.getStageAmount());\n            materialsDataManager.moveBatchToStage(newBatchId, stageId);\n        }\n\n        BatchId newBatchId = materialsDataManager.addBatch(BatchConstructionInfo.builder()\n                .setMaterialsProducerId(materialsProducerId).setMaterialId(Material.ANTIGEN).build());\n        materialsDataManager.transferMaterialBetweenBatches(antigenBatchId, newBatchId, antigenAmountPerBatch);\n        materialsDataManager.moveBatchToStage(newBatchId, stageId);\n\n        final double batchAssemblyStartTime = FastMath.max(actorContext.getTime(), lastBatchAssemblyEndTime);\n        final double fermentationStartTime = batchAssemblyStartTime + batchAssemblyDuration;\n        lastBatchAssemblyEndTime = fermentationStartTime;\n        final double planTime = fermentationStartTime + vaccinePreparationTime;\n        actorContext.addPlan((c) -> endVaccinePreparation(stageId), planTime);\n    }\n}\n\n\nOnce vaccine preparation is complete (Code Block 12.24) for a stage containing the ANTIGEN, ADJUVANT, PRESERVATIVE and STABILIZER materials, the stage is converted into 25 VACCINE units and stored on the producer. The Vaccinator will observe this change in inventory and may transfer the vaccine units to the regions and people as needed.\n\n\nCode Block 12.24: When a vaccine production stage is ready for release, the vaccine producer converts the stage doses of vaccine and places them in its resource inventory.\nprivate void endVaccinePreparation(final StageId stageId) {\n    materialsDataManager.convertStageToResource(stageId, Resource.VACCINE, vaccineUnits);\n    planVaccinePrepartion();\n}"
  },
  {
    "objectID": "ch12-MaterialsPlugin.html#inspecting-the-output",
    "href": "ch12-MaterialsPlugin.html#inspecting-the-output",
    "title": "12  Materials Plugin",
    "section": "12.9 Inspecting the output",
    "text": "12.9 Inspecting the output\n\n12.9.1 Person Property Report\nThe 81 scenarios result in a large amount of output (>1,000,000 rows) in the person property report. It shows the aggregate counts for people across all the person properties.\n\n\n12.9.2 Disease State Report\nAnalysis of the number of recovered people at the end of each simulation shows that R0 and infection threshold needed to start vaccine manufacture play a significant role in the outcome. The number of initial infections and the community contact rate also show the expected positive correlation to the number of recovered, but to a lesser extent.\n\n\n12.9.3 Vaccine Report\nThe vaccine report shows that lower infection thresholds drive an earlier start of vaccine manufacture. However, due to the relatively low production of the vaccine, it still takes 20-23 weeks to vaccinate the entire population.\n\n\n12.9.4 Vaccine Production Report\nThe vaccine production report records the slow build up of ordered materials and conversion of those into vaccines. From the start of the materials collection to the first doses of vaccine being administered is approximately 32 days."
  },
  {
    "objectID": "ch13-PartitionsPlugin.html#plugin-data-initialization",
    "href": "ch13-PartitionsPlugin.html#plugin-data-initialization",
    "title": "13  Partitions Plugin",
    "section": "13.1 Plugin Data Initialization",
    "text": "13.1 Plugin Data Initialization\nPartitions are built dynamically by actors and data managers. While serialization of simulation state exceeds the scope of this chapter, the PartitionsPluginData class contains a single argument to support run-continuity between related experiment executions. The default policy is to not support run continuity and should only be set to true when the need for run continuity exists."
  },
  {
    "objectID": "ch13-PartitionsPlugin.html#plugin-behavior",
    "href": "ch13-PartitionsPlugin.html#plugin-behavior",
    "title": "13  Partitions Plugin",
    "section": "13.2 Plugin Behavior",
    "text": "13.2 Plugin Behavior\nThe plugin adds a single data manager to the simulation as an instance of the PartitionsDataManager that is initialized with the PartitionsPluginData. The plugin has fixed dependencies on the People plugin and the Stochastic plugin. Unlike other plugins, its dependencies are dynamic and provided by the modeler. This topic will be covered later in the example code."
  },
  {
    "objectID": "ch13-PartitionsPlugin.html#data-manager",
    "href": "ch13-PartitionsPlugin.html#data-manager",
    "title": "13  Partitions Plugin",
    "section": "13.3 Data Manager",
    "text": "13.3 Data Manager\nThe PartitionsDataManager provides various operations with partitions. The data manager provides public methods that:\n\nAdd partitions\nRemove partitions\nProvide various queries about the state of partitions\nAllow random sampling of people from partitions\n\nPartitions are referenced by a client-assigned id and are maintained by the data manager. Each partition is composed of a multi-layered filter and zero to many labelers. A labeler is a mechanism for labeling a person based on that person’s characteristics. The labels form the dimensions of the cellular structure of the partition. For example, a labeler could label a person based on their integer age, but convert that age into labels such as “CHILD”, “ADULT” AND “SENIOR”. Labelers can span multiple personal charactertics such as combining regions with ages. For example, the labels might be “EASTERN_SHOOL_AGE_CHILDREN” or “WESTERN_SENIORS”, etc."
  },
  {
    "objectID": "ch13-PartitionsPlugin.html#example-code-lesson-20",
    "href": "ch13-PartitionsPlugin.html#example-code-lesson-20",
    "title": "13  Partitions Plugin",
    "section": "13.4 Example Code (Lesson 20)",
    "text": "13.4 Example Code (Lesson 20)\nExample_20.java shows the use of the partitions plugin. In it we will examine\n\nThe formation of partitions\nThe sampling of partitions\n\nThe example includes seven plugins:\n\nPeople plugin – (GCM core plugin) used to manage people\nPerson properties plugin– (GCM core plugin) used to decorate properties onto people\nGlobal properties plugin– (GCM core plugin) used to store policies and initial conditions\nStochastics plugin – (GCM core plugin) used to generate random numbers used in various decisions\nRegions Plugin– (GCM core plugin) supports the person properties plugin\nPartitions Plugin - (GCM core plugin) used for managing partitions\nModel plugin – (local plugin) used to introduce three actors that will:\n\nLoad the population\nManage infectious contacts\nManage vaccinations"
  },
  {
    "objectID": "ch13-PartitionsPlugin.html#model",
    "href": "ch13-PartitionsPlugin.html#model",
    "title": "13  Partitions Plugin",
    "section": "13.5 Model",
    "text": "13.5 Model\nThe example’s model represents a disease that is preventable through vaccination. A small number of people at the start of the simulation are infected and the rest are susceptible. Vaccination is limited to uninfected adults and three vaccinations are needed to confer full immunity. There is 30 day delay between vaccine doses. The disease is transmitted at random from the infected to the susceptible, there is no incubation period and infectiousness lasts from 3 to 12 days. Vaccine supply is unlimited, but the vaccination rate is fixed with vaccine being assigned using lottery assignment: Older adults and those with the least vaccine protection are given a statistical preference."
  },
  {
    "objectID": "ch13-PartitionsPlugin.html#model-execution",
    "href": "ch13-PartitionsPlugin.html#model-execution",
    "title": "13  Partitions Plugin",
    "section": "13.6 Model Execution",
    "text": "13.6 Model Execution\nThe example’s execution is shown in Code Block 13.1\n\n\nCode Block 13.1: The various plugins are gathered from their initial data and the experiment is executed.\nprivate void execute() {\n    Experiment.builder()//\n            .addPlugin(getGlobalPropertiesPlugin())//\n            .addPlugin(getPersonPropertiesPlugin())//\n            .addPlugin(getRegionsPlugin())//\n            .addPlugin(getStochasticPlugin())//\n            .addPlugin(getPeoplePlugin())//\n            .addPlugin(getPartitionsPlugin())//\n            .addPlugin(ModelPlugin.getModelPlugin())//\n            .addExperimentContextConsumer(getNIOReportItemHandler())//\n            .build()//\n            .execute();\n}\n\n\nThere are several fixed global properties, Code Block 13.2 :\n\nVACCINATOR_TYPE – the type of vaccinator used by the model\nVACCINATIONS_PER_DAY – the number of vaccinations per day allowed\nTRANSMISSION_PROBABILTY – the base probabilty of disease transmission per infectious contact\nINFECTIOUS_CONTACT_RATE – the number of potentially infectious contacts per day per person\nMINIMUM_INFECTIOUS_PERIOD – then minimum number of days that a person is infectious\nMAXIMUM_INFECTIOUS_PERIOD – the maximum number of days that a person is infectious\nINITIAL_INFECTION_COUNT – the number of people who are infectious at the begining of the simulation\nINTER_VACCINATION_DELAY_TIME – the number of days required between a peson’s vaccinations\nPOPULATION_SIZE – the initial size of the population\n\n\n\nCode Block 13.2: The global properties are all fixed values.\nprivate Plugin getGlobalPropertiesPlugin() {\n    GlobalPropertiesPluginData.Builder builder = GlobalPropertiesPluginData.builder();\n    PropertyDefinition propertyDefinition = PropertyDefinition.builder().setPropertyValueMutability(false)\n            .setDefaultValue(10_000).setType(Integer.class).build();\n    builder.defineGlobalProperty(GlobalProperty.POPULATION_SIZE, propertyDefinition, 0);\n\n    propertyDefinition = PropertyDefinition.builder().setPropertyValueMutability(false).setDefaultValue(10)\n            .setType(Integer.class).build();\n    builder.defineGlobalProperty(GlobalProperty.INITIAL_INFECTION_COUNT, propertyDefinition, 0);\n\n    propertyDefinition = PropertyDefinition.builder().setPropertyValueMutability(false)\n            .setDefaultValue(VaccinatorType.PARTITION).setType(VaccinatorType.class).build();\n    builder.defineGlobalProperty(GlobalProperty.VACCINATOR_TYPE, propertyDefinition, 0);\n\n    propertyDefinition = PropertyDefinition.builder().setPropertyValueMutability(false).setDefaultValue(3.0)\n            .setType(Double.class).build();\n    builder.defineGlobalProperty(GlobalProperty.MINIMUM_INFECTIOUS_PERIOD, propertyDefinition, 0);\n\n    propertyDefinition = PropertyDefinition.builder().setPropertyValueMutability(false).setDefaultValue(12.0)\n            .setType(Double.class).build();\n    builder.defineGlobalProperty(GlobalProperty.MAXIMUM_INFECTIOUS_PERIOD, propertyDefinition, 0);\n\n    propertyDefinition = PropertyDefinition.builder().setPropertyValueMutability(false).setDefaultValue(2.0)\n            .setType(Double.class).build();\n    builder.defineGlobalProperty(GlobalProperty.INFECTIOUS_CONTACT_RATE, propertyDefinition, 0);\n\n    propertyDefinition = PropertyDefinition.builder().setPropertyValueMutability(false).setDefaultValue(0.15)\n            .setType(Double.class).build();\n    builder.defineGlobalProperty(GlobalProperty.TRANSMISSION_PROBABILTY, propertyDefinition, 0);\n\n    propertyDefinition = PropertyDefinition.builder().setPropertyValueMutability(false).setDefaultValue(100)\n            .setType(Integer.class).build();\n    builder.defineGlobalProperty(GlobalProperty.VACCINATIONS_PER_DAY, propertyDefinition, 0);\n\n    propertyDefinition = PropertyDefinition.builder().setPropertyValueMutability(false).setDefaultValue(30.0)\n            .setType(Double.class).build();\n    builder.defineGlobalProperty(GlobalProperty.INTER_VACCINATION_DELAY_TIME, propertyDefinition, 0);\n\n    GlobalPropertiesPluginData globalPropertiesPluginData = builder.build();\n    return GlobalPropertiesPlugin.builder().setGlobalPropertiesPluginData(globalPropertiesPluginData)\n            .getGlobalPropertiesPlugin();\n}\n\n\nThe person properties plugin contains four properties, Code Block 13.3:\n\nAGE – the integer age of a person\nWAITING_FOR_NEXT_DOSE – Boolean indicating that it is too soon to administer another dose of the vaccine\nVACCINATION_COUNT – the number or vaccinations received\nDISEASE_STATE – the state of the disease: SUSCEPTIBLE, INFECTIOUS or RECOVERED\n\n\n\nCode Block 13.3: The four person properties are defined.\nprivate Plugin getPersonPropertiesPlugin() {\n    Builder builder = PersonPropertiesPluginData.builder();\n\n    PropertyDefinition propertyDefinition = PropertyDefinition.builder()//\n            .setPropertyValueMutability(false).setType(Integer.class).build();\n    builder.definePersonProperty(PersonProperty.AGE, propertyDefinition, 0.0, false);\n\n    propertyDefinition = PropertyDefinition.builder()//\n            .setPropertyValueMutability(true).setType(Boolean.class)//\n            .setDefaultValue(false).build();\n    builder.definePersonProperty(PersonProperty.WAITING_FOR_NEXT_DOSE, propertyDefinition, 0.0, false);\n\n    propertyDefinition = PropertyDefinition.builder()//\n            .setPropertyValueMutability(true)//\n            .setType(DiseaseState.class).setDefaultValue(DiseaseState.SUSCEPTIBLE).build();\n    builder.definePersonProperty(PersonProperty.DISEASE_STATE, propertyDefinition, 0.0, false);\n\n    propertyDefinition = PropertyDefinition.builder()//\n            .setPropertyValueMutability(true)//\n            .setType(Integer.class)//\n            .setDefaultValue(0)//\n            .build();\n    builder.definePersonProperty(PersonProperty.VACCINATION_COUNT, propertyDefinition, 0.0, false);\n\n    PersonPropertiesPluginData personPropertiesPluginData = builder.build();\n    return PersonPropertiesPlugin.builder()//\n            .setPersonPropertiesPluginData(personPropertiesPluginData)//\n            .getPersonPropertyPlugin();\n}\n\n\nThe regions plugin contains three regions that will be randomly assigned to people. It exists to fulfill a dependency of the person properties plugin. The stochastics and people plugins are similarly minimal.\nThe partitions plugin is initialized in Code Block 13.4. It requires dependencies on those plugins that will be used to calculate partition filters and labelers. This runs counter to intuition since the model plugin (via its actors) is using the partitions plugin. However, the partitions data manager needs to keep the partitions current with the state of people. In the example model, all partitions use person properties, so the person properties plugin must process events before the partitions plugin.\n\n\nCode Block 13.4: The partitions plugin is simple, but requires that it has dependencies on those plugins that will be used to calculate partition filters and labelers.\nprivate Plugin getPartitionsPlugin() {\n    PartitionsPluginData partitionsPluginData = PartitionsPluginData.builder()//\n            .setRunContinuitySupport(false).build();\n\n    return PartitionsPlugin.builder()//\n            .setPartitionsPluginData(partitionsPluginData)//\n            .addPluginDependency(PersonPropertiesPluginId.PLUGIN_ID)//\n            .getPartitionsPlugin();\n}"
  },
  {
    "objectID": "ch13-PartitionsPlugin.html#experiment-dimensions",
    "href": "ch13-PartitionsPlugin.html#experiment-dimensions",
    "title": "13  Partitions Plugin",
    "section": "13.7 Experiment dimensions",
    "text": "13.7 Experiment dimensions\nThere are no experiment dimensions in this example with a single scenario being executed."
  },
  {
    "objectID": "ch13-PartitionsPlugin.html#the-actors",
    "href": "ch13-PartitionsPlugin.html#the-actors",
    "title": "13  Partitions Plugin",
    "section": "13.8 The Actors",
    "text": "13.8 The Actors\n\n13.8.1 Population Loader\nThe population loader adds 10,000 people to the simulation in Code Block 13.5. Each person is assigned a randomly chosen region. All person properties are left at default value except for AGE which is generated randomly.\n\n\nCode Block 13.5: People are added to the simulation with region and age assignments.\npublic class PopulationLoader {\n    public void init(ActorContext actorContext) {\n        StochasticsDataManager stochasticsDataManager = actorContext.getDataManager(StochasticsDataManager.class);\n        Well randomGenerator = stochasticsDataManager.getRandomGenerator();\n        PeopleDataManager peopleDataManager = actorContext.getDataManager(PeopleDataManager.class);\n        GlobalPropertiesDataManager globalPropertiesDataManager = actorContext\n                .getDataManager(GlobalPropertiesDataManager.class);\n        Integer populationSize = globalPropertiesDataManager.getGlobalPropertyValue(GlobalProperty.POPULATION_SIZE);\n        for (int i = 0; i < populationSize; i++) {\n            Region region = Region.getRandomRegion(randomGenerator);\n            int age = AgeGroup.getRandomAge(randomGenerator);\n            PersonPropertyValueInitialization personPropertyValueInitialization = new PersonPropertyValueInitialization(PersonProperty.AGE,age);\n            PersonConstructionData personConstructionData = PersonConstructionData.builder()//\n                    .add(region)//\n                    .add(personPropertyValueInitialization)\n                    .build();//\n            peopleDataManager.addPerson(personConstructionData);\n        }\n    }\n}\n\n\n\n\n13.8.2 Contact Manager\nThe ContactManager actor, Code Block 13.6, schedules infectious contacts between infected people and the susceptible population. On its initialization, it establishes various parameters from the global variables and schedules the initial infections. It uses a simple partition configured in its default state. It has no filter and no labelers, so it will include all people in the simulation. It is used to select random people for potential infectious contacts and is somewhat more efficient than storing a list of all people locally.\n\n\nCode Block 13.6: The Contact Manager uses a simple partition that contains the entire population and uses it to randomly select infectious contacts.\npublic void init(ActorContext actorContext) {\n    this.actorContext = actorContext;\n    partitionsDataManager = actorContext.getDataManager(PartitionsDataManager.class);\n    personPropertiesDataManager = actorContext.getDataManager(PersonPropertiesDataManager.class);\n    peopleDataManager = actorContext.getDataManager(PeopleDataManager.class);\n    globalPropertiesDataManager = actorContext.getDataManager(GlobalPropertiesDataManager.class);\n    StochasticsDataManager stochasticsDataManager = actorContext.getDataManager(StochasticsDataManager.class);\n    randomGenerator = stochasticsDataManager.getRandomGenerator();\n\n    loadGlobalProperties();\n    establishPopulationPartition();\n    initializeInfections();\n}\n\nprivate void establishPopulationPartition() {\n    partitionsDataManager.addPartition(Partition.builder().build(), partitionKey);\n}\n\n\nInfection of a person, Code Block 13.7, results in the immediate scheduling of infectious contacts. The person is infectious for 3 to 12 days and will have 2 contacts per day. Each contact has a base 15% probability of infecting the contacted person, Code Block 13.8. Susceptible people who have been previously vaccinated have a reduced chance of contracting the disease. Note that the partition is used to select the contacted person and that the infectious person is excluded from contact since a person cannot contact themselves.\n\n\nCode Block 13.7: Each time a person is infected, the contact manager schedules several follow-on infectious contacts.\nprivate void infectPerson(PersonId personId) {\n    personPropertiesDataManager.setPersonPropertyValue(personId, PersonProperty.DISEASE_STATE,\n            DiseaseState.INFECTIOUS);\n\n    double infectiousPeriod = randomGenerator.nextDouble() * (maximumInfectiousPeriod - minimumInfectiousPeriod)\n            + minimumInfectiousPeriod;\n\n    double lastContactTime = actorContext.getTime() + infectiousPeriod;\n\n    double infectionTime = actorContext.getTime();\n    while (true) {\n        double contactDelay = (1.0 / infectiousContactRate);\n        contactDelay *= (1 + randomGenerator.nextDouble() / 5 - 0.1);\n        infectionTime += contactDelay;\n\n        if (infectionTime < lastContactTime) {\n            actorContext.addPlan((c2) -> {\n                processInfectiousContact(personId);\n            }, infectionTime);\n        } else {\n            break;\n        }\n    }\n    actorContext.addPlan((c2) -> {\n        endInfectiousness(personId);\n    }, lastContactTime);\n\n}\n\n\n\n\nCode Block 13.8: Infectious contacts are subject to mitigation. To be infected, the contacted person must be susceptible and may having varying degrees of protection from previous vaccinations.\nprivate void processInfectiousContact(PersonId personId) {\n    \n    PartitionSampler partitionSampler = PartitionSampler.builder().setExcludedPerson(personId).build();\n    Optional<PersonId> optionalPersonId = partitionsDataManager.samplePartition(partitionKey, partitionSampler);\n    if (optionalPersonId.isPresent()) {\n\n        PersonId contactedPersonId = optionalPersonId.get();\n        \n\n        DiseaseState diseaseState = personPropertiesDataManager.getPersonPropertyValue(contactedPersonId,\n                PersonProperty.DISEASE_STATE);\n        if (diseaseState == DiseaseState.SUSCEPTIBLE) {\n\n            int vaccinationCount = personPropertiesDataManager.getPersonPropertyValue(contactedPersonId,\n                    PersonProperty.VACCINATION_COUNT);\n            double mitigatedTransmissionProbability;\n\n            switch (vaccinationCount) {\n            case 0:\n                mitigatedTransmissionProbability = 1;\n                break;\n            case 1:\n                mitigatedTransmissionProbability = 0.5;\n                break;\n            case 2:\n                mitigatedTransmissionProbability = 0.2;\n                break;\n            default:\n                mitigatedTransmissionProbability = 0;\n                break;\n            }\n\n            mitigatedTransmissionProbability *= transmissionProbabilty;\n\n            if (randomGenerator.nextDouble() < mitigatedTransmissionProbability) {\n                infectPerson(contactedPersonId);\n            }\n        }\n    }\n\n}\n\n\n\n\n13.8.3 Vaccinator Manager\nThis example contains three versions of the vaccinator actor that demonstrate an evolving solution to person selection. The vaccine manager, Code Block 13.9, uses the global property,VACCINATOR_TYPE, to create an instance of the vaccinator actor. The global property is set to the partition vaccinator and the remaining two possibilities are left for reader inspection.\n\n\nCode Block 13.9: The vaccine manager creates one of three vaccinator actors based on the global property,VACCINATOR_TYPE.\npublic class VaccinatorManager {\n    public void init(ActorContext actorContext) {\n        GlobalPropertiesDataManager globalPropertiesDataManager = actorContext.getDataManager(GlobalPropertiesDataManager.class);\n        VaccinatorType vaccinatorType =\n        globalPropertiesDataManager.getGlobalPropertyValue(GlobalProperty.VACCINATOR_TYPE);\n        switch (vaccinatorType) {\n        case PARTITION:\n            actorContext.addActor(new PartitionVaccinator()::init);\n            break;\n        case EVENT:\n            actorContext.addActor(new EventVaccinator()::init);\n            break;\n        case INSPECTION:\n            actorContext.addActor(new InspectionVaccinator()::init);\n            break;\n        default:\n            throw new RuntimeException(\"unhandled case \"+vaccinatorType);                       \n        }\n    }\n}\n\n\n\n\n13.8.4 Inspection Vaccinator\nThe inspection vaccinator represents the most obvious approach to finding the next person to vaccinate. It initializes, Code Block 13.10, and immediately starts vaccinating the population.\n\n\nCode Block 13.10: The inspection-based vaccinator establishes its working variables and begins planning the next vaccination.\npublic void init(ActorContext actorContext) {\n    this.actorContext = actorContext;\n\n    StochasticsDataManager stochasticsDataManager = actorContext.getDataManager(StochasticsDataManager.class);\n    randomGenerator = stochasticsDataManager.getRandomGenerator();\n    personPropertiesDataManager = actorContext.getDataManager(PersonPropertiesDataManager.class);\n    peopleDataManager = actorContext.getDataManager(PeopleDataManager.class);\n    globalPropertiesDataManager = actorContext.getDataManager(GlobalPropertiesDataManager.class);\n\n    establishWorkingVaribles();\n    planNextVaccination();\n}\n\n\nEach vaccine attempt repeats the following steps, Code Block 13.11:\n\nGather the list of all people\nBuild data structures to hold those people in separate groups aligned to age and vaccination status priorities\nLoop through the population, selecting people who:\n\nAre adults\nAre not infectious or recovered\nHave fewer that 3 vaccinations\nAre not the in post-vaccination 30 day waiting period\n\nAssign each selected person to an age/vaccination count category\nNote if there are people who will need vaccination in the future after the waiting period is over\nSelect a category based on the weight, Code Block 13.12, of the category and the number of people who are associated with the category\nSelect a person at random from the selected category\nIf a person was selected or a future vaccination will be needed, choose to continue the vaccination process\n\n\n\nCode Block 13.11: The inspection-based vaccinator vaccinates 100 people per day. Each vaccination attempt considers every person in the simulation.\nprivate void planNextVaccination() {\n    actorContext.addPlan(this::vaccinatePerson, interVaccinationTime + actorContext.getTime());\n}\n\n\nprivate void vaccinatePerson(ActorContext actorContext) {\n    List<PersonId> people = peopleDataManager.getPeople();\n    Map<MultiKey, List<PersonId>> candidates = new LinkedHashMap<>();\n    Map<MultiKey, Double> weights = new LinkedHashMap<>();\n\n    List<AgeGroup> eligibleAgeGroups = new ArrayList<>();\n    eligibleAgeGroups.add(AgeGroup.ADULT_18_44);\n    eligibleAgeGroups.add(AgeGroup.ADULT_45_64);\n    eligibleAgeGroups.add(AgeGroup.SENIOR);\n\n    List<Integer> eligibleVaccineCounts = new ArrayList<>();\n    eligibleVaccineCounts.add(0);\n    eligibleVaccineCounts.add(1);\n    eligibleVaccineCounts.add(2);\n\n    for (AgeGroup ageGroup : eligibleAgeGroups) {\n        for (Integer vaccineCount : eligibleVaccineCounts) {\n            MultiKey multiKey = new MultiKey(ageGroup, vaccineCount);\n            double weight = getWeight(ageGroup, vaccineCount);\n            weights.put(multiKey, weight);\n            candidates.put(multiKey, new ArrayList<>());\n        }\n    }\n\n    potentialEligiblePeopleExist = false;\n\n    for (PersonId personId : people) {\n        int age = personPropertiesDataManager.getPersonPropertyValue(personId, PersonProperty.AGE);\n        if (age < 18) {\n            continue;\n        }\n        DiseaseState diseaseState = personPropertiesDataManager.getPersonPropertyValue(personId,\n                PersonProperty.DISEASE_STATE);\n        if (diseaseState != DiseaseState.SUSCEPTIBLE) {\n            continue;\n        }\n        int vaccinationCount = personPropertiesDataManager.getPersonPropertyValue(personId,\n                PersonProperty.VACCINATION_COUNT);\n        if (vaccinationCount > 2) {\n            continue;\n        }\n\n        boolean waitingFromPreviousVaccination = personPropertiesDataManager.getPersonPropertyValue(personId,\n                PersonProperty.WAITING_FOR_NEXT_DOSE);\n\n        if (waitingFromPreviousVaccination) {\n            potentialEligiblePeopleExist = true;\n            continue;\n        }\n\n        AgeGroup ageGroup = AgeGroup.getAgeGroup(age);\n        MultiKey multiKey = new MultiKey(ageGroup, vaccinationCount);\n        candidates.get(multiKey).add(personId);\n    }\n\n    Map<MultiKey, Double> extendedWeights = new LinkedHashMap<>();\n\n    double sumOfExtendedWeights = 0;\n    for (MultiKey multiKey : weights.keySet()) {\n        Double weight = weights.get(multiKey);\n        int candidateCount = candidates.get(multiKey).size();\n        Double extenedWeight = weight * candidateCount;\n        extendedWeights.put(multiKey, extenedWeight);\n        sumOfExtendedWeights += extenedWeight;\n    }\n\n    PersonId selectedCandidate = null;\n\n    double selectedWeight = sumOfExtendedWeights * randomGenerator.nextDouble();\n    for (MultiKey multiKey : extendedWeights.keySet()) {\n        Double extendedWeight = extendedWeights.get(multiKey);\n        selectedWeight -= extendedWeight;\n        if (selectedWeight <= 0) {\n            List<PersonId> seletedCandidates = candidates.get(multiKey);\n            if (!seletedCandidates.isEmpty()) {\n                int index = randomGenerator.nextInt(seletedCandidates.size());\n                selectedCandidate = seletedCandidates.get(index);\n            }\n            break;\n        }\n    }\n\n    if (selectedCandidate != null) {\n\n        int vaccinationCount = personPropertiesDataManager.getPersonPropertyValue(selectedCandidate,\n                PersonProperty.VACCINATION_COUNT);\n        vaccinationCount++;\n        personPropertiesDataManager.setPersonPropertyValue(selectedCandidate, PersonProperty.VACCINATION_COUNT,\n                vaccinationCount);\n        if (vaccinationCount < 3) {\n            personPropertiesDataManager.setPersonPropertyValue(selectedCandidate,\n                    PersonProperty.WAITING_FOR_NEXT_DOSE, true);\n            planWaitTermination(selectedCandidate);\n        }\n        planNextVaccination();\n    } else {\n        if (potentialEligiblePeopleExist) {\n            planNextVaccination();\n        }\n    }\n}\n\n\n\n\nCode Block 13.12: The inspection-based vaccinator assigns a probability weight to each person based on their age and number of vaccine doses administered.\nprivate double getWeight(AgeGroup ageGroup, int vaccineCount) {\n\n    double result = 1;\n\n    switch (ageGroup) {\n    case ADULT_18_44:\n        result += 0;\n        break;\n    case ADULT_45_64:\n        result += 3;\n        break;\n    case CHILD:\n        result += 0;\n        break;\n    case SENIOR:\n        result += 10;\n        break;\n    default:\n        break;\n    }\n\n    switch (vaccineCount) {\n    case 0:\n        result += 4;\n        break;\n    case 1:\n        result += 3;\n        break;\n    case 2:\n        result += 2;\n        break;\n    default:\n        result += 0;\n        break;\n    }\n\n    return result;\n}\n\n\nWhile this process is fairly straight forward, it does involve fairly complex and tricky calculations. Worse yet, it is extremely repetitive and does not scale well to realistic population sizes. It is orders of magnitude slower than the next two approaches.\n\n\n13.8.5 Event Vaccinator\nThe event vaccinator transforms the inspection vaccinator’s approach by retaining the category organizational structures and using the event system to maintain the lists of eligible people. It initializes, Code Block 13.13, by building the sub-populations of eligible people and subscribing to all events that may alter those populations.\n\n\nCode Block 13.13: The event-based vaccinator improves on the inspection-based vaccinator by maintaining the eligible sub-populations.\npublic void init(ActorContext actorContext) {\n    this.actorContext = actorContext;\n\n    StochasticsDataManager stochasticsDataManager = actorContext.getDataManager(StochasticsDataManager.class);\n    randomGenerator = stochasticsDataManager.getRandomGenerator();\n    personPropertiesDataManager = actorContext.getDataManager(PersonPropertiesDataManager.class);\n    peopleDataManager = actorContext.getDataManager(PeopleDataManager.class);\n    globalPropertiesDataManager = actorContext.getDataManager(GlobalPropertiesDataManager.class);\n\n    establishWorkingVaribles();\n    subscribeToPersonPropertyUpdateEvents();\n    intializeCandidatesAndWeights();\n    planNextVaccination();\n}\n\n\nThe vaccination process is very similar to the inspection-based method, but there is no recalculation of the sub-populations, Code Block 13.14. Instead, the event-based approach subscribes to all person property updates, Code Block 13.15 , and processes each update by:\n\nRemoving the relevant person from the sub-populations\nFiltering out people who :\n\nAre not susceptible\nAre not adults\nAre waiting from the last dose\nAlready have 3 vaccinations\n\nAdding the person back into the sub-populations. Note the person may have moved from one sub-population to another.\n\n\n\nCode Block 13.14: The event-based vaccinator selects from maintained sub-populations.\nprivate void planNextVaccination() {\n    Plan<ActorContext> plan = Plan.builder(ActorContext.class)//\n            .setTime(interVaccinationTime + actorContext.getTime())//\n            .setKey(planId).setCallbackConsumer(this::vaccinatePerson).build();\n\n    actorContext.addPlan(plan);\n}\n\nprivate void vaccinatePerson(ActorContext actorContext) {\n\n    Map<MultiKey, Double> extendedWeights = new LinkedHashMap<>();\n\n    double sumOfExtendedWeights = 0;\n    for (MultiKey multiKey : weights.keySet()) {\n        Double weight = weights.get(multiKey);\n        int candidateCount = candidates.get(multiKey).size();\n        Double extenedWeight = weight * candidateCount;\n        extendedWeights.put(multiKey, extenedWeight);\n        sumOfExtendedWeights += extenedWeight;\n    }\n\n    PersonId selectedCandidate = null;\n\n    double selectedWeight = sumOfExtendedWeights * randomGenerator.nextDouble();\n    for (MultiKey multiKey : extendedWeights.keySet()) {\n        Double extendedWeight = extendedWeights.get(multiKey);\n        selectedWeight -= extendedWeight;\n        if (selectedWeight <= 0) {\n            List<PersonId> seletedCandidates = candidates.get(multiKey);\n            if (!seletedCandidates.isEmpty()) {\n                int index = randomGenerator.nextInt(seletedCandidates.size());\n                selectedCandidate = seletedCandidates.get(index);\n            }\n            break;\n        }\n    }\n\n    if (selectedCandidate != null) {\n\n        int vaccinationCount = personPropertiesDataManager.getPersonPropertyValue(selectedCandidate,\n                PersonProperty.VACCINATION_COUNT);\n        vaccinationCount++;\n        personPropertiesDataManager.setPersonPropertyValue(selectedCandidate, PersonProperty.VACCINATION_COUNT,\n                vaccinationCount);\n        if (vaccinationCount < 3) {\n            personPropertiesDataManager.setPersonPropertyValue(selectedCandidate,\n                    PersonProperty.WAITING_FOR_NEXT_DOSE, true);\n            planWaitTermination(selectedCandidate);\n        }\n        planNextVaccination();\n    }\n\n}\n\n\n\n\nCode Block 13.15: The event-based vaccinator processes each person property update event by first removing the person from the sub-populations and then adding them back in if required.\nprivate void handlePersonPropertyChange(ActorContext actorContext,\n        PersonPropertyUpdateEvent personPropertyUpdateEvent) {\n\n    PersonId personId = personPropertyUpdateEvent.personId();\n\n    // remove the person if they are being tracked\n    MultiKey multiKey = groupMap.remove(personId);\n    List<PersonId> list = candidates.get(multiKey);\n    if (list != null) {\n        list.remove(personId);\n    }\n\n    DiseaseState diseaseState = personPropertiesDataManager.getPersonPropertyValue(personId,\n            PersonProperty.DISEASE_STATE);\n\n    // the person must be susceptible\n    if (diseaseState != DiseaseState.SUSCEPTIBLE) {\n        return;\n    }\n\n    Integer vaccinationCount = personPropertiesDataManager.getPersonPropertyValue(personId,\n            PersonProperty.VACCINATION_COUNT);\n\n    if (vaccinationCount > 2) {\n        return;\n    }\n\n    int age = personPropertiesDataManager.getPersonPropertyValue(personId, PersonProperty.AGE);\n    AgeGroup ageGroup = AgeGroup.getAgeGroup(age);\n    if (ageGroup == AgeGroup.CHILD) {\n        return;\n    }\n    boolean waitingForNextDose = personPropertiesDataManager.getPersonPropertyValue(personId,\n            PersonProperty.WAITING_FOR_NEXT_DOSE);\n    if (waitingForNextDose) {\n        return;\n    }\n\n    multiKey = new MultiKey(ageGroup, vaccinationCount);\n\n    list = candidates.get(multiKey);\n    if (list != null) {\n        list.add(personId);\n        groupMap.put(personId, multiKey);\n    }\n\n}\n\n\nSome care must be given to properly terminating the vaccination process. When a vaccination attempt is made and there is no eligible candidate, no new attempt is scheduled. Instead, the vaccinator relies on knowing that a new candidate will appear only when a person has ended their post-vaccination waiting period. To accomplish this, Code Block 13.16, the vaccinator uses a plan id for vaccination plans. When it processes the end of the waiting period for a person it looks to the simulation and determines whether there is a future plan to vaccinate. If no such plan exists, it immediately vaccinates the person and re-starts the vaccination process.\n\n\nCode Block 13.16: The event-vaccinator can restart the vaccination process when a person becomes eligible after the post-vacination waiting period is over.\nprivate void endWaitTime(PersonId personId) {\n    personPropertiesDataManager.setPersonPropertyValue(personId, PersonProperty.WAITING_FOR_NEXT_DOSE, false);\n    if (actorContext.getPlan(planId).isEmpty()) {\n        vaccinatePerson(actorContext);\n    }\n}\n\n\nThe performance of the code is multiple orders of magnitude better than the inspection approach. However, there are a few drawbacks:\n\nThe code is more complex and is more difficult to get right. Edge cases abound.\nIt still relies on list/map/set based data structures which can be slow and use too much memory.\nIf the selection criteria were to become more complex or if the actor needs to select people from subsets of the eligible people for special purposes as occurs in more realistic use cases, a great deal of effort would have to expended to ensure correctly functioning code.\n\n\n\n13.8.6 Partition Vaccinator\nThe partition-vaccinator improves on the event-vaccinator by using partitions. Internally, the partitions are performing similar event-triggered updates of the sub-populations. However, their approach is more sophisticated:\n\nSupports complex filtering\nAllows for categorization of data via labels\nSupports multi-dimensional labeling of the filtered population\nSupports nuanced sampling of the population that can be aligned to label based subsets\n\nThe vaccinator initializes, Code Block 13.17, by creating partitions that will manage the data structures and subscribe to the relevant events. It then proceeds with vaccination planning as in the previous versions.\n\n\nCode Block 13.17: The partition-vaccinator manages the eligible population via partitions.\npublic void init(ActorContext actorContext) {\n    this.actorContext = actorContext;\n    personPropertiesDataManager = actorContext.getDataManager(PersonPropertiesDataManager.class);\n    partitionsDataManager = actorContext.getDataManager(PartitionsDataManager.class);\n    globalPropertiesDataManager = actorContext.getDataManager(GlobalPropertiesDataManager.class);\n    establishWorkingVaribles();\n    createPartitions();\n    planNextVaccination();\n}\n\n\nThe vaccinator uses two partitions to manage vaccination, Code Block 13.18. The first partition is used to select currently eligible people and the second covers people who may become eligible in the future and is used to determine if vaccination of the population is complete.\n\n\nCode Block 13.18: The partition-vaccinator creates two partitions to help with person selection and termination of vaccinations.\nprivate void createPartitions() {\n\n    PersonPropertyFilter ageFilter = new PersonPropertyFilter(PersonProperty.AGE, Equality.GREATER_THAN_EQUAL, 18);\n\n    PersonPropertyFilter diseaseFilter = new PersonPropertyFilter(PersonProperty.DISEASE_STATE, Equality.EQUAL,\n            DiseaseState.SUSCEPTIBLE);\n\n    PersonPropertyFilter vaccineFilter = new PersonPropertyFilter(PersonProperty.VACCINATION_COUNT,\n            Equality.LESS_THAN, 3);\n\n    PersonPropertyFilter waitFilter = new PersonPropertyFilter(PersonProperty.WAITING_FOR_NEXT_DOSE, Equality.EQUAL,\n            false);\n\n    Filter filter = ageFilter.and(diseaseFilter).and(vaccineFilter).and(waitFilter);\n\n    Labeler ageLabeler = new FunctionalPersonPropertyLabeler(PersonProperty.AGE,\n            (value) -> AgeGroup.getAgeGroup((Integer) value));\n\n    Labeler vaccineCountLabeler = new FunctionalPersonPropertyLabeler(PersonProperty.VACCINATION_COUNT,\n            (value) -> value);\n\n    Partition partition = Partition.builder()//\n            .setFilter(filter)//\n            .addLabeler(ageLabeler)//\n            .addLabeler(vaccineCountLabeler)//\n            .build();\n\n    partitionsDataManager.addPartition(partition, currentlyEligibleKey);\n\n    filter = ageFilter.and(diseaseFilter).and(vaccineFilter);\n    partition = Partition.builder()//\n            .setFilter(filter)//\n            .build();\n\n    partitionsDataManager.addPartition(partition, potentiallyEligibleKey);\n}\n\n\nThe first step in this process is to create the filter that will pass only eligible people. Filters are provided as extensions of the Filter.java class in the partitions plugin. The plugin contains base filter implementations for the logical operators of AND, OR, NOT, TRUE, and FALSE. Nearly all plugins provide more refined filters via the plugin’s support package. In the example code, we create four filters that select:\n\nAdults\nPeople who are susceptible\nPeople who have received fewer that 3 vaccinations\nPeople who have not been recently vaccinated\n\nAll these filters are based on person properties, so we use the PersonPropertyFilter class provided by the person properties plugin. We combine the filters using the AND operator native to all filters.\nWe need to select people not only on their membership in the partition, but also on their personal properties, preferring older people and those who have had fewer vaccinations. Thus we will be using weighted selection and will use labelers assign weight to the cells in the partition. The nine cells are formed from the combinations of :\n\nADULT_18_44, ADULT_45_64, SENIOR\nVACCINATION_COUNT = 0, 1, 2\n\nThe two labelers will use the FunctionalPersonPropertyLabeler class to specify the transformation of values into labels. Note that the age labeler is converting an integer age value into an AgeGroup while the vaccination count labeler is simply returning the vaccination count. The resulting partition is formed from the filter and the two labelers and is added to the partitions data manager under the ‘currentlyEligibleKey’ key value. This partition will be used to select a new person to vaccinate each time a vaccination comes due.\nThe next partition uses a reduced filter that allows for people who have been recently vaccinated but are not fully vaccinated. It does not require any labelers since we will use this partition only to determine if vaccinations should continue to be scheduled.\nThe vaccination process, Code Block 13.19, greatly simplifies the previous designs. The decision to continue vaccination is based on the potentially eligible population containing at least one person. Selection of a person from the currently eligible population uses a PartitionSampler, which specifies how the partition is to perform the sample. In this case we are only providing the weighting function that assigns a weighting value to each of the nine categories. Other capabilities of the PartitionSampler include:\n\nExcluding a particular person – useful for contact management\nLimiting sampling to a constrained portion of the cells that compose the partition\nSelecting a specific random number generator for the sampling process\n\nThe resulting code is easier to refactor, less error prone and executes much faster with far less memory than the previous implementations. Cells in the partition are dynamically allocated to multiple implementations that can approach 1.3 bits per person in the population while maintaining O(ln(n) ) performance for sampling.\n\n\nCode Block 13.19: The partition-vaccinator schedules and executes vaccinations using partitions.\nprivate void planNextVaccination() {\n    if (partitionsDataManager.getPersonCount(potentiallyEligibleKey) == 0) {\n        return;\n    }\n    actorContext.addPlan(this::vaccinatePerson, vaccinatorDelay + actorContext.getTime());\n}\n\nprivate void vaccinatePerson(ActorContext actorContext) {\n\n    PartitionSampler partitionSampler = PartitionSampler.builder()//\n            .setLabelSetWeightingFunction(this::getWeight)//\n            .build();\n\n    Optional<PersonId> optionalPersonId = partitionsDataManager.samplePartition(currentlyEligibleKey,\n            partitionSampler);\n    if (optionalPersonId.isPresent()) {\n        PersonId personId = optionalPersonId.get();\n        int vaccinationCount = personPropertiesDataManager.getPersonPropertyValue(personId,\n                PersonProperty.VACCINATION_COUNT);\n        vaccinationCount++;\n        personPropertiesDataManager.setPersonPropertyValue(personId, PersonProperty.VACCINATION_COUNT,\n                vaccinationCount);\n        if (vaccinationCount < 3) {\n            personPropertiesDataManager.setPersonPropertyValue(personId, PersonProperty.WAITING_FOR_NEXT_DOSE,\n                    true);\n            planWaitTermination(personId);\n        }\n\n    }\n    planNextVaccination();\n}"
  },
  {
    "objectID": "ch13-PartitionsPlugin.html#inspecting-the-output",
    "href": "ch13-PartitionsPlugin.html#inspecting-the-output",
    "title": "13  Partitions Plugin",
    "section": "13.9 Inspecting the output",
    "text": "13.9 Inspecting the output\n\n13.9.1 Disease State Report\nThe disease state report, Figure 13.1, records the number of people having various vaccine counts, disease state and age grouping at the end of the simulation. The results show that the vaccination rate is not sufficient to prevent the majority of infections, but does reflect vaccination eligibility and prioritization rules. The results here are for the partition vaccinator, but the results for the other vaccinators are similar. Since each implementation has subtle ordering differences when choosing people to vaccinate, the results vary by amounts that would correspond to changes in the stochastic seed value.\n\n\n\nFigure 13.1: The experiment's single scenario showing expected vaccinations for different age groups.\n\n\n\n\n\n\nscenario\n\n\nage_group\n\n\ndisease_state\n\n\nvaccinations\n\n\npeople\n\n\n\n\n\n\n0\n\n\nCHILD\n\n\nRECOVERED\n\n\n0\n\n\n1599\n\n\n\n\n0\n\n\nSENIOR\n\n\nRECOVERED\n\n\n0\n\n\n377\n\n\n\n\n0\n\n\nADULT_18_44\n\n\nRECOVERED\n\n\n0\n\n\n1745\n\n\n\n\n0\n\n\nADULT_45_64\n\n\nRECOVERED\n\n\n0\n\n\n1018\n\n\n\n\n0\n\n\nADULT_18_44\n\n\nRECOVERED\n\n\n1\n\n\n591\n\n\n\n\n0\n\n\nADULT_18_44\n\n\nSUSCEPTIBLE\n\n\n3\n\n\n1253\n\n\n\n\n0\n\n\nSENIOR\n\n\nSUSCEPTIBLE\n\n\n3\n\n\n742\n\n\n\n\n0\n\n\nADULT_45_64\n\n\nSUSCEPTIBLE\n\n\n3\n\n\n1026\n\n\n\n\n0\n\n\nCHILD\n\n\nSUSCEPTIBLE\n\n\n0\n\n\n553\n\n\n\n\n0\n\n\nSENIOR\n\n\nRECOVERED\n\n\n1\n\n\n484\n\n\n\n\n0\n\n\nADULT_45_64\n\n\nRECOVERED\n\n\n1\n\n\n568\n\n\n\n\n0\n\n\nADULT_45_64\n\n\nRECOVERED\n\n\n2\n\n\n19\n\n\n\n\n0\n\n\nADULT_18_44\n\n\nRECOVERED\n\n\n2\n\n\n10\n\n\n\n\n0\n\n\nSENIOR\n\n\nRECOVERED\n\n\n2\n\n\n15"
  }
]